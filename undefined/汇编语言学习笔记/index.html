<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">汇编语言学习笔记（注：本篇笔记均摘自一位热心的B站用户---_惜取少年时_） | 欢迎来到Franの杂货铺</title>
  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <meta name="browsermode" content="application">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "KitholtFrank";
  mashiro_option.author_name = "Frank";
  mashiro_option.site_url = "https://kitholt.github.io/";
  mashiro_option.v_appId = "vK4njxg3C8GQOr9L6M8Hav7x-gzGzoHsz";
  mashiro_option.v_appKey = "e9eG1y4IcG54g4l676M1xeWQ";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/kitholt/cdn/img/warriors.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/best.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/curry.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/chase.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/stadium.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/splashbros.webp,https://cdn.jsdelivr.net/gh/kitholt/cdn/img/coolkt.webp,".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dim">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://kitholt.github.io/">
          <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt3.jpeg">
        </a>
      </div>
      <div class="header-info">
        <p>你来啦!欢迎来到Franの杂货铺！</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/kitholt" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialgithub.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://weibo.com/u/7188904314" target="_blank" class="social-github" title="sina">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialsina.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://music.163.com/#/my/m/music/playlist?id=890672374" target="_blank" class="social-github" title="wangyiyun">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialwangyiyun.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/frank-41-24-53" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialzhihu.png">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialwechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/socialQR.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">Kitholt</span>
            <span class="shironeko">Frank</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags">
                          <i class="fa fa-tags" aria-hidden="true"></i>
                          标签
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    资瓷
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg);" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      汇编语言学习笔记（注：本篇笔记均摘自一位热心的B站用户---_惜取少年时_）</h1>
      <p class="entry-census">
        <span>
          <a href="">
            <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt3.jpeg">
          </a>
        </span>
        <span>
          <a href=""></a>
        </span>
        <span class="bull">
        ·</span>
        2021-3-14<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h2 id="汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）"><a href="#汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）" class="headerlink" title="汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）"></a>汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）</h2><p>[TOC]</p>
<p>注：本篇笔记均摘自一位热心的B站用户—<em>惜取少年时</em></p>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><p>【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】<br>    汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。<br>    1.汇编课程的研究重点<br>        如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作<br>    2.汇编语言的主体是汇编指令<br>    3.汇编指令和机器指令的差别在于指令的表示方法上<br>        汇编指令是机器指令便于记忆的书写格式<br>    4.汇编语言时机器指令的助记符<br>    5.汇编语言的组成<br>        1.汇编指令（机器码的助记符）<br>        2.伪指令（由编译器执行）<br>        3.其他符号（由编译器识别，如：+ - * /）<br>        汇编语言的核心是汇编指令，他决定了汇编语言的特性<br>    6.CPU对存储器的读写<br>        CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互<br>        1.地址信息：存储单元的地址<br>        2.控制信息：芯片的选择，读或写命令<br>3.数据信息：读或写的数据</p>
<h1 id="第二章-寄存器（CPU工作原理）"><a href="#第二章-寄存器（CPU工作原理）" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h1><p>CPU=运算器+控制器+【寄存器】，器件之间通过总线相连<br>    8086CPU有14个寄存器，名称分别为：<br>        AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW<br>    2.1 通用寄存器<br>        1.8086CPU所有的寄存器都是16位的，可以存放2个字节<br>        2.AX、BX、CX、DX通常用来存放一般性数据<br>            被称为通用寄存器<br>        3.8086上一代CPU中的寄存器都是8位的，为了保证兼容性<br>            这四个寄存器都是可以分为2个独立的8位寄存器使用<br>            AX=AH+AL<br>            BX=BH+BL<br>            CX=CH+CL<br>            DX=DH+DL<br>        4.AX的低8位（0-7）构成AL寄存器<br>            高8位（8-15）构成了AH寄存器<br>            AH和AL寄存器是可以独立使用的8位寄存器<br>    2.2 字在寄存器中的存储<br>        8086一个字16位<br><img src="img_ass/2.1.png" alt="avatar"></p>
<p>2.3 几条汇编指令<br>        1.汇编指令不区分大小写<br>        2.几条汇编指令<br>            mov ax,18    ;AX=18<br>            mov ah,78    ;AH=78<br>            add ax,8    ;AX=AX+8<br>            mov ax,bx    ;AX=BX<br>            add ax,bx    ;AX+=BX<br>        3.用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方<br>            mov ax,2    ;ax=2<br>            add ax,ax    ;ax=4<br>            add ax,ax    ;ax=8<br>            add ax,ax    ;ax=16<br>2.4 物理地址<br>        1.CPU访问内存单元时，要给出内存单元的地址。<br>        2.所有的内存单元够成的存储空间是一个一维的线性空间<br>        3.我们将这个唯一的地址称为物理地址<br>2.5 16位结构的CPU<br>        16位结构描述了一个淳朴具有以下几个方面特征：<br>            1.运算器一次最多可以处理16位的数据<br>            2.寄存器的最大宽度为16位<br>            3.寄存器和运算器之间的通路是16位的<br>2.6 8086CPU给出物理地址的方法<br>        1.8086有20位地址总线，可传送20位地址，实际上的寻址能力为1M<br>        2.8086内部为16位结构，它只能传送16位的地址，理论上表现出的寻址能力却只有64K<br>        3.问题：8086CPU如何用内部16位的数据转换成20位的地址？<br>            1.8086CPU采用一种在内部用两个16位地址合成的方法，来形成20位的物理地址<br>                即：段地址+偏移地址=物理地址<br>            2.地址加法器合成物理地址的方法：<br>                物理地址=段地址×16+偏移地址<br>            3.“地址段×16”即是数据左移4位（二进制位的左移4位，十六进制的左移1位）<br>                在地址加法器中，如何完成“段地址×16”？<br>                二进制形式的段地址左移4位<br>2.7 “段地址×16+偏移地址=物理地址”的本质含义<br>        1.即可以用两个16位的二进制数来表示一个20位的二进制数<br>        2.8086CPU中内部为16位结构，但地址线却是20位的，使用地址加法器可以把16位地址变成20位地址<br>            具体操作就是：段地址×16+偏移地址<br>2.8 段的概念<br>        1.内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址×16+偏移地址=物理地址”<br>            的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存<br>        2.以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，<br>            使用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元<br>        3.注意<br>            1.段地址必然是16的倍数，即一个段的起始地址必然是16的倍数<br>            2.偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K<br>            3.CPU可以用不同的段地址和偏移地址形成同一个物理地址<br>2.9 段寄存器<br>        1.段寄存器就是提供段地址的<br>            8086CPU有4个段寄存器：<br>            1.CS（code segment）<br>            2.DS（data segment）<br>            3.SS（stack segment）<br>            4.ES（extra segment）<br>        2.当8086CPU要访问内存时，有这4个段寄存器提供内存单元的段地址<br>2.10 CS和IP<br>        1.CS和IP时候8086CPU中最关键的寄存器<br>            他们指示了CPU当前读取指令的地址。<br>        2.CS和IP的含义<br>            CS：代码段寄存器<br>            IP：指令指针寄存器【专用寄存器】<br>        3.8086CPU工作过程的简要描述<br>            1.从CS:IP指向内存单元，读取指令，读取的指令进入指令缓冲器<br>            2.IP=IP+所读取指令的长度，从而指向下一条指令<br>            3.执行指令，转到步骤1，重复这个过程<br>        4.开机时的CS和IP<br>            1.在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为<br>                CS=FFFFH，IP=0000H<br>            2.即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行<br>            3.FFFF0H单元中的指令是8086PC机开机后执行的第一条指令<br>        5.修改CS、IP的指令<br>            1.在CPU中，程序员能够【用指令读写】的部件只有【寄存器】，<br>                程序员可以通过改变寄存器中的内容实现对CPU的控制<br>            2.CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容<br>                控制CPU执行目标指令<br>            3.如何修改CS和IP？<br>                1.通过mov改变AX等，但是不能通过mov改变CS和IP<br>                2.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP<br>                    指令中的段地址修改CS<br>                    偏移地址修改IP<br>                3.【jmp 某一合法的寄存器】   仅修改IP的内容<br>                    比如：jmp ax 或者 jmp bx（类似于mov IP ax）<br>                4.jmp是只具有一个操作对象的指令<br>2.11 代码段<br>        1.可以将长度为N（N&lt;=64KB）的一组代码，存放在一组地址连续、其实地址为16的倍数的内存单元中<br>            这段内存是用来存放代码的，从而定义了一个代码段<br>        2.CPU中只认被CS:IP指向的内存单元中的内容为指令<br>    【实验一】查看CPU和内存，用机器指令和汇编指令编程<br>        1.R命令：查看、改变CPU寄存器的内容<br>            r后面加寄存器的名称可以改变CPU寄存器的内容<br>        2.D命令：查看内存中的内容<br>        3.E命令：改写内存中的内容<br>        4.U命令：将内存汇总的机器指令翻译成汇编指令<br>        5.T命令：执行一条机器指令<br>        6.A命令：以汇编指令的格式在内存中写入一条机器指令<br>            1.debug中输入的默认是16位数<br>            2.空格数量任意<br>        7.按Q可以退出</p>
<h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><p>3.1 内存中字的存储<br><img src="img_ass/3.1.png" alt="avatar"></p>
<p>1.任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个存储单元<br>            也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元<br>2.注意：在内存的表示中，从高到低，是从0号单元开始，然后逐渐变大，<br>            即在书写时，低位写在高的地方，高位写在低的地方，<br>            如上图所示：4E20H即是0号字节存储20，1号字节存储4E<br>3.2 DS和[address]<br>        1.8086中有一个DS寄存器，通常用来存放要访问的数据的段地址<br>        2.例如：我们要读取10000H单元的内容可以用如下程序段进行：<br>            mov bx,1000H<br>            mov ds,bx<br>            mov al,[0]<br>          上面的三条指令将10000H（1000:0）中的数据读到al中<br>            1.复习：已知mov指令可以完成的两种传送功能<br>                1.将数据直接送入寄存器<br>                2.将一个寄存器中的内容送入另一个寄存器中<br>            2.除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器<br>                mov指令格式：mov 寄存器名,内存单元地址<br>                […]表示一个内存单元，“[…]”中的…表示内存单元的【偏移地址】<br>                执行指令时，8086CPU自动取DS中的数据为内存单元的【段地址】<br>            3.如何把1000H放入DS中？<br>                要通过通用寄存器把段地址传入到DS中<br>                8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器<br>                即：mov ds,1000H  是非法的<br>                数据-&gt;通用寄存器-&gt;段寄存器<br>        3.写几条指令，将AL中的数据送入内存单元10000H？<br>            mov bx,1000H<br>            mov ds,bx<br>            mov [0],al      ;al中的字节型数据送入到1000H:0中<br>3.3 字的传送<br>        1.8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据<br>            即：一次可以传送一个字<br>        2.比如<br>            mov bx,1000H<br>            mov ds,bx<br>            mov ax,[0]      ;1000H:0处的字型数据送入ax中<br>            mov [0],cx      ;cx中的16位数据送入到1000H:0中<br>3.4 mov、add、sub指令<br>        1.复习：已学mov指令的几个形式<br>            1.mov 寄存器,数据         ;立即寻址<br>            2.mov 寄存器,寄存器        ;寄存器寻址<br>            3.mov 寄存器,内存单元      ;直接寻址<br>            4.mov 内存单元,寄存器      ;寄存器寻址？<br>            5.mov 段寄存器,寄存器      ;寄存器寻址<br>            6.mov 寄存器,段寄存器      ;寄存器寻址<br>        2.add、sub同mov一样，都有两个操作对象<br>            1.add的用法<br>                1.add 寄存器,数据      ;立即寻址<br>                2.add 寄存器,寄存器    ;寄存器寻址<br>                3.add 寄存器,内存单元  ;直接寻址<br>                4.add 内存单元,寄存器  ;<br>            2.sub的用法<br>                【不带借位的减法】<br>                指令格式 sub op1,op2    ;意为：op1=op1-op2<br>                1.sub 寄存器,数据      ;立即寻址<br>                2.sub 寄存器,寄存器    ;寄存器寻址<br>                3.sub 寄存器,内存单元  ;直接寻址<br>                4.sub 内存单元,寄存器  ;<br>3.5 数据段<br>        如何访问数据段中的数据？<br>            将一段内存当作数据段，是我们在编程时的一种安排<br>            具体操作：用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元<br>3.6 栈<br>        1.8086CPU提供相关的指令来以栈的方式访问内存空间<br>            这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用<br>        2.8086CPU提供入栈和出栈指令：（最基本的）<br>            push（入栈）<br>            pop（出栈）<br>            1.push ax：将寄存器ax中的数据送入栈中<br>            2.pop ax：从栈顶取出数据送入ax<br>            3.8086CPU的入栈和出栈操作都是以【字（16位）】为单位进行的<br>            4.pop和push可以在寄存器和内存之间传送数据<br>        3.CPU如何知道一段内存空间被当做栈使用？<br>            1.8086CPU中，有两个寄存器<br>                1.段寄存器SS：存放栈顶的段地址<br>                2.寄存器SP：存放栈顶的偏移地址【专用寄存器】<br>            2.任意时刻SS:SP指向栈顶元素，当栈为空的时候，也就不存在栈顶元素<br>                ss:sp也就指向栈最高地址单元的下一个单元<br>        4.执行push和pop的时候，如何知道哪个单元是栈顶单元？<br>            1.执行push ax时<br>                1.sp=sp-2<br>                2.将ax中的内容送入到ss:sp指向的内存单元<br>                    ss:sp此时指向新栈顶<br>            2.执行pop ax时<br>                1.将ss:sp指向的内存单元的内容送入到ax中<br>                    注意：这里取出的内容在内存中还是存在的，并没有被重置<br>                        下一轮push会覆盖<br>                2.sp=sp+2<br>        5.如果栈是空的，sp指向哪里？<br>            sp指向最高地址单元的下一个单元<br>3.7 栈顶超界的问题<br>        ss、sp只记录了栈顶的地址，依靠ss、sp可以保证在入栈和出栈时找到栈顶<br>        可以，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？<br>        1.8086CPU不保证栈的操作不会越界<br>        2.当栈空的时候，再执行pop出栈 或者 当栈满的时候再使用push入栈<br>            都会发生栈顶超界问题，会操作到栈以外的数据，<br>            这些数据可能是其他用途的数据或者代码<br>            栈顶超界是危险的！！！<br>        3.8086CPU没有记录栈顶上下限的寄存器<br>3.8 栈段<br>        1.将一段内存当做栈段，仅仅是我们在编程时的一种安排，<br>        2.ss:sp指向我们定义的栈段的栈顶；<br>        3.当栈空时，sp指向最高地址的下一个单元<br>        4.思考：一个栈段最大可以设为多少？<br>            64KB<br>        5.设栈顶的变化范围是0-FFFFH，从栈空时sp=0（最高地址单元FFFFH的下一个单元0000H）<br>            一直压栈，直到栈满，sp=0；<br>            如果再次压栈，栈顶将环绕，覆盖原来栈中的内容<br>        6.一段内存，既可以是代码的存储空间，又可以是数据的存储空间，还可以是栈空间<br>            也可以是什么都属实。<br>            关键在于CPU中寄存器的设置，即：cs、ip、ss、sp、ds的设置<br>            **可以通过mov直接给sp赋值【立即数寻址】，但是不能通过mov给cs、ip、ss、ds赋值<br>                给cs和ip赋值需要使用jum指令<br>                给ss和ds赋值需要使用mov ss或ds,寄存器   ;【寄存器寻址】<br>    【实验二】</p>
<h1 id="第四章-第一个汇编程序"><a href="#第四章-第一个汇编程序" class="headerlink" title="第四章 第一个汇编程序"></a>第四章 第一个汇编程序</h1><p>4.1 一个源程序从写出到执行的过程<br>        1.一个汇编语言程序从写出到最终执行的简要过程<br>            编写-&gt;编译连接-&gt;执行<br>        2.对源程序进行编译连接<br>            1.使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】<br>            2.再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】。<br>        3.可执行文件包含两部分内容<br>            1.程序（从源程序的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）<br>            2.相关的描述信息（比如：程序有多大、要占多少内存空间等）<br>        4.执行可执行文件中的程序<br>            1.在操作系统（如：MSDOS）中，执行可执行文件中的程序<br>            2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存<br>                并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序<br>    4.2 源程序的主要结构<br>        源程序由 汇编指令+伪指令+宏指令 组成<br>            伪指令：编译器处理<br>            汇编指令：编译为机器码<br>        1.伪指令<br>            1.没有对应的机器码的指令，不能由CPU直接执行<br>            2.伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作<br>        2.segment和ends【定义一个段】<br>            1.segment和ends是一对成对使用的伪指令<br>            2.编写汇编程序【必须】使用到的指令<br>            3.segment和ends的功能是定义一个段<br>                segment：说明一个段开始<br>                ends：说明一个段结束<br>            4.一个段必须有一个名称来标识，使用格式为<br>                段名 segment<br>                段名 ends<br>            5.一个汇编程序由多个段组成<br>                这些段用来存放【代码、数据、或当作栈空间】来使用<br>                一个有意义的汇编程序至少要有一个段，这个段用来存放代码。<br>        3.end【真正的没了】<br>            1.end是一个汇编程序的结束标记<br>            2.编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译<br>            3.如果程序写完了，要在结尾处加上伪指令end<br>                否则，编译器无法知道程序在何处结束<br>            4.【切记】不要把end和ends搞混了<br>                end：汇编程序的结束标记<br>                ends：与segment成对出现<br>        4.assume【寄存器和段的关联假设】<br>            1.它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联<br>            2.通过assume说明这种关联，在需要的情况下，<br>                编译程序可以将段寄存器和某一具体的段相联系<br>        5.程序和源程序<br>            1.我们将源程序文件中的所有内容称为【源程序】<br>            2.将源程序中最终由计算机执行处理的指令或数据称为【程序】<br>            3.程序最先以汇编指令的形式，存储在源程序中<br>                然后经过编译、连接后转变为机器码，存储在可执行文件中<br>        6.标号，标号与段名称有所区别<br>            1.一个标号指代了一个地址，即是段名称。<br>            2.段名称 放在segment的前面，作为一个段的名称<br>                这个段的名称最终将被汇编、连接程序处理为一个段的段地址<br>        7.DOS中的程序运行<br>            1.DOS是一个单任务操作系统<br>            2.一个程序结束后，将CPU的控制权交还给是他得以运行的程序<br>                我们称这个过程为：程序返回<br>        8.程序返回<br>            mov ax，4c00H<br>            int 21H      ;【中断机制】是DOS最伟大的机制,Windows系统上是【消息机制】<br>            这两条指令所实现的功能就是程序返回<br>        9.几个和结束相关的内容<br>            1.段结束：伪指令<br>                通知编译器一个段的结束【ends】<br>            2.程序结束：伪指令<br>                通知编译器程序的结束【end】<br>            3.程序返回：汇编指令<br>                mov ax,4c00H<br>                int 21H<br>        10.语法错误和逻辑错误<br>            1.语法错误<br>                1.程序在编译时被编译器发现的错误<br>                2.容易发现<br>            2.逻辑错误<br>                1.在编写时不会表现出来的错误、在运行时会发生的错误<br>                2.不容易发现<br>    4.3 以简化的方式进行汇编和连接<br>        汇编使用的程序：masm.exe<br>        连接使用的程序：link.exe<br>        简化方式进行汇编和连接的程序：ml.exe<br>    4.4 汇编和连接的作用<br>        连接的作用<br>        1.当源程序很大时，可以将他们分成多个源程序文件夹编译<br>            每个源程序编译成为目标文件后，再用连接程序将它们连接在一起，<br>            生成一个可执行文件<br>        2.程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起<br>            生成一个可执行文件<br>        3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接<br>            用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。<br>          所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用<br>            连接程序对目标文件进行处理，生成可执行文件<br>    4.5 可执行文件中的程序装入内存并运行的原理<br>        1.在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2<br>            将P1从可执行文件中加载入内存，将CPU的控制权交给P1，P1才能得以运行<br>        2.当P1运行完毕后，应该将CPU的控制权交还给使他得以运行的程序<br>        3.操作系统的外壳<br>            1.操作系统是由多个功能模块组成的庞大、复杂的软件系统<br>                任何通用的操作系统，都需要提供一个称为shell（外壳）的程序，<br>                用户（操作人员）使用这个程序来操作计算机系统工作<br>            2.DOS中有一个程序command.com，这个程序在DOS中称为命令解释器<br>                也就是DOS系统的shell<br>        4.执行可执行文件1.exe时，<br>          （1）什么程序将CPU的控制权交给了1.exe？<br>          （2）将程序1.exe加载入内存后，如何使程序得以运行？<br>          （3）1.exe程序运行结束后，返回到了哪里？<br>            1.在DOS中直接执行1.exe时，是正在运行的cmd.exe将1.exe中的程序加载入内存<br>            2.cmd.exe设置CPU的CS:IP指向程序的第一条指令（即，程序的入口）<br>                从而使程序得以运行<br>            3.程序运行结束后，返回cmd.exe中，CPU继续运行cmd.exe<br>    【实验三】</p>
<h1 id="第五章-【bx】和loop指令"><a href="#第五章-【bx】和loop指令" class="headerlink" title="第五章 【bx】和loop指令"></a>第五章 【bx】和loop指令</h1><p>5.1 [bx]<br>        1.和[0]类似，[0]表示内存单元，它的偏移地址是0；<br>        2.[bx]同样也表示一个内存单元，它的段地址在DS中<br>            它的偏移地址在bx中，至于是取字还是取字节，<br>            要看他放入的寄存器是8位还是16位<br>        3.补充：inc指令：相当于C语言中的++运算符<br>5.2 Loop指令<br>        这个指令和循环有关<br>        1.指令格式：loop 标号<br>            CPU执行loop指令的时候，要进行两步操作<br>            1.(cx)=(cx)-1;<br>            2.判断cx中的值，若不为零，则转至标号处执行程序<br>                若为零，则向下执行。<br>        2.通常，loop指令实现循环，cx中存放循环的次数<br>        3.标号<br>            在汇编语言中，标号代表了一个地址，标号标识了一个地址<br>        4.使用cx和loop指令相配合实现循环功能的三个要点<br>            1.在cx中存放循环次数<br>            2.loop指令中的标号所标识地址要在前面<br>            3.要循环执行的程序段，要写在标号和loop指令的中间<br>        5.用cx和loop指令相配合实现循环功能的程序框架<br>            mov cx,循环次数<br>          S:循环执行的程序段<br>            loop s<br>5.3 在Debug中跟踪供loop指令实现的循环程序<br>        **注意：在汇编程序中，数据不能以字母开头，如果要输入像FFFFH这样的数<br>            则要在前面添加一个0<br>        在debug程序中引入G命令和P命令<br>        1.G命令<br>            G命令如果后面不带参数，则一直执行程序，直到程序结束<br>            G命令后面如果带参数，则执行到ip为那个参数地址停止<br>        2.P命令<br>            T命令相当于单步进入（step into）<br>            P命令相当于单步通过（step over）<br>5.4 Debug和汇编编译器Masm对指令的不同处理<br>        1.在debug中，可以直接用指令 mov ax,[0] 将偏移地址为0号单元的内容赋值给ax<br>        2.但通过masm编译器，mov ax,[0] 会被编译成 mov ax,0<br>            1.要写成这样才能实现：mov ax,ds:[0]<br>            2.也可以写成这样：<br>                mov bx,0<br>                mov ax,[bx]  ;或者mov ax,ds:[bx]<br>5.5 loop和[bx]的联合应用<br>        1.计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中<br>            1.注意两个问题<br>                1.12个8位数据加载一起，最后的结果可能会超出8位（越界），故要用16位寄存器存放结果<br>                2.将一个8位的数据加入到16位寄存器中，类型不匹配，8位的数据不能与16位相加<br>            2.【解决办法】<br>                把原来8位的数据，先通过通用寄存器ax，将它们转化成16位的<br>            3.代码如下</p>
<pre><code>assume cs:codesg

codesg segment
start:
    ;指定数据段
    mov ax,0ffffh
    mov ds,ax

    ;初始化
    mov ax,0
    mov dx,0
    mov bx,0

    ;指定循环次数，12次
    mov cx,0ch
circ:
    ;把8位数据存入al中,即ax中存放的是[bx]转化之后的16位数据，前8位都是0
    mov al,[bx]
    ;进行累加
    add dx,ax
    ;bx自增，变化内存的偏移地址
    inc bx
    loop circ

    ;程序返回
    mov ax,4c00h
    int 21H
codesg ends

end start    
</code></pre><p>5.6 段前缀<br>        1.指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中<br>        2.我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器<br>            比如  mov ax,ds:[0]<br>                  mov ax,ds:[bx]<br>            这里的ds就叫做【段前缀】<br>    5.7 一段安全的空间<br>        1.8086模式中，随意向一段内存空间写入内容是很危险的<br>            因为这段空间中可能存放着【重要的系统数据或代码】<br>        2.在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用【0:200~0:2FF】<br>            的256个字节的空间。所以，我们使用这段空间是安全的    </p>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><p>6.1在代码段中使用数据<br>        1.dw的含义【定义字型数据：define word，16字节】<br>            在数据段中使用dw定义数据，则数据在数据段中<br>            在代码段中使用dw定义数据，则数据在代码段中<br>            堆栈段也是一样<br>        2.在程序的第一条指令前加一个标号start，并且这个标号在伪指令end后面出现<br>            可以通知编译器程序在什么地方结束，并且也可以通知编译器程序的入口在哪里<br>6.2在代码段中使用栈<br>        **补充：如果题目要求【逆序】存放，就要想到栈（FILO）<br>        使用dw向系统申请一段空间，然后把这个空间当做栈<br>6.3将数据、代码、栈放入不同的段<br>        1.在前面的6.1和6.2中，我们在程序中用到了数据和栈，我们在编程的时候要注意<br>            何处是数据，何处是栈、何处是代码<br>        2.这样做显然有两个问题<br>            1.把他们放在一个段中是程序显得混乱<br>            2.前面程序中处理的数据很少，用到的栈空间也小，放在一个段里面没有问题<br>                但数据、栈、代码需要的空间超过64KB，就不能放在一个段中<br>                (8086中一个段的容量不能大于64KB)<br>        3.我们可以和定义代码段一样的方法来定义多个段<br>            然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间<br>        4.将数据、代码、栈放入不同的段<br>            1.我们可以在源程序中为这三个段起具有含义的名称<br>                用来存放数据的段，我们将其命名为“data”<br>                用来存放代码的段，我们将其命名为“code”<br>                用来作栈空间的段，我们将其命名为“stack”<br>              但是CPU看得懂吗？【不能】<br>            2.我们在源程序中用伪指令<br>                “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连<br>                这样做了之后，CPU是都就会将cs指向code，ds指向data，ss指向stack<br>                  从而按照我们的意图来处理这些段呢？【不能】<br>                  伪指令CPU看不懂，伪指令是给编译器看的<br>            3.若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令<br>                才是CPU要执行的内容<br>                需在在code段中给DS，CS、SS设置相应的值才能让CPU识别出数据段、代码段、堆栈段<br>                其中汇编程序开始的地方（即代码段开始的地方）由end后面的标号所指向的地方给出<br>        5.assume指令不可省略，至于为什么，需要以后多多体会<br>    【实验五】<br>        1.如果段中的数据占N个字节，则程序加载后，这段实际占有的空间为：N%16==0?N:16×(N/16+1);<br>            因为一个段最小占用16字节，即有16个字节只有这个段可以访问到<br>        2.在编辑源程序的时候，如果调换各个段的编写位置，最后CS、DS、SS的值会发生变化<br>        3.如果去掉start，编译器会从上到下执行，如果第一个段是代码段，则可以正常运行<br>            若第一个段不是代码段，则不会正常运行<br>        4.代码示例1</p>
<pre><code>assume cs:code,ds:data,ss:stack

;数据段
data segment
    ;8个数据
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

;栈段
stack segment
    ;8个数据
    dw 0,0,0,0,0,0,0,0
stack ends

;代码段
code segment
start:
    ;栈空间初始化
    mov ax,stack
    mov ss,ax
    mov sp,16

    ;数据段初始化
    mov ax,data
    mov ds,ax

    push ds:[0];一个栈单元是一个字
    push ds:[2]
    ;存放数据不会改变
    pop ds:[2]
    pop ds:[0]

    ;程序返回
    mov ax,4c00h
    int 21h
code ends
end 
</code></pre><pre><code>    5.将a，b数据段中的内容分别相加，结果放入data数据段中
</code></pre><pre><code>assume cs:code

;数据段
a segment
    db 1,2,3,4,5,6,7,8
a ends

;数据段
b segment
    db 1,2,3,4,5,6,7,8
b ends

;数据段
data segment
    db 0,0,0,0,0,0,0,0
data ends

;代码段
code segment
start:
    mov bx,0
    mov ax,0

    mov dx,a
    mov ss,dx

    mov dx,b
    mov es,dx

    mov dx,data
    mov ds,dx

    mov cx,8
circ:
    add al,ss:[bx]
    add al,es:[bx]
    mov [bx],al
    inc bx
    mov al,0
    loop circ

    ;程序返回
    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><pre><code>    6.将a数据段中的前8个字型数据逆序存储到b段中
</code></pre><pre><code>assume cs:code
a segment
    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends

b segment
    dw 0,0,0,0,0,0,0,0
b ends

code segment
start:
    mov ax,0
    mov ax,a
    mov ss,ax
    mov sp,0

    mov ax,0
    mov ax,b
    mov ds,ax

    mov bx,0

    mov cx,8
circ:
    pop [bx]
    add bx,2
    loop circ

    mov ax,4c00h
    int 21h
code ends
end start 
</code></pre><h1 id="第七章-更灵活地定位内存地址"><a href="#第七章-更灵活地定位内存地址" class="headerlink" title="第七章 更灵活地定位内存地址"></a>第七章 更灵活地定位内存地址</h1><pre><code>本章主要讲解一些更灵活的定位内存地址的方法和相关的编程方法
</code></pre><p>7.1 and和or指令<br>        1.and指令：逻辑与指令，按位进行与运算<br>            1.如:mov al,01100011B<br>                 and al,00111011B<br>              执行后：<br>                 al=00100011B<br>            2.通过and指令可将操作对象的相应位设为0，其他位保持不变<br>                例如al的第6位设为0：and al,10111111B<br>                例如al的第7位设为0：and al,01111111B<br>                例如al的第0位设为0：and al,11111110B<br>        2.or指令，逻辑或运算，按位进行或运算<br>            1.如:mov al,01100011B<br>                 or  al,00111011B<br>              执行后：<br>                al=01111011B<br>            2.通过该指令可将操作对象的相应位设为1，其他位不变<br>                or al,01000000B;将al的第6位设为1<br>                or al,10000000B;将al的第7位设为1<br>                or al,00000001B;将al的第0位设为1<br>7.2 关于ASCII码<br>        一种编码方案，在计算机系统中通常被采用，8位<br><img src="img_ass/ASCII.png" alt="avatar"></p>
<p>7.3 以字符形式给出的数据<br>        1.在汇编程序中，可以使用’×××’的方式指明数据是以字符的形式给出的<br>        2.编译器会将它们转化为相应的ASCII码<br>        3.例如<br>            1.db ‘unIX’   ;相当于：db 75H,6EH,49H,58H<br>                ‘u’、’n’、’I’、’X’的ASCII码分别为75H,6EH,49H,58H<br>            2.mov al,’a’  ;相当于：mov al，61H<br>                ‘a’的ASCII码为61H<br>        4.ASCII码中，大写字母和小写字母之间的规律<br>            小写字母=大写字母+32<br>            小写字母=大写字母+20H<br>            大写字母从41H开始排，小写字母从61H开始排<br>大写|二进制|小写|二进制<br>-|-|-|-<br>A|01000001|a|01100001<br>B|01000010|b|01100010<br>C|01000011|c|01100011<br>D|01000100|d|01100100</p>
<p>7.4 大小写转换的问题<br>        1.方案一：<br>            1.识别出是该字节是表示一个的大写英文字符，还是小写的<br>                用于条件判断的汇编程序，目前还没有学到<br>            2.根据+20H 或者 -20H进行大小写转换<br>        2.方案二：<br>            1.若全部转化为大写，则将第5位置0<br>                and al,11011111B<br>            2.若全部转化为小写，则将第5位置1<br>                or  al,00100000B<br>7.5 [bx+常数]<br>        mov ax,[bx+200]的含义：<br>        1.将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个入一个子单元<br>          该字单元的偏移地址为bx中的数值加上200，段地址在ds中<br>        2.也可以写成<br>            1.mov ax,200[bx]<br>            2.mov ax,[bx].200<br>7.6 用[bx+idata]的方式进行数组的处理<br>        在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写<br>          1.我们观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5<br>          2.我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放<br>          3.我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符<br>          4.注意这个数组的定位方式，对比C语言<br>            C语言的数组定位方式：a[i]，b[i]，  a、b是地址常量<br>            汇编语言的数组定位方式：0[bx],5[bx]<br>            所以：[bx+常数]的方式为高级语言实现数组提供了便利的机制</p>
<pre><code>assume cs:codesg,ds:datasg

datasg segment
    db &#39;BaSiC&#39;
    db &#39;MinIX&#39;
datasg ends

codesg segment
start:
    mov ax,datasg
    mov ds,ax
    mov bx,0

    mov cx,5    ;做5次循环
circ:
    mov al,[bx]
    and al,11011111b
    mov [bx],al
    mov al,[bx+5];等价于mov al,5[bx];等价于mov al,[bx].5
    or al,00100000b
    mov 5[bx],al
    inc bx
    loop circ

    mov ax,4c00h
    int 21h
codesg ends
end start
</code></pre><pre><code>7.7 SI和DI
    已经学过的10个寄存器：AX、BX、CX、DX、DS、CS、SS、ES、IP、SP
    1.SI和DI是8086CPU中和bx功能相近的寄存器
        bx不够用，所以引进了SI和DI
    2.SI和DI（16位）不能够分成两个8位寄存器来使用【和bx的区别】
    3.下面三组指令实现了相同的功能
        1.mov bx,0
          mov ax,[bx]
        2.mov si,0
          mov ax,[si]
        3.mov di,0
          mov ax,[di]
    4.下面三组指令也实现了相同的功能
        1.mov bx,0
          mov ax,[bx+123]
        2.mov si,0
          mov ax,[si+123]
        3.mov di,0
          mov ax,[di+123]
    5.用寄存器SI和DI实现将字符串&#39;welcome to masm!&#39;复制到它后面的数据区中
        通常用ds:si指向要复制的源始字符串
        通常用ds:di指向要复制的目的空间
        **注意si、di是16位寄存器，循环中自增时，应该+2
</code></pre><pre><code>assume cs:code,ds:data
data segment
    db &#39;welcome to masm!&#39;
    db &#39;................&#39;
data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov si,0
    mov di,16

    mov cx,8
circ:
    mov ax,0[si]
    mov [di],ax
    inc di
    inc di
    inc si
    inc si
    loop circ

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><p>7.8 [bx+si]和[bx+di]<br>        1.[bx+si]和[bx+di]的含义类似，我们以[bx+si]为例进行讲解<br>            [bx+si]表示一个内存单元，它的偏移地址为bx中的数值加上si中的数值<br>              它的偏移地址在ds中<br>        2.[bx+si]也可以写成[bx][si]<br>7.9 [bx+si+常数]和[bx+di+常数]<br>        1.以[bx+Si+常数]为例讲解<br>            [bx+si+常量]表示一个内存单元，偏移地址为bx的值+si的值+常数<br>        2.指令mov ax,[bx+si+常数]也可以写成如下形式<br>            1.mov ax,200[bx+si]<br>            2.mov ax,200[bx][si]<br>            3.mov ax,[bx].200[si]<br>7.10 不同的寻址方式的灵活应用<br>        1.总结几种定位内存的方法<br>            1.ds:[常数]   【直接寻址】<br>                用一个常量来表示地址，可用于直接定位一个内存单元<br>            2.[bx]      【寄存器间接寻址】<br>                用一个寄存器的值来表示内存地址，可以间接定位一个内存单元<br>            3.[bx+常数]   【？？】<br>                用一节寄存器的值和常量表示内存地址，可在一个起始地址的基础上用变量间接定位一个内存单元<br>            4.[bx+si]<br>            5.[bx+si+常数]<br>        2.编程，给定数据段data，将data段中每个单词的头一个字母改写成大写字母</p>
<pre><code>assume cs:code,ds:data
data segment
    db &#39;1. file         &#39;
    db &#39;2. edit         &#39;
    db &#39;3. search       &#39;
    db &#39;4. view         &#39;
    db &#39;5. options      &#39;
    db &#39;6. help         &#39;
data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov bx,0

    mov cx,6
circ:
    mov al,[bx+3]
    and al,11011111b
    mov [bx+3],al
    add bx,16
    loop circ

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><pre><code>    3.编程，给定数据段data，将data段中的每个单词改为大写字母
      1.【loop指令cx-1之后，在判断是否为0】
      2.双重循环用汇编怎么实现？
        应该在每次开始内循环的时候，将外层循环的cx的值保存起来，
        在执行外层循环的loop指令前，在恢复外层循环的cx数值。
        **可以用寄存器来临时保存，也可以用栈空间（内存）保存【没有多余的寄存器】
            更好的方法是使用：栈
          1.使用寄存器实现
</code></pre><pre><code>assume cs:code,ds:data
data segment
    db 4,4,6,4,7,4;单词的字母数
    db &#39;          &#39;;补齐
    db &#39;1. file         &#39;
    db &#39;2. edit         &#39;
    db &#39;3. search       &#39;
    db &#39;4. view         &#39;
    db &#39;5. options      &#39;
    db &#39;6. help         &#39;
data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov bx,16
    mov si,0
    mov di,0

    mov cx,6;外层循环6次
outer:;外层循环
    mov dx,cx;用寄存器将外层循环的次数保存，C语言中是用栈来保存的

    mov cx,0
    mov cl,[di];内循环的次数    
    inner:;内层循环
        mov al,[bx][si+3]
        and al,11011111b
        mov [bx][si+3],al
        inc si
        loop inner

    add bx,16
    mov si,0
    inc di
    mov cx,dx;恢复外层循环的次数
    loop outer

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><pre><code>          2.使用栈实现【更好的方法】
</code></pre><pre><code>assume cs:code,ds:data,ss:stack
data segment
    db 4,4,6,4,7,4;单词的字母数
    db &#39;          &#39;;补齐
    db &#39;1. file         &#39;
    db &#39;2. edit         &#39;
    db &#39;3. search       &#39;
    db &#39;4. view         &#39;
    db &#39;5. options      &#39;
    db &#39;6. help         &#39;
data ends

stack segment
    dw 1,2,3,4,5,6,7,8
stack ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov ax,stack
    mov ss,ax
    mov sp,16
    mov bx,16
    mov si,0

    mov cx,6;外层循环6次
outer:;外层循环
    push cx;将外层循环的次数保存

    mov cx,0
    mov cl,[di];内循环的次数    
    inner:;内层循环
        mov al,[bx][si+3]
        and al,11011111b
        mov [bx][si+3],al
        inc si
        loop inner

    add bx,16
    mov si,0
    inc di
    pop cx;恢复外层循环的次数
    loop outer

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><pre><code>本章对前面的所有内容是具有总结性的
计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：
    1.处理的数据在什么地方？
    2.要处理的数据有多长？
  这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作
</code></pre><p>8.1 bx、si、di、bp<br>        1.在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]”<br>            中，用来进行内存单元的寻址<br>        2.在“[…]”中，这四个寄存器（bx、bp、si、di）可以单个出现，<br>            或者只能以以下4种组合出现<br>            1.bx和si<br>            2.bx和di<br>            3.bp和si<br>            4.bp和di<br>        3.错误的用法<br>            mov ax,[bx+bp]<br>            mov ax,[si+di]<br>        4.只要在[…]中使用寄存器bp，则指令中没有显性给出段地址，那么<br>            段地址就默认在ss中，比如：<br>            mov ax,[bp]       ax的值为栈空间中，偏移地址为bp的内存单元<br>            mov ax,[bp+常数]<br>            mov ax,[bp+si]<br>            mov ax,[bp+si+常数]<br>8.2 机器指令处理的数据所在的位置<br>        1.绝大部分机器指令进行数据处理的指令大致可分为3大类<br>            读取、写入、运算<br>        2.在机器指令这一层，并不关心数据的值是多少，而关心指令执行前一刻<br>            它将要处理的数据所在的位置<br>        3.指令在执行前，所要处理的数据可以在三个地方<br>            CPU内部（寄存器）、内存、端口<br>8.3 汇编语言中数据位置的表达<br>        汇编语言中用三个概念来表达数据的位置<br>          1.立即数<br>          2.寄存器<br>          3.段地址（SA）和偏移地址（EA）<br>            1.存放段地址的寄存器可以是默认的，<br>                既可以是默认在ds中，也可以是在ss中（使用bp寄存器）<br>            2.存放段地址的寄存器也可以显性的给出<br>                mov ax,ds:[bp]<br>                mov ax,es:[bx]<br>                mov ax,ss:[bx+si]<br>                mov ax,cs:[bx+si+8]<br>8.4 寻址方式<br><img src="img_ass/8.1.png" alt="avatar"></p>
<p>8.5 指令要处理的数据有多长？<br>        1.8086CPU的指令，可以处理两种尺寸的数据，byte和word<br>            所以在机器指令中要指明，指令进行的是字操作还是字节操作<br>        2.8086CPU确定数据长度的几种方法<br>            1.通过寄存器名指明要处理的数据的尺寸<br>                mov al,1        ;指明数据是字节型的<br>                mov bx,ds:[0]   ;指明数据是字型的<br>            2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度<br>                X在汇编指令中可以为word或byte<br>                1.下面的指令中，用byte ptr指明了指令访问的内存单元是字节型单元<br>                  mov byte ptr ds:[0],1<br>                  inc byte ptr [bx]<br>                  inc byte ptr ds:[0]<br>                  add byte ptr [bx],2<br>                2.下面的指令中，用word ptr指明了指令访问的内存单元是字型单元<br>                  mov word ptr ds:[0],1<br>                  inc word ptr [bx]<br>                  inc word ptr ds:[0]<br>                  add word ptr [bx],2<br>            3.其他方法<br>                有些指令默认了访问的内存单元类型<br>                pop、push指令，一定是字型数据<br>        3.在没有寄存器参与的内存单元访问指令中，用word ptr或者byte ptr<br>            显性地指明所要访问的内存单元的长度，是非常有必须要的<br>            否则，CPU无法得知所要访问的单元是字单元，还是字节单元<br>8.6 寻址方式的综合应用<br>8.7 div指令<br>        1.div是除法指令（division），使用div作除法的时候，要求<br>            1.除数：8位或16位，在寄存器或内存单元中<br>            2.被除数：（默认）放在AX或DX和AX中<br>            3.除数与被除数的相互关系<br>                除数  被除数<br>                8位   16位（AX）<br>                16位  32位（DX+AX）<br>            4.结果存放的位置<br>                运算  8位  16位<br>                商    AL   AX<br>                余数  AH   DX<br>        2.div指令格式<br>            1.div 寄存器<br>            2.div 内存单元<br>            除数是寄存器或内存单元的内容<br>        3.div指令示例<br>            1.div byte ptr ds:[0]   ;被除数是16位，除数是ds:[0]的内容(8位)<br>              含义：(al)=(ax)/((ds)<em>16+0)的商<br>                   (ah)=(ax)/((ds)</em>16+0)的余数<br>           2.div word ptr es:[0]    ;被除数是32位，除数是es:[0]的内容(16位)<br>              含义：(ax)=[(dx)<em>10000H+(ax)]/((es)</em>16+0)的商<br>                   (dx)=[(dx)<em>10000H+(ax)]/((es)</em>16+0)的余数<br>        4.利用除法指令计算100001/100<br>            1.被除数100001大于65535，要使用dx和ax两个寄存器联合存放<br>              即说要进行的16位的除法<br>            2.除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位<br>              除数应为16位，所以要用16位寄存器来存放除法100<br>            3.现将100001表示成十六进制数：186A1H，即dx中存放1H，ax中存放86A1H</p>
<pre><code>mov dx,1
mov ax,86A1H
mov bx,100
div bx  ;默认除数是16位的
</code></pre><p>8.8 伪指令dd<br>        1.dd是用来定义双字型数据的<br>        2.示例<br>            data segment<br>                db 1    ;字节型数据<br>                dw 1    ;字型数据<br>                dd 1    ;双字型数据<br>            data ends<br>        3.已知data段数据，用div计算data中第一个数据除以第二个数据后的结果，<br>            商存放在第3个数据的内存单元中</p>
<pre><code>assume cs:code,ds:data
data segment
    dd 100001
    dw 100
    dw 0
data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov bx,0
    mov ax,[bx]     ;低位存放在ax中
    mov dx,[bx+2]   ;高位存放在dx中
    div word ptr [bx+4]
    mov [bx+6],ax   ;商存放在ax中，把ax中的内容放入内存中

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><p>8.9 dup<br>        1.dup是一个操作符，在汇编语言中，同db、dw、dd等一样，也是有编译器识别处理的符号<br>        2.dup和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复<br>        3.dup示例<br>            1.db 3 dup(0)   ;定义了3个字节，他们的值都是0<br>            2.db 3 dup(0,1,2)   ;定义了9个字节，他们是0、1、2、0、1、2、0、1、2<br>            3.db 3 dup(‘abc’,’ABC’) ;定义了18个字节，相当于db’abcABCabcABCabcABC’<br>        4.dup的使用格式<br>            db 重复的次数 dup(重复的字节型数据)<br>            dw 重复的次数 dup(重复的字型数据)<br>            dd 重复的次数 dup(重复的双字型数据)<br>    【实验七】<br>    没调试成功</p>
<pre><code>assume cs:code,ds:data,ss:stack,es:table

stack segment
    ;空栈时，sp指向16
    dw 8 dup(0)
stack ends

data segment
    ;表示21年的21个字符串
    ;起始地址0，终止地址21*4-1：83
    db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;
    db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;
    db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;

    ;表示21年公司总收入的21个双字型数据
    ;起始地址21*4：84，终止地址21*4+21*4-1：167
    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000

    ;表示21年公司雇员人数的21个字型数据
    ;起止地址21*8：168，终止地址21*8+21*2-1：209
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800
data ends

table segment
    db 21 dup(&#39;year summ ne ?? &#39;)
table ends



code segment
start:
    mov ax,data
    mov ds,ax

    mov ax,table
    mov es,ax

    mov ax,stack
    mov ss,ax
    mov sp,16

    mov si,0
    mov di,0
    mov bx,0
    mov bp,0 

    mov cx,21
outer:

    push si
    add si,si
    mov ax,ds:[bp]
    mov es:[bx][di],ax
    mov ax,ds:84[bp]
    mov es:[bx][di+5],ax
    pop si
    mov al,168[si]
    mov es:[bx][di+10],al
    inc si
    add di,2
    push si
    add si,si
    mov ax,ds:[bp]
    mov es:[bx][di],ax
    mov ax,ds:84[bp]
    mov es:[bx][di+5],ax
    pop si
    mov al,168[si]
    mov es:[bx][di+10],al
    inc si
    add di,2

    add bx,16
    loop outer

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><pre><code>8086CPU的转移指令分为以下几类：
    1.无条件跳转指令（如：jmp）
    2.条件跳转指令
    3.循环指令（如：loop）
    4.过程，就像C语言中的函数
    5.中断
</code></pre><p>9.1 操作符offset<br>        操作符offset在汇编语言中由编译器处理，它的功能是取标号的偏移地址<br>        如：s:mov ax,offset s<br>9.2 jmp指令<br>        1.无条件转移，可以只修改ip，也可以同时修改cs和ip<br>            1.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP<br>                指令中的段地址修改CS<br>                偏移地址修改IP<br>                这种用法编译器不认识，只能做在debug中使用<br>            2.【jmp 某一合法的寄存器】   仅修改IP的内容<br>                比如：jmp ax 或者 jmp bx（类似于mov IP ax）<br>        2.jmp指令要给出两种信息：<br>            1.转移的目的地址<br>            2.转移的距离（段间转移、段内短转移、段内近转移）<br>9.3 依据位移进行转移的jmp指令<br>        1.jmp short 标号【转到标号处执行指令,段内短转移】<br>          此格式实现的是：段内短转移，它对ip的修改范围为-128~127<br>        2.也就是说，它向前转移时可以最多越过128个字节，负数使用补码表示<br>          向后转移可以最多越过127个字节<br>        3.CPU不需要目的地址就可以实现对ip的修改<br>            jmp指令的机器码中不包含目的地址，但是可以实现跳转<br>            实现的方式，是在原地址的基础上进行一个偏移量，即位移<br>        4.还有一种和指令“jmp short 标号”功能类似的指令格式：<br>            jmp near ptr 标号，它实现的是段内近转移<br>            功能为：(ip)=(ip)+16位位移<br>            jmp short 标号是8位的位移，而jmp near ptr 标号是16位位移<br>9.4 转移的目的地址在指令中的jmp指令<br>        前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前ip的转移位移<br>        1.指令“jmp far ptr 标号”<br>            实现的是段间转移，又称为远转移,这时机器码中应该明确给出【段地址】<br>        2.指令“jmp far ptr 标号”功能如下：<br>            (CS)=标号所在段的段地址<br>            (IP)=标号所在段中的偏移地址<br>            far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip<br>9.5 转移地址在寄存器中的jmp指令<br>        指令格式：jmp 16位寄存器<br>        功能：修改ip寄存器中的值，把16位寄存器中的值送入到ip寄存器中<br>9.6 转移地址在内存中的jmp指令<br>        转移地址在内存中的jmp指令有两种格式：<br>        1.jmp word ptr 内存单元地址（段内转移）<br>            功能：将内存中的那个字视为一个偏移地址，然后跳转到那个偏移地址<br>            与【jmp 寄存器】功能相似<br>            内存单元地址可用寻址方式的任意格式给出<br>        2.jmp dword ptr 内存单元地址（段间转移）<br>            (ip)=(内存单元地址)   ;双字中的低位字是给ip的<br>            (cs)=(内存单元地址+2) ;双字中的高位字是给cs的<br>            跟【jmp 段地址:偏移地址】功能类似<br>            内存单元地址可用寻址方式的任意格式给出<br>            <strong>补充：不能直接向内存单元中加入立即数<br>                要通过寄存器，把立即数加进去<br>9.7 jcxz指令<br>        1.有条件跳转指令，所有的有条件跳转指令都是短转移<br>            对应的机器码中包含转移的位移，而不是目的地址。对ip的修改范围都为：-128~127
            </strong>另一个有条件跳转指令【loop指令】<br>        2.指令格式：jcxz 标号<br>            如果（cx）=0，则跳转到标号处执行<br>        3.jcxz 标号 指令的操作：<br>            1.当(cx)=0时，(ip)=(ip)+8位位移<br>            2.当(cx)!=0时，什么也不做（程序继续向下执行）<br>9.8 loop指令<br>        1.循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移<br>        2.指令格式：loop 标号<br>        3.指令的内部操作<br>            1.cx=cx-1<br>            2.如果cx!=0，(ip)=(ip)+8位位移，跳转<br>            3.(cx)=0，什么也不做，程序向下执行<br>            cx用来控制循环的次数<br>9.9 根据位移进行转移的意义<br>        1.根据位移进行转移，这样设计，方便了程序段在内存中的浮动装配<br>            可以实现代码的复用<br>        2.如果在机器码中直接给出【段地址:偏移地址】，<br>            这段程序在内存中换一个位置，则会运行不正确<br>        3.段内近转移、段内短转移都是根据位移进行转移，一共有四种方式<br>            1.jmp short ptr 标号<br>            2.jmp near ptr 标号<br>            3.jcxz 标号<br>            4.loop 标号<br>9.10 编译器对转移位移超界的检测<br>        注意，根据位移进行转移的指令，他们的转移范围会受到限制<br>        如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错<br>    【实验八、九】【这个实验要重点看】</p>
<h1 id="第十章-call和ret指令"><a href="#第十章-call和ret指令" class="headerlink" title="第十章 call和ret指令"></a>第十章 call和ret指令</h1><pre><code>call和ret指令都是转移指令，它们都能修改ip，或同时修改cs和ip
</code></pre><p>10.1 ret和ref<br>        1.ret指令用栈中的数据，修改ip的内容，从而实现【近转移】<br>            CPU执行ret指令时，进行下面两步操作：<br>            1.(ip)=((ss)<em>16+(sp))   ;ip的值修改为栈顶的内容<br>            2.(sp)=(sp)+2           ;栈顶移动<br>        2.retf指令用栈中的数据，修改cs和ip的内容，从而实现【远转移】<br>            CPU执行retf指令时，进行下面四步操作<br>            1.(ip)=((ss)</em>16+(sp))   ;ip的内容修改为栈顶的内容<br>            2.(sp)=(sp)+2           ;栈顶移动<br>            3.(cs)=((ss)<em>16+(sp))   ;cs的内容修改为栈顶移动之后，栈顶的内容<br>            4.(sp)=(sp)+2           ;栈顶移动<br>            栈顶的两个字，低位字修改为ip，高位字修改为cs<br>        3.可以看出，如果我们用汇编语法来解释ret和retf指令，则<br>            1.CPU执行ret指令，相当于<br>                pop ip<br>            2.执行retf指令时，相当于<br>                pop ip<br>                pop cs<br>10.2 call指令<br>        1.call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：<br>            1.将当前的ip或cs和ip压入栈中<br>            2.转移<br>        2.call指令不能实现短转移，除此之外，<br>            call指令实现转移的方法和jmp指令的原理相同<br>        【依据位移进行转移的call指令】<br>        3.CPU执行“call 标号”这种格式的call指令时，进行如下操作：<br>            1.(sp)=(sp)-2         ;栈顶移动<br>            2.((ss)</em>16+(sp))=(ip) ;当前ip内容压栈<br>            3.(ip)=(ip)+16位位移   ;跳转到标号处<br>        4.call指令格式：call 标号<br>            相当于执行：<br>            push ip<br>            jmp near ptr 标号<br>10.4 转移的目的地址在指令中的call指令<br>        1.指令格式：call far ptr 标号<br>            实现的是段间转移<br>        2.执行这种格式的call指令时CPU的操作<br>            1.(sp)=(sp)-2           ;栈顶移动<br>            2.((ss)×16+(sp))=(cs)   ;先把cs压栈<br>            3.(sp)=(sp)-2           ;栈顶移动<br>            4.((ss)×16+(sp))=(ip)   ;然后把ss压栈<br>        3.CPU执行“call far ptr 标号”时，相当于进行<br>            push cs<br>            push ip<br>            jmp far ptr 标号<br>10.5 转移地址在寄存器中的call指令<br>        1.指令格式：call 16位寄存器<br>        2.执行这种指令时，在CPU中的操作<br>            1.(sp)=(sp)-2<br>            2.((ss)×16+(sp))=(ip)<br>            3.(ip)=(16位寄存器)<br>        3.相当于<br>            push ip<br>            jmp 16位寄存器<br>10.6 转移地址在内存中的call指令<br>        转移地址在内存中的call指令有两种格式：<br>        1.call word ptr 内存单元地址<br>            汇编语法解释<br>              push ip<br>              jmp word ptr 内存单元地址<br>        2.call dword ptr 内存单元地址<br>            汇编语法解释<br>              push cs   ;cs存放在高位<br>              push ip   ;ip存放在低位<br>              jmp dword ptr 内存单元地址<br>10.7 call和ret的配合使用<br>10.8 mul指令<br>        相乘的两个数；要么都是8位，要么都是16位<br>        1.8位：AL中和8位寄存器或内存字节单元中<br>            AL中的内容作为被乘数<br>            结果放在AX中<br>        2.16位：AX中和16位寄存器或内存字单元中<br>            AX中的内容作为被乘数<br>            结果放在DX（高位）和AX（低位）中。<br>        3.格式如下：<br>            mul 寄存器<br>            mul 内存单元（byte ptr或 word ptr指明是字还是字节）<br>10.9 模块化程序设计<br>10.10 参数和结果传递的问题<br>        【编程】计算data段中第一组数据的3次方，结果保存在后面一组dword单元中</p>
<pre><code>data sgement
    dw 1,2,3,4,5,6,7,8
    dd 0,0,0,0,0,0,0,0 
data ends
</code></pre><p>10.11 批量数据的传递<br>        使用寄存器、内存、栈传递数据<br>        【编程】将一个全是字母，以0结尾的字符串，转化为大写<br>    【实验十 编写子程序】<br>        1.显示字符串<br>        2.解决除法溢出问题<br>        3.数值显示<br>    【课程设计1】</p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><pre><code>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）
本章中的标志寄存器（以下简称为flag）是我们要学习的最有一个寄存器
flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息
8086CPU的flag寄存器的结构：
    1.flag的1、3、4、12、13、14、15位共7位在8086CPU中没有使用，不具有任何含义
        而0、2、4、6、7、8、9、10、11位共9位都具有特殊的含义
    2.示意图
</code></pre><p><img src="img_ass/11.1.png" alt="avatar"></p>
<p>11.1 ZF标志<br>        1.flag的第6位是ZF，零标志位。<br>            它记录相关指令执行后，<br>              1.结果为0，ZF=1<br>              2.结果不为0，ZF=0<br>        2.示例：<br>            mov ax,1<br>            sub ax,1<br>            指令执行后，结果为0，则ZF=1<br>            mov ax，2<br>            sub ax，1<br>            指令执行后，结果不为0，则ZF=0<br>        3.注意，在8086CPU的指令集中，有的指令的执行会影响标志寄存器<br>            比如：add、sub、mul、div、inc、or、and等<br>            他们大都是运算指令（逻辑运算或者算术运算）<br>          有的指令的执行对标志寄存器没有影响，<br>            比如：mov、push、pop等，他们大都是传送指令<br>11.2 PF标志<br>        flag的第2位是PF，奇偶标志位<br>        它记录指令执行后，结果的所有二进制位中1的个数<br>          1.为偶数，PF=1<br>          2.为奇数，PF=0<br>11.3 SF标志<br>        1.flag的第7位是SF，符号标志位<br>        2.它记录指令执行后<br>          1.结果为负。sf=1<br>          2.结果为正，sf=0<br>          sf标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负<br>            sf标志把所有数当作有符号数<br>            如果把数据当作无符号数运算，sf的值则没有意义，虽然相关指令会影响它的值<br>        3.也就是说，CPU在执行add等指令时，是必然要影响sf标志位的值<br>            至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算<br>11.4 CF标志<br>        1.flag的第0位是CF，进位标志位<br>          一般请况下，在进行无符号数运算的时候，<br>            它记录了运算结果的最高有效位向更高位的进位值，<br>              或从更高位的借位值<br>            代表假想的更高位<br>        2.CPU在运算时，不会丢弃进位值，而是记录在一个特殊的寄存器的某一位上<br>            8086CPU就用flag的cf为来记录这个进位值，借位也一样<br>        3.在debug中的显示<br><img src="img_ass/11.2.png" alt="avatar"></p>
<pre><code>    4.无符号的时候产生的结果
</code></pre><p>11.5 OF标志<br>        flag中的第11位<br>        进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出<br>        1.这里所讲的溢出，只是对有符号数运算而言<br>          就像进位只是相对于无符号数而言！<br>        2.一定要注意cf和of的区别<br>            当需要把机器码看成有符号数则使用of<br>            当需要把机器码看成无符号数则使用cf<br>11.6 adc标志<br>        adc是带进位的加法指令，他利用了cf上记录的进位值<br>        1.格式：adc 操作对象1，操作对象2<br>        2.功能：操作对象1=操作对象1+操作对象2+cf<br>          比如：adc ax,bx实现的功能是：<br>            (ax)=(ax)+(bx)+cf<br>        3.执行adc指令的时候，加上的cf的值的含义，由adc指令前的指令决定<br>            也就是说，关键在于所加上的cf值是被什么指令设置的<br>        4.如果cf是被sub指令设置的，那么他的含义就是借位值<br>          如果是被add指令设置的，那么它的含义就是进位值<br>        5.下面的指令和add ax,bx具有相同的结果<br>            add al,bl<br>            adc ah,bh<br>            CPU提供adc指令的目的，就是来进行加法的第二步运算的<br>            adc指令和add指令相配合就可以对更大的数据进行加法运算<br>        【实验：编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中】<br>11.7 sbb标志<br>        sbb是带借位减法指令，他利用了cf位上记录的借位值<br>        1.格式：sbb 操作对象1，操作对象2<br>        2.功能：操作对象1=操作对象1-操作对象2-cf<br>        3.利用sbb指令，我们可以对任意大的数据进行减法运算<br>        4.sbb和adc是基于相同的思想设计的两条指令，<br>            在应用思路上和adc类似<br>11.8 cmp标志<br>        1.cmp是比较指令，功能相当于减法指令，只是不保存结果<br>        2.cmp指令执行后，将对标志寄存器产生影响<br>        3.其他相关指令通过识别这些被影响的标志寄存器，来得知比较结果<br>        4.cmp指令格式：cmp 操作对象1,操作对象2<br>        5.功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置<br>        6.比如：cmp ax,ax<br>            做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关位<br>            指令执行后<br>            zf=1    ;结果为0<br>            pf=1    ;结果的1的个数为偶数<br>            sf=0    ;结果为正号<br>            cf=0    ;结果没有产生进位或借位<br>            of=0    ;结果没有溢出<br>        7.根据flag，判断cmp指令的结果（无符号数）<br><img src="img_ass/11.3.png" alt="avatar"></p>
<pre><code>    8.cmp既可以对无符号数进行比较，也可以对有符号数进行比较
        cmp 操作数1,操作数2   ;操作数1、操作数2都是有符号数
        1.of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负
            of=0，sf=1   则 操作数1比操作数2小
            of=0，sf=0   则 操作数1比操作数2大
        2.of=1，说明有溢出，逻辑上真正结果的正负与实际结果的正负相反
            of=1，sf=1   则 操作数1比操作数2大
            of=1，sf=0   则 操作数1比操作数2小
</code></pre><p>11.9 检测比较结果的条件转移指令<br>        1.这些条件转移指令通常和cmp相配合使用<br>        2.因为cmp指令可以同时进行两种比较，无符号数和有符号数的比较<br>          所以，这些转移指令也分为两种，即：<br>            1.根据【无符号数】的比较结果进行转移的条件转移指令，<br>              他们检测zf、cf的值<br>            2.根据【有符号数】的比较结果进行转移的条件转移指令<br>              他们检测sf、of和zf的值<br>        3.无符号比较，条件转移指令小结【无符号，6个】<br>          1.je  等于则转移     zf=1<br>          2.jne 不等于则转移   zf=0<br>          3.jb  低于则转移     cf=1      【b表示below】<br>          4.jnb 不低于则转移   cf=0<br>          5.ja  高于则转移     cf=0，zf=0【a表示above】<br>          6.jna 不高于则转移   cf=1或zf=1<br>11.10 DF标志和串传送指令<br>        1.flag的第10位DF，方向标志位<br>            在串处理指令（movsb，movsw）中，控制每次操作后si、di的增减<br>            df=0：每次操作后si，di递增<br>            df=1：每次操作后si，di递减<br>        2.格式：movsb<br>        3.功能：（以字节为单位传送）<br>            1.((es)<em>16+(di))=((ds)</em>16+(si))<br>            2.如果df=0，则：(si)=(si)+1<br>                           (di)=(di)+1<br>              如果df=1，则：(si)=(si)-1<br>                           (di)=(di)-1<br>            3.功能文字描述<br>                movsb的功能是将ds:si指向的内存单元中的字节<br>                送入es:di中，然后根据标志寄存器df位的值，<br>                  将si和di递增或递减<br>        4.movsw 传送一个字<br>        5.movsb和movsw都和rep配合使用<br>            格式：rep movsb<br>            rep的作用根据cx的值，重复执行后面的串传送指令<br>        6.cld指令和std指令<br>            cld指令：将标志寄存器的df置为0【c:clear】<br>            std指令：将标志寄存器的df置为1【s:set】<br>    11.11 pushf和popf<br>        pushf：将标志寄存器的值压栈<br>        popf：从栈中弹出数据，送入标志寄存器中<br>        pushf和popf为直接访问标志寄存器提供了一种方法<br>    11.12 标志寄存器在debug中的表示</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h1><pre><code>**引言和简介
    1.中断是CPU处理外部突发事件的一个重要技术
    2.它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后
        又立即返回断点，继续进行CPU原来的工作。
    3.引起中断的原因【即：发出中断请求的来源叫作中断源】
    4.根据中断源的不同，可以把中断分为：【软件中断】和【硬件中断】两大类
        而硬件中断又可以分为【外部中断】和【内部中断】两类
</code></pre><p>12.1 内中断的产生<br>        1.外部中断一般是指计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断。<br>            外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。<br>        2.内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断）所引起的中断。<br>            内部中断是不可屏蔽的中断<br>        3.软件中断其实并不是真正的中断，他们只是可被调用执行的一般程序，<br>            DOS的系统功能调用（int 21h）都是软件中断<br>        4.CPU为了处理并发的中断请求，规定了中断的优先权，优先权由高到低的顺序是：<br>            1.除法错、溢出中断、软件中断<br>            2.不可屏蔽中断<br>            3.可屏蔽中断<br>            4.单步中断<br>12.2 中断处理程序简介<br>        1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系<br>            使得CPU根据中断信息可以找到要执行的处理程序。<br>        2.中断信息中包含有表示中断的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序的。<br>        3.CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址<br>            即中断类型码是中断向量在中断向量表中的索引<br>12.3 中断向量表【中断向量表就是中断向量的列表】<br>        1.中断向量表在内存中保存，其中存放着256个【2^8,8位中断类型码】中断源所对应的中断处理程序的入口<br>            对于8086PC机，中断向量表指定放在内存地址0处<br>        2.从0:0-0:03ffh的1024个字节【256<em>4，物理地址使用段地址和偏移地址存放，需要4个字节】中存放着中断向量表<br>12.4 中断过程<br>        1.可以用中断类型码，在中断向量表中找到中断处理程序的入口<br>            找到这个入口地址的最终目的是用它设置cs和ip，使CPU执行中断处理程序<br>        2.用中断类型码找到中断向量，并用它设置cs和ip，这个工作时由CPU的硬件自动完成的<br>            CPU硬件完成这个工作的过程被称为【中断过程】<br>        3.中断过程<br>            8086CPU的中断过程<br>            1.（从中断信息中）取得中断类型码<br>            2.标志寄存器的值入栈（保护标志位）<br>            3.设置标志寄存器的第8位TF和第9位IF设置为0（后面讲解本步的目的）<br>            4.cs内容入栈<br>            5.ip内容入栈<br>            6.从内存地址为中断类型码</em>4和中断类型码<em>4+2的两个子单元中<br>                读取中断处理程序的入口地址设置cs和ip<br>        4.使用汇编语言描述中断过程，如下<br>            1.取得中断类型码N<br>            2.pushf<br>            3.TF=0，IF=0<br>            4.push cs<br>            5.push ip<br>            6.（ip）=（N</em>4），（cs）=（N*4+2）<br>12.5 中断处理程序<br>        1.由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，<br>            所以，中断处理程序必须一致存储在内存某段空间中<br>        2.而中断处理程序的入口地址，即【中断向量】，必须存储在对应的中断向量表表项中<br>        3.中断处理程序的编写方法和子程序的比较类似，下面是常规的步骤<br>            1.保存用到的寄存器<br>            2.处理中断<br>            3.恢复用到的寄存器<br>            4.用iret指令返回<br>            **iret指令的功能用汇编语法描述为<br>                pop ip<br>                pop cs<br>                popf<br>              iret通常和硬件自动完成的中断过程配合使用<br>              iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序<br>12.6 除法错误中断的处理<br>        当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的终端信息<br>        CPU将检测到这个信息，然后引发中断程序，转去执行0号中断对应的中断处理程序<br>        例如：<br>            mov ax 1000h<br>            mov bh，1<br>            div bh<br>          此程序会产生溢出<br>          运行之后，会显示<br><img src="img_ass/12.1.png" alt="avatar"></p>
<p>12.7 编程处理0号中断<br>        现在重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to here!”的广告词，然后返回到操作系统<br>        把中断处理程序放到安全空间中<br>        中断程序的框架<br><img src="img_ass/12.2.png" alt="avatar"></p>
<p>12.8 安装<br>        计算中断程序的长度：offset 标号1-offset 标号2<br>        在代码段中存放数据<br>12.9 do0<br>12.10 设置中断向量<br>12.11 单步中断<br>        如果检测到标志寄存器的tf位为1，则产生单步中断，引发中断过程<br>12.12 响应中断的特殊情况<br><img src="img_ass/12.3.png" alt="avatar"><br><img src="img_ass/12.4.png" alt="avatar"></p>
<h1 id="第十三章-int指令"><a href="#第十三章-int指令" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h1><p>13.1 int指令<br>        1.int格式：int n  ;n为中断类型码<br>            它的功能是引发中断过程<br>        2.CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下<br>            1.取中断类型码<br>            2.标志寄存器入栈，if=0，tf=0<br>            3.cs，ip入栈<br>            4.从此处转去执行n号中断的中断处理过程<br>        3.可以在程序中使用int指令调用任何一个中断的中断处理程序<br>            可以用int指令调用这些子程序，也可以自己编写一些中断处理程序供别人使用<br>13.2 编写供应用程序调用的中断例程<br>        【实例1】编写、安装中断7ch的中断例程，实现求一个word型数据的平方<br>            1.功能：求一word型数据的平方<br>            2.参数：（ax）=要计算的数据<br>            3.返回值：dx、ax中存放结果的高16位和低16位<br>            4.应用举例：求2*3456^2</p>
<pre><code>;程序1：调用中断程序计算平方
code segment
    assume cs: code
start:
    mov ax,3456; (ax)=3456
    int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方

    add ax,ax
    adc dx,dx ;存放结果，讲结果乘以2
    mov ax,4c00h
    int 21h
code ends
end start

;程序2：编写中断程序
;程序2中要做三部分工作
;   1.编程实现求平方功能的程序
;   2.安装程序，我们将其安装在0:200处
;   3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。
code segment
    assume cs:code
start:
    mov ax,cs
    mov ds,ax
    mov si,offset sqr                    ;设置ds:si指向源地址
    mov ax,0
    mov es,ax
    mov di,200h                            ;设置es:di指向目的地址
    mov cx,offset sqrend - offset sqr    ;设置cx为传输长度
    cld                                    ;设置传输方向为正
    rep movsb

    mov ax,0
    mov es,ax
    mov word ptr es:[7ch*4],200h        ;设置中断向量地址，偏移地址
    mov word ptr es:[7ch*4+2],0         ;设置中断向量地址，段地址

    mov ax,4c00h
    int 21h

  sqr:  
        mul ax
        iret
sqrend:    nop

code ends
end start
</code></pre><pre><code>    【实例2】编写、安装中断7ch的中断例程，实现将一个全是字母，以0结尾的字符串，转化为大写。
</code></pre><pre><code>code segment
    assume cs:code
start:
    mov ax,cs
    mov ds,ax
    mov si,offset capital
    mov ax,0
    mov es,ax
    mov di,200h
    mov cx,offset capitalend - offset capital
    cld
    rep movsb

    mov ax,0
    mov es,ax
    mov word ptr es:[7ch*4],200h
    mov word ptr es:[7ch*4+2],0

    mov ax,4c00h
    int 21h

capital:
    push cx
    push si

change: 
    mov cl,[si]
    mov ch,0
    jcxz ok
    and byte ptr [si],11011111b
    inc si
    jmp short change
ok:    
    pop si
    pop cx
    iret

capitalend:
    nop

code ends
end start
</code></pre><p>13.3 对int、iret和栈的深入理解<br>        【问题】用7ch中断例程完成loop指令的功能<br>            不要随便修改sp，可以使用bp进行间接访问<br>13.4 BIOS和DOS所提供的中断例程<br>13.5 BIOS和DOS中断例程的安装过程<br>        1.开机后，CPU一加电，初始化（cs）=0ffffh，ip=0，自动从ffff:0单元开始执行程序<br>            ffff:0处有一条跳转指令，CPU执行该指令后，转去执行bios中的硬件系统的检测和初始化程序。<br>        2.初始化程序将建立bios所支持的中断向量，即将bios提供的中断例程的入口地址登记在中断向量表中。<br>        3.硬件系统检测和初始化完成后，调用19h进行操作系统的引导。从此将计算机交由操作系统控制。<br>        4.DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量<br>13.6 BIOS中断例程的应用<br>        1.int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序<br>            一般来说，一个供程序员调用的中断例程中，往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序<br>        2.bios和dos提供的中断例程，都用ah来传递内部子程序的编号<br>13.7 DOS中断例程应用<br>        int 21h中断例程是dos提供的中断例程，其中包含了dos提供给程序员造编程时调用的子程序<br>        【实验13】<br>    **介绍一本汇编语言的书《The Art of Assembly Language》</p>
<h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><pre><code>CPU可以直接读写3个地方的数据
    1.CPU内部的寄存器
    2.内存单元
    3.端口
</code></pre><p>14.1 端口的读写<br>        1.对端口的读写不能用mov、push、pop等内存读写指令<br>            端口的读写指令只有两条：【in】和【out】分别用于从端口读取数据和往端口写入数据<br>        2.CPU执行内存访问指令和端口访问指令时，总线上的信息：<br>            1.访问内存<br>                mov ax,ds:[8];<br>                假设执行前（ds）=0<br>                执行时，与总线相关的操作：<br>                1.CPU通过地址线将地址信息8发出<br>                2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据<br>                3.存储器将8号单元中的数据通过数据线送入CPU<br>            2.访问端口<br>                这里的【端口】是对硬件开放的端口<br>                in al,60h; 从60h号端口读入一个字节<br>                执行时与总线相关的操作<br>                1.CPU通过地址线将地址信息60h发出<br>                2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据<br>                3.端口所在的芯片将60h端口中的数据通过数据线送入CPU<br>                <strong>注意：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据<br>                    访问8位端口时用al，访问16位端口时用ax<br>            3.对0-255以内的端口进行读写<br>                in al,20h       ;从20h端口读一个字节<br>                out 20h,al      ;往20h端口写一个字节<br>            4.对256-65535的端口进行读写时，端口号放在【dx】中<br>                mov dx,3f8h     ;将端口号3f8送入dx<br>                in al,dx        ;从3f8h端口读一个字节<br>                out dx,al        ;从3f8h端口写一个字节<br>14.2 CMOS RAM芯片<br>        1.PC机中有一个CMOS RAM芯片，其有如下特征<br>            1.包含一个实时钟和一个有128个存储单元的RAM存储器。（早期的计算机为64字节）<br>            2.该芯片靠电池供电。因此，关机后其内部的实时钟仍可以正常工作，RAM中的信息不丢失<br>            3.128字节的RAM中，内部实时钟占用0-0dh单元来保存时间信息，其余大部分分单元用于<br>                保存系统配置信息，供系统启动时bios程序读取<br>                bios也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息
            </strong>补充：BIOS<br>                BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。<br>                  在IBM PC兼容系统上，是一种业界标准的固件接口。BIOS这个字眼是在1975年第一次由CP/M操作系统中出现。<br>                  BIOS是个人电脑启动时加载的第一个软件<br>            4.该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS RAM。<br>            5.70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据<br>                或要写入到其中的数据<br>        2.比如：读CMOS RAM的2号单元：<br>            1.将2送入端口70h<br>            2.从71h读取2号单元的内容<br>    14.3 shl和shr指令<br>        shl和shr是逻辑移位指令，后面的课程中我们要用到移位指令<br>        1.shl逻辑左移指令，功能为：<br>            1.将一个寄存器或内存单元中的数据向左移位<br>            2.将最后移出的移位写入cf中<br>            3.最低位用0补充<br>            例如有如下指令：<br>                mov al,01001000b<br>                shl al,1        ;将al中的数据左移一位<br>                执行后(al)=100100000b，cf=0.<br>            如果移动位数大于1时，必须将移动位数放在cl中<br>        2.shr逻辑右移指令，与shl刚好相反<br>14.4 CMOS RAM中存储的时间信息<br>        在CMOS RAM中存放着当前时间<br>          秒：00h<br>          分：02h<br>          时：04h<br>          日：07h<br>          月：08h<br>          年：09h<br>        这6个信息的长度都为1个字节<br>        这些数据以BCD码的方式存放，一个字节可以表示两个BCD码<br>        CMOS RAM存储时间信息的单元中存储了用两个BCD码表示的两个十进制数<br>            高4位的BCD码表示十位，低四位的BCD码表示个位<br>        【编程】：在屏幕中间显示当前的月份<br>            1.CMOS RAM芯片回顾：<br>                1.70h为地址端口，存放要访问的CMOS RAM单元的地址<br>                2.71h为数据端口，存放从选定的CMOS RAM单元中【读取】的数据，或【写入】其中的数据<br>            2.分析<br>              这个程序主要做两部分工作<br>                1.从CMOS RAM的8号单元读取当前月份的BCD码<br>                    要读取CMOS RAM的信息，我们首先要向地址端口70h写入要访问的单元的地址<br>                    mov al,8<br>                    out 70h,al<br>                    然后从数据端口71h中取得指定单元中的数据<br>                    in al,71h<br>                2.将用BCD码表示的月份以十进制的形式显示到屏幕上</p>
<pre><code>;编程：在屏幕中间显示当前的月份
code segment
    assume cs:code
start:
    mov    al,8
    out 70h,al
    in    al,71h
    mov ah,al
    mov cl,4
    shr ah,cl
    and al,00001111b

    add ah,30h
    add al,30h

    mov bx,0b800h    ;显存
    mov es,bx
    mov byte ptr es:[160*12+40*2],ah     ;显示月份的十位数码
    mov byte ptr es:[160*12+40*2+2],al   ;显示月份的个位数码

    mov ax,4c00h
    int 21h
code ends
end start
</code></pre><pre><code>    【实验十四】编程：以“年/月/日 时:分:秒”的格式，显示当前日期和时间
</code></pre><h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><pre><code>**CPU除了有运算能力，还有I/O能力
</code></pre><p>15.1 接口芯片和端口<br>        1.在PC系统的接口卡和主板上，装有各种接口芯片，这些外设接口芯片的内部装有若干寄存器<br>            CPU将这些寄存器当做【端口】访问<br>        2.外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的【端口】中<br>        3.CPU向外设的输出也是要先送入【端口】中，再由相关芯片送入到外设<br>        4.CPU可以向外设输出控制命令，这些控制命令也是先送到【端口】中，然后相关芯片根据命令进行相关工作<br>        5.可见：CPU与外部设备的交流是通过【端口】进行的<br>            CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入<br>15.2 外中断信息<br>        1.在PC系统中，外中断源一共有两类<br>            1.可屏蔽中断<br>            2.不可屏蔽中断<br>        2.可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断<br>            要看标志寄存器的IF位的设置<br>            当CPU检测到可屏蔽中断信息时：<br>            1.若IF=1，则CPU在执行完当前指令后相应中断，引发中断过程<br>            2.若IF=0，则不响应可屏蔽中断<br>        3.可屏蔽中断所引发的中断过程，除在第一步的实现上与内中断有所不同外，基本上和内中断的中断过程相同<br>        4.因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的<br>            而内中断的中断码是在CPU内部产生的<br>        5.IF设置为0的原因：在进入中断处理程序后，禁止其他的可屏蔽中断<br>            当然，如果中断处理程序中需要处理可屏蔽中断，可以用指令将IF设置为1<br>        6.8086CPU提供的设置IF的指令如下：<br>            sti         ;用于设置IF=1<br>            cli         ;用于设置IF=0<br>        7.不可屏蔽中断是CPU必须相应的外中断。<br>            当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后<br>            立即响应，应发中断过程<br>        8.8086CPU不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码<br>        9.不可屏蔽中断的中断过程<br>            1.标志寄存器入栈，IF=0，TF=0<br>            2.CS，IP入栈<br>            3.（IP）=（8），（CS）=（0AH）   ;固定地址<br>        10.几乎所有外中断，都是可屏蔽中断。当外设有需要处理的事件发生时<br>            相关芯片向CPU发出可屏蔽中断信息。<br>            不可屏蔽中断是系统中有必须处理的紧急情况发生时用来通知CPU的中断信息，本门课程中，主要讨论可屏蔽中断<br>    15.3 PC机键盘的处理过程<br>        1.下面看一个键盘输入的处理过程，并以此来体会PC机处理外设输入的基本方法<br>            1.键盘输入<br>            2.引发9号中断<br>            3.执行int 9中断例程<br>        2.PC机键盘的处理过程<br>            1.键盘上每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一触键的开关状态进行扫描。<br>            2.按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明按下的键在键盘上的位置<br>                扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H<br>            3.松开控下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时<br>                产生的扫描码也被送入60H端口中。<br>              一般按下一个键时，产生的扫描码称为通码，松开一个键产生的扫描码称为断码<br>              扫描码长度为一个字节，通码的第七位为0，断码的第七位为1<br>                即：断码=通码+80H<br>              **BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要的工作如下：<br>                1.读出60H端口中的扫描码<br>                2.如果是字符键的扫描码，将该扫描码对应的字符码（即：ASCII码）送入内存中的BIOS键盘缓冲区<br>                3，如果是控制键和切换键的扫描码，则将其转变为状态字节，写入内存中存储状态字节的单元<br>            4.键盘的输入到达60H端口时，相关的芯片会向CPU发出中断类型码为9的可屏蔽中断信息。<br>            5.CPU检测到中断信息后，如果IF=1，则相应中断，同时将IF设置为0（不让其他可屏蔽中断进行干扰），引发中断过程，转去执行int9中断例程<br>        3.BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接受的键盘输入的内存区<br>        4.该内存区可以存储15个键盘输入，int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，<br>            所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高字节存放扫描码，低字节存放字符码<br>        5.0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：<br><img src="img_ass/15.1.png" alt="avatar"></p>
<p>15.4 编写int9中断例程,并安装<br>        梳理键盘输入的处理过程<br>            1.键盘产生扫描码<br>            2.扫描码送入60H端口<br>            3.一旦侦测到60H端口有动静，引发9号中断<br>            4.CPU执行int9中断例程处理输入<br>          以上的过程，前三步都由硬件系统自动完成，能够修改的只有第四步，修改int9中断程序<br>        【任务演示】在屏幕中依次显示“a”~“z”并可以让人看清。在显示过程中，按下Esc键后，该表显示的颜色</p>
<pre><code>;程序1：实现连续显示“a”~“z”
;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。
;部分功能代码：
stack segment
    db 128 dup (0)
stack ends

code segment
    assume cs:code
start:  
    mov ax,stack
    mov ss,ax
    mov sp,128

    mov ax,0b800h
    mov es,ax
    mov ah,&#39;a&#39;
s:    mov es:[160*12+40*2],ah
    call delay
    inc ah
    cmp ah,&#39;z&#39;
    jna s

    mov ax,4c00h
    int 21h

delay:    
    push ax
    push dx
    mov dx,0010h    ;循环10000000h次
    mov ax,0
s1:                       
    sub ax,1
    sbb dx,0
    cmp ax,0
    jne s1
    cmp dx,0
    jne s1
    pop dx
    pop ax
    ret

code ends
end start 

;程序2：实现改变颜色
;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。
stack segment
    db 128 dup (0)
stack ends

data segment
    dw 0,0
data ends

code segment
    assume cs:code
start:    
    mov ax,stack
    mov ss,ax
    mov sp,128
    mov ax,data
    mov ds,ax
    mov ax,0
    mov es,ax

    push es:[9*4]
    pop ds:[0]
    push es:[9*4+2]
    pop ds:[2]            ;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中

    mov word ptr es:[9*4],offset int9
    mov es:[9*4+2],cs    ;在中断向量表中设置新的int 9中断例程的入口地址

    mov ax,0b800h
    mov es,ax
    mov ah,&#39;a&#39;
s:    
    mov  es:[160*12+40*2],ah
    call delay
    inc ah
    cmp ah,&#39;z&#39;
    jna s
    mov ax,0
    mov es,ax

    push ds:[0]
    pop es:[9*4]
    push ds;[2]
    pop es;[9*4+2]       ;将中断向量表中int 9中断例程的入口恢复为原来的地址

    mov ax,4c00h
    int 21h

delay:    
    push ax
    push dx
    mov dx,0010h
    mov ax,0
s1:     
    sub ax,1
    sbb dx,0
    cmp ax,0
    jne s1
    cmp dx,0
    jne s1
    pop dx
    pop ax
    ret

;------以下为新的int 9中断例程--------------------
;int9中断例程是在进行键盘输入之后，由系统自动调用
int9:    
    push ax
    push bx
    push es

    in al,60h

    pushf
    pushf
    pop bx
    and bh,11111100b
    push bx
    popf
    call dword ptr ds:[0]                 ;对int指令进行模拟，调用原来的int 9中断例程

    cmp al,1
    jne int9ret

    mov ax,0b800h
    mov es,ax
    inc byte ptr es:[160*12+40*2+1]      ;属性增加1，改变颜色

int9ret:
    pop es
    pop bx
    pop ax
    iret

code ends
end start
</code></pre><h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><p>16.1 描述了单元长度的标号<br>        1.本章讨论如何有效合理地组织数据，以及相关的编程技术<br>            1.前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址<br>            2.还可以使用一种标号，这种标号不但可以表示内存单元的地址，还表示了内存单元的长度<br>                即：表示在此标号处的单元，是一个字节单元，还是字单元还是双字单元<br>        2.例如<br>            1.标号1<br>            a : db 1,2,3,4,5,6,7,8<br>            b : dw 0<br>          此种标号只能标记地址<br>          此种加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用<br>            2.标号2<br>            a db 1,2,3,4,5,6,7,8    ;标号a，描述了地址code:0,和从这个地址开始，以后的内存单元都是字节单元<br>            b dw 0                  ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元<br>          此种标号既可以标记地址，也可以表示此标号处的单元<br>        3.使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据<br>          这种标号此后称为数据标号，它标记了存储数据的单元的地址和长度<br>        4.数据标号的用法<br>            指令：mov ax,b             ;相当于：mov ax,cs:[8]<br>            指令：mov b,2              ;相当于：mov word ptr cs:[8],2<br>            指令：inc b                ;相当于：inc word ptr cs:[8]<br>            指令：mov al,a [si]        ;相当于：mov al,cs:0[si]<br>            指令：mov al,a[3]          ;相当于：mov al,cs:0[3]<br>            指令：mov al,a[bx+si+3]    ;相当于：mov al,cs:0[bx+si+3]<br>16.2 在其他段中使用数据标号<br>        1.注意，如果想在代码段中，直接用数据标号访问数据，<br>            则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来。<br>          否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。</p>
<pre><code>    2. 当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，
        用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。
    3.我们可以将数据标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。 
      1.把数据标号当做数据来定义时，使用【dw】定义数据
      比如：     data segment
                      a db 1,2,3,4,5,6,7,8
                        b dw 0
                    c dw a,b        ;数据标号c处存储的两个字型数据为标号a、b 的偏移地址。
                   data ends
      数据标号c处存储的两个字型数据为标号a、b 的偏移地址。
      相当于：
                data segment
                    a db 1,2,3,4,5,6,7,8
                    b dw 0
                    c dw offset a, offset b
                 data ends
      2.把数据标号当做数据来定义时，使用【dd】定义数据
        再比如：
            data segment
                a db 1,2,3,4,5,6,7,8
                b dw 0
                c dd a,b    ;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。
             data ends
        数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。
        相当于：
            data segment
                    a db 1,2,3,4,5,6,7,8
                    b dw 0
                    c dw offset a, seg a, offset b, seg b   ;seg操作符，功能为取得某一标号的段地址。
                 data ends
            seg操作符，功能为取得某一标号的段地址。
16.3 直接定址表
    本节课，我们将使用“查表”的方法，编写相关程序的技巧
    【任务】编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据
</code></pre><pre><code>code segment
    assume cs:code
start:  
        mov al,0eh          ;al中存放了byte型数据

        call showbyte

        mov ax,4c00h
        int 21h

;子程序：
;用al传送要显示的数据

showbyte:
        jmp short show

        table db &#39;0123456789ABCDEF&#39;    ;字符表

show:   push bx                 ;保护现场
        push es

        mov ah,al
        shr ah,1           
        shr ah,1
        shr ah,1
        shr ah,1                ;右移4位，ah中得到高4位的值
        and al,00001111b        ;al中为低4位的值

        mov bl,ah
        mov bh,0
        mov ah,table[bx]        ;用高4位的值作为相对于table的偏移，取得对应的字符

        mov bx,0b800h
        mov es,bx
        mov es:[160*12+40*2],ah

        mov bl,al
        mov bh,0
        mov al,table[bx]        ;用低4位的值作为相对于table的偏移，取得对应的字符

        mov es:[160*12+40*2+2],al

        pop es
        pop bx
        ret

code ends
end start
</code></pre><p>16.4 程序入口地址的直接定址表<br>        【编程】实现一个子程序setscreen，为显示输出提供如下功能：<br>            1.清屏<br>            2.设置前景色<br>            3.设置背景色<br>            4.向上滚动一行<br>        1.入口参数说明：<br>            1.用ah寄存器传递功能号<br>                0：清屏；1：设置前景色；2：设置背景色；3：向上滚动一行<br>            2.对于2、3号功能，用al传递颜色值<br>                al∈{0，1，2，3，4，5，6，7}<br>        2.各种功能如何实现<br>            1.清屏：<br>                将显存中当前屏幕中的字符设为空格符；<br>            2.设置前景色：<br>                设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；<br>                012位存放前景色<br>            3.设置背景色：<br>                设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；<br>                456位存放背景色<br>            4.向上滚动一行：<br>                依次将第 n+1行的内容复制到第n行处：最后一行为空。  </p>
<pre><code>;功能子程序1：清屏
sub1:      push bx      ;保护现场,调用子程序的时候，注意要保护现场，运行子程序的时候，可能会修改一些寄存器的值
        push cx
        push es
        mov bx,0b800h
        mov es,bx
        mov bx,0
        mov cx,2000
sub1s:    mov byte ptr es:[bx],&#39; &#39;  ;循坏2000次
        add bx,2
        loop sub1s
        pop es          ;恢复现场
        pop cx
        pop bx
        ret     
;功能子程序2：设置前景
sub2:    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,1
    mov cx,2000
sub2s:    and byte ptr es:[bx],11111000b    
    or es:[bx],al 
    add bx,2
    loop sub2s

    pop es
    pop cx
    pop bx
    ret        
;功能子程序3：设置背景色
sub3:    push bx
    push cx
    push es
    mov cl,4
    shl al,cl
    mov bx,0b800h
    mov es,bx
    mov bx,1
    mov cx,2000
sub3s:    and byte ptr es:[bx],10001111b
    or es:[bx],al 
    add bx,2
    loop sub2s

    pop es
    pop cx
    pop bx
    ret 
;功能子程序4：向上滚动一行
sub4:    
    push cx
    push si
    push di
    push es
    push ds

    mov si,0b800h
    mov es,si
    mov ds,si
    mov si,160            ;ds:si指向第n+1行，第1行
    mov di,0            ;es:di指向第n行，第0行
    cld
    mov cx,24;共复制24行

sub4s:    
    push cx
    mov cx,160
    rep movsb             ;复制
      pop cx
    loop sub4s

    mov cx,80    
    mov si,0

sub4s1: 
    mov byte ptr es:[160*24+si],&#39; &#39;        ;最后一行清空
    add si,2
    loop sub4s1

    pop ds
    pop es
    pop di
    pop si
    pop cx
    ret ;sub4 ends
</code></pre><pre><code>    3.可以将这些功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应
</code></pre><pre><code>;编程：实现一个子程序setscreen，为显示输出提供如下功能：
;(1) 清屏。
;(2) 设置前景色。
;(3) 设置背景色。
;(4) 向上滚动一行。
;
;入口参数说明：
;(1) 用 ah 寄存器传递功能号：0 表示清屏，1表示设置前景色，2 表示设置背景色，3 表示向上滚动一行；
;(2) 对于2、3号功能，用 al 传送颜色值，(al) ∈{0,1,2,3,4,5,6,7}

setscreen: jmp short set

    table  dw sub1,sub2,sub3,sub4

set:    
    push bx    
    cmp ah,3        ;判断传递的是否大于 3
    ja sret
    mov bl,ah
    mov bh,0
    add bx,bx        ;根据ah中的功能号计算对应子程序的地址在table表中的偏移

    call word ptr table[bx]    ;调用对应的功能子程序，学会本句代码，是本章节的【精髓】

sret:    
    pop bx    
    iret

;功能子程序1：清屏
sub1:   
    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,0
    mov cx,2000

sub1s:  
    mov byte ptr es:[bx],&#39; &#39;
    add bx,2
    loop sub1s
    pop es
    pop cx
    pop bx
    ret ;sub1 ends

;功能子程序2：设置前景色
sub2:    
    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,1
    mov cx,2000

sub2s:    
    and byte ptr es:[bx],11111000b    
    or es:[bx],al 
    add bx,2
    loop sub2s

    pop es
    pop cx
    pop bx
    ret ;sub2 ends

;功能子程序3：设置背景色
sub3:    
    push bx
    push cx
    push es
    mov cl,4
    shl al,cl
    mov bx,0b800h
    mov es,bx
    mov bx,1
    mov cx,2000

sub3s:    
    and byte ptr es:[bx],10001111b
    or es:[bx],al 
    add bx,2
    loop sub2s

    pop es
    pop cx
    pop bx
    ret ; sub3 ends

;功能子程序4：向上滚动一行
sub4:    
    push cx
    push si
    push di
    push es
    push ds

    mov si,0b800h
    mov es,si
    mov ds,si
    mov si,160            ;ds:si指向第n+1行
    mov di,0            ;es:di指向第n行
    cld
    mov cx,24;共复制24行

sub4s:    
    push cx
    mov cx,160
    rep movsb             ;复制
      pop cx
    loop sub4s

    mov cx,80    
    mov si,0

sub4s1: 
    mov byte ptr es:[160*24+si],&#39; &#39;        ;最后一行清空
    add si,2
    loop sub4s1

    pop ds
    pop es
    pop di
    pop si
    pop cx
    ret ;sub4 ends
</code></pre><h1 id="第十七章-使用BIOS进入键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进入键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进入键盘输入和磁盘读写"></a>第十七章 使用BIOS进入键盘输入和磁盘读写</h1><pre><code>**引言
    1.大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。
    2.程序和数据通常需要长期存储，磁盘是最常用的存储设备。
    3.BIOS 为这两种外设的I/O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。
</code></pre><p>17.1 int9中断例程对键盘输入的处理<br>        CPU 在9 号中断发生后，执行int 9中断例程，从60h 端口读出扫描码，<br>            并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。<br>    17.2 使用int16h中断例程读取键盘缓冲区<br>        1.BIOS提供了int 16h 中断例程供程序员调用。<br>        2.int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。<br>        3.下面的指令从键盘缓冲区（缓冲区的最低位）中读取一个键盘输入，并且将其从缓冲区中删除：<br>               mov ah,0<br>               int 16h<br>          结果：(ah)=扫描码，(al)=ASCII码。<br>        4.int 16h 中断例程的 0 号功能，进行如下的工作：<br>            （1）检测键盘缓冲区中是否有数据；<br>            （2）没有则继续做第1 步；（缓冲区随时有可能输入数据）<br>            （3）读取缓冲区第一个字单元中的键盘输入；<br>            （4）将读取的扫描码送入ah，ASCII 码送入al；<br>            （5）将己读取的键盘输入从缓冲区中删除。<br>        5.可见，B1OS 的int 9 中断例程和int 16h 中断例程是一对相互配合的程序，<br>            int 9 中断例程向键盘缓冲区中写入，<br>            int 16h 中断例程从缓冲区中读出。<br>          它们写入和读出的时机不同，int 9 中断例程在有键按下的时候向键盘缓冲区中写入数据；<br>          而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。<br>        【编程】接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”，<br>            将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。</p>
<pre><code>;编程：
;接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， 
;将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。
;A、B、C处的程序指令比较有技巧，请读者自行分析
code segment
    assume cs:code
start:    
    mov ah,0
    int 16h                ;int 16h 0号功能实现从键盘缓冲区读取一个键盘输入

    mov ah,1            ;A
    cmp al,&#39;r&#39;
    je red
    cmp al,&#39;g&#39;
    je green
    cmp al,&#39;b&#39;
    je blue
    jmp short sret

red:    
    shl ah,1            ;B
green:    
    shl ah,1            ;C

blue:    
    mov bx,0b800h
    mov es,bx
    mov bx,1
    mov cx,2000
s:    and byte ptr es:[bx],11111000b      ;设置颜色
    or es:[bx],ah                       ;设置颜色
    add bx,2
    loop s

sret:    
    mov ax,4c00h
    int 21h

code ends
end start
</code></pre><p>17.3 字符串的输入<br>        int 21h的0a号功能可以实现字符串的输入<br>        也可以用int 16h，通过显示键盘缓冲区中的内容，实现字符串的显示<br>        1.使用int 16h显示字符串程序的处理过程如下<br>            ① 调用int 16h读取键盘输入；<br>            ② 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行① ；<br>            ③ 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行① ；<br>            ④ 如果是Enter 键，向字符栈中压入0，返回。<br>        2.子程序：字符栈的入栈、出栈和显示<br>            参数说明<br>            (ah)=功能号，0表示入栈，1表示出栈，2表示显示；<br>                ds : si 指向字符栈空间；<br>            对于0 号功能：(al)=入栈字符；<br>            对于1 号功能：(al)=返回的字符；<br>            对于2 号功能：(dh)、(dl) =字符串在屏幕上显示的行、列位置。</p>
<pre><code>;使用int 16h显示字符串的子程序：字符栈
;最基本的字符串输入程序，需要具备下面的功能：
;（1） 在输入的同时需要显示这个字符串；
;（2）一般在输入回车符后，字符串输入结束；
;（3）能够删除已经输入的字符。

;编写一个接收字符串的输入子程序，实现上面三个基本功能。
;因为在输入的过程中需要显示，子程序的参数如下：
;    (dh)、(dl)=字符串在屏幕上显示的行、列位置；
;    ds:si 指向字符串的存储空间，字符串以O 为结尾符。

;功能子程序实现

charstack:
    jmp short charstart

    table dw charpush,charpop,charshow
    top dw 0                               ;栈顶

charstart:
    push bx
    push dx
    push di
    push es

    cmp ah,2
    ja sret
    mov bl,ah
    mov bh,0
    add bx,bx
    jmp word ptr table[bx]      ;使用直接定址表

charpush:
    mov bx,top
    mov [si][bx],al
    inc top
    jmp sret

charpop:
    cmp top,0
    je sret
    dec top
    mov bx,top
    mov al,[si][bx]    
    jmp sret

charshow:
    mov bx,0b800h
    mov es,bx
    mov al,160
    mov ah,0    
    mul dh
    mov di,ax
    add dl,dl
    mov dh,0
    add di,dx

    mov bx,0

charshows:
    cmp bx,top
    jne noempty
    mov byte ptr es:[di],&#39; &#39;    
    jmp sret

noempty:
    mov al,[si][bx]
    mov es:[di],al
    mov byte ptr es:[di+2],&#39; &#39;
    inc bx
    add di,2
    jmp charshows

sret:    
    pop es
    pop di
    pop dx
    pop bx
    ret
</code></pre><p>17.4 应用int13h中断例程对键盘进行读写<br>        1.磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。<br>        2.注意，我们只能以扇区为单位对磁盘进行读写。<br>          在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。<br>        3.BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。<br>        4.我们可以通过调用BIOS中断例程来访问磁盘。<br>            BIOS 提供的访问磁盘的中断例程为int 13h 。<br>          如下，读取0面0道1扇区的内容到0:200：<br><img src="img_ass/17.1.png" alt="avatar"></p>
<pre><code>        返回参数：
            操作成功：（ah）=0，（al）=读入的扇区数
            操作失败：（ah）=出错代码
      将0:200中的内容写入0面0道1扇区示例
        返回参数：
</code></pre><p><img src="img_ass/17.2.png" alt="avatar"></p>
<pre><code>            操作成功： (ah)=0，(al)=写入的扇区数
            操作失败： (ah)=出错代码
    5.注意：使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的，
       很可能覆盖掉重要的数据。
    【编程】将当前屏幕的内容保存在磁盘上
        分析：1 屏的内容占4000个字节，需要8 个扇区（一个扇区512B），我们用0面0道的1~8扇区存储显存中的内容。
</code></pre><pre><code>code segment
    assume cs:code
start:    
    mov ax,0b800h
    mov es,ax
    mov bx,0    ;es:bx    指向将写入磁盘的数据的内存区

    mov al,8     ;写入的扇区数
    mov ch,0     ;磁道号，从0开始
    mov cl,1     ;扇区号 从1开始
    mov dl,0     ;驱动器号0:软驱A,  1:软驱B,硬盘从80h开始， 80h:硬盘C，81h:硬盘D
    mov dh,0     ;磁头号，（对于软盘即面号，因为一个面用一个磁头来读写）
    mov ah,3    ;传递 int 13h 写入数据的功能号
    int 13h

            ;返回参数
            ;操作成功:(ah) = 0,(al) = 写入的扇区数
            ;操作失败:(ah) = 出错代码

return:    
    mov ax,4c00h
    int 21h

code ends
end start
</code></pre><pre><code>    【实验17和课程设计2】
        课程设计1在第十章
</code></pre><h1 id="综合研究"><a href="#综合研究" class="headerlink" title="综合研究"></a>综合研究</h1><pre><code>研究试验1 搭建一个精简的C语言开发环境
研究试验2 使用寄存器
研究试验3 使用内存空间
研究试验4 不用main函数编程
研究试验5 函数如何接受不定数量的参数
</code></pre>
        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/AliPayQR.png"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/WeChanQR.png"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
					<div class="tag-cloud">
                  <div class="tag-cloud-title">
                  </div>
                  <div class="tag-cloud-tags">
                  <a href="/tags/Spring/" style="font-size: 10px; color: #f38181">Spring</a> <a href="/tags/ajax/" style="font-size: 10px; color: #f38181">ajax</a> <a href="/tags/css/" style="font-size: 12.5px; color: #dc9996">css</a> <a href="/tags/js/" style="font-size: 15px; color: #c4b1aa">js</a> <a href="/tags/nodeJs/" style="font-size: 10px; color: #f38181">nodeJs</a> <a href="/tags/spring/" style="font-size: 10px; color: #f38181">spring</a> <a href="/tags/vue/" style="font-size: 10px; color: #f38181">vue</a> <a href="/tags/吐槽/" style="font-size: 12.5px; color: #dc9996">吐槽</a> <a href="/tags/大学所学/" style="font-size: 17.5px; color: #adc9bf">大学所学</a> <a href="/tags/机器学习/" style="font-size: 10px; color: #f38181">机器学习</a> <a href="/tags/算法/" style="font-size: 20px; color: #95e1d3">算法</a> <a href="/tags/设计模式/" style="font-size: 10px; color: #f38181">设计模式</a>
                  </div>
                </div>

          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/undefined/线性时间选择/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                线性时间选择</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/undefined/全排列问题/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt2.jpeg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                全排列问题</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "vK4njxg3C8GQOr9L6M8Hav7x-gzGzoHsz",
        appKey: "e9eG1y4IcG54g4l676M1xeWQ",
        path: window.location.pathname,
        placeholder: "整点留言呗"
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt3.jpeg" itemprop="image" alt="" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="" itemprop="url" rel="author"></a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            // PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  

  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Kitholt Frank<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2021</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_uv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
    </div>
  </div><!-- .site-info -->
    
</footer>







<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/kitholt/cdn/img/kt3.jpeg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">KitholtFrank</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/kitholt" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags">
                  <i class="fa fa-tags" aria-hidden="true"></i>
                  标签
                </a>
              </li>
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            资瓷
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="890672374"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
<noscript><iframe src="/blog/*>";</iframe></noscript>
<script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.151/js/click.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/piao.js"></script>
 
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>

<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/clickBom.js"></script>


</html>