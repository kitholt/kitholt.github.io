{"meta":{"title":"欢迎来到Franの杂货铺","subtitle":null,"description":"Halo, my friend!!!!!!","author":"Kitholt Frank","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-04T09:35:18.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-04T07:39:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Fran的小黑屋 到我房间来......&nbsp; 给你看我新买的夜光手表&nbsp; （ ） bot_ui_ini()","keywords":"关于我？"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-04T05:33:56.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-06T15:32:04.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"我的Valine邮箱验证成功啦，欢迎大家来喷我 胡言乱语，乱说一气 :D 获取中... —— :D 获取中... fetch('https://v1.hitokoto.cn/?c=b') .then(response => response.json()) .then(data => { const hitokoto = document.getElementById('hitokoto_text') const from = document.getElementById('from') hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid hitokoto.innerText = data.hitokoto from.innerText = data.from }) .catch(console.error)","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-04T09:10:00.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"散百块，你懂我意思么？(冠希哥.gif)"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-04T05:22:24.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-04T09:06:10.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"环球音乐集团"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"计算机组成原理与汇编语言(持续更新...)","slug":"计算机组成原理与汇编语言","date":"2021-03-10T15:16:38.259Z","updated":"2021-03-10T14:13:46.000Z","comments":true,"path":"2021/03/10/计算机组成原理与汇编语言/","link":"","permalink":"/2021/03/10/计算机组成原理与汇编语言/","excerpt":"","text":"计算机组成原理与汇编语言note①相关概念机器数：数字在计算机中的二进制表达形式，在二进制的最高位存放正或负符号，正数为0，负数为1 真值：带符号位的机器数对应的真正的数值 原码：符号位加上真值的绝对值 反码：正数の反码还是本身，而负数的反码：符号位不变，其余位按位取反 补码：反码+1 那么，为什么要引入反码和补码？ 人脑计算：我们会自动将符号位分开并进行计算 电脑（计算机）计算：因为符号位也是0,1表示，在做计算时，计算机无法辨别哪些是符号位哪些是数值位。如果硬要让计算机认识的话也不是不行，但是这会使计算机的基础电路设计变得异常复杂（这是要累死设计计算机的人- -） 所以我们希望符号位也能参与到运算当中。另外我们都知道CPU只有加法器而没有减法器，这是为什么呢？我们小学就知道，减法是加法的逆运算（减去一个数等于加上那个数的负数），因此只要解决计算机的加法问题就好啦 At First…原码君出来了，但是在运算中很快就发现了问题，比如一个正数和一个负数相加，就会出问题。比如1-1 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [1000_0010]原 = -2 And…出现了原码君的儿子反码君，值得高兴的是，反码能够使得计算结果的真值正确，但是唯独在0这个值上栽了跟头 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原= [0000_0001]反 + [1111_1110]反 = [1111_1111]反 = [1000_0000]原 = -0 0已经能用[0000_0000]原 表示了，现在又整出一个[1000_0000]，没有意义啊这 Finally!原码君的孙子aka反码君的孙子——补码君诞生了，他很完美地解决了这个问题： 1-1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [0000_0001]补 + [1111_1111]补 = [0000_0000]补 =[0000_0000]原 = 0 Besides…除此之外，还可以用 [1000_0000]补 表示-128： (-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补 -1-127的结果应该是-128，在用补码运算的结果中， [1000_0000]补 就代表-128。 注意，-128并没有原码和反码表示。 使用补码不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数，这就是为什么8位二进制使用原码或反码表示的范围为 [-127, +127]，而使用补码表示的范围为 [-128, 127] 的原因。 因为机器使用补码，所以对于编程中常用到的32位int类型可以表示范围是 [-2^31, 2^31-1] ，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"复习堆排序","slug":"复习堆排序","date":"2021-03-06T07:44:20.528Z","updated":"2021-03-06T07:45:00.720Z","comments":true,"path":"2021/03/06/复习堆排序/","link":"","permalink":"/2021/03/06/复习堆排序/","excerpt":"","text":"复习堆排序堆的定义：堆是一个具有以下性质的二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称之为大顶堆。反之称之为小顶堆。 那么，在代码中如何表示大小顶堆？arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2]//大顶堆 arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2]//小顶堆 堆排序の思想 先把待排序序列构建成一个大（小）顶堆 这时，整个序列的最大值就是堆顶的根节点（也就是数组的第一个元素） 将其与末尾元素进行交换，此时末尾就是最大值 然后将剩余的n-1个元素重新构造成一个新的堆，这样就得到n-1个元素的次小值，如此反复，就能得到一个有序序列——[重复（1），（2），（3）步骤] 代码实现：import java.util.Arrays; public class heapSort { public static void main(String[] args){ int[] arr={25, 30, 11, 7, 22, 16, 18, 33, 40, 55}; int temp=0; for(int i=arr.length/2-1;i&gt;=0;i--){//从左往右，从下往上寻找非叶子节点进行初始的堆排序 adjustHeap(arr,i, arr.length); } for(int j=arr.length-1;j&gt;=0;j--){//初始堆建成后，首尾的元素进行交换，此时大顶堆的结构被破坏 temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j);//因为是首尾交换所以只有最顶部的结点不符合顶堆的定义，中间的非叶子节点均符合堆顶义，所此时的i等于0，也就是只从顶部开始调整 } System.out.println(&quot;排序后的数组为：&quot;+Arrays.toString(arr)); } /** * * @param arr 待排序数组 * @param i 以i为父节点进行堆排序的树（数组） * @param length 数组长度 */ public static void adjustHeap(int[] arr,int i,int length){ int temp=arr[i]; for(int k=2*i+1;k&lt;length;k=2*k+1){//k指向i的较大的一个子结点 if((k+1&lt;length)&amp;&amp;arr[k]&lt;arr[k+1]){//判断i叶子结点的左右结点的大小，如果左边的小于右边的，则k++ k++; } if(arr[k]&gt;temp){//如果该子结点大于它的父结点，则将该子结点赋值给父节点 arr[i]=arr[k]; i=k;//以k为父节点继续和它的子节点比较 } } arr[i]=temp;//将最开始保存的arr[i]放到末尾 } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机网络(持续更新...)","slug":"计算机网络","date":"2021-03-04T06:16:12.896Z","updated":"2021-03-10T15:16:14.000Z","comments":true,"path":"2021/03/04/计算机网络/","link":"","permalink":"/2021/03/04/计算机网络/","excerpt":"","text":"计算机网络注：按照课时进度整理 Part①网络的分类 电信网络：向客户提供电话，电报以及传真等服务 有线电视网络：向用户传送各类电视节目 计算机网络：能允许用户能够在计算机之间传送数据文件 思考：internet和Internet有何区别？ internet指的是互连网，它泛指有多个计算机网络互相连而成的计算机网络（网络的网络）。在这些网络之间的通信协议可以任意选择，不一定非要TCP/IP协议 Internet则是我们经常谈到的互联网（因特网），它是由当前全球最大的、开放的、由众多网络互相连接而成的互连网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。PS：现在的互联网具有三级结构，即主干网、地区网、校园网（企业网） 相关名词：ISP（Internet Service Provider）：互联网服务提供者，也就是提供IP地址，比如我国的三大通信巨头：“移”不动、“联”不通、“信”不过，根据覆盖面积大小和IP数量的不同，ISP又分为：主干ISP、地区ISP、本地ISP 互联网的组成：边缘部分：连接在互联网的所有的端系统（手机端、电脑端、网络摄像头……），通过C/S方式和P2P方式进行通信 核心部分：路由器使用分组交换向边缘部分的端系统提供连通性 啥是分组交换？在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。 分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。 分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。 分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。 Part②计算机网络的分类 按照作用范围分类 广域网（远程网）WAN（Wide Area Network） 城域网MAN（Metropolitan Area Network） 局域网LAN（Local Area Network） 个人局域网PAN（Personal Area Network） 按照网络的使用者分类 公用网（public network） 专用网（private network） 用来把用户接入到互联网的网络 接入网AN（Access Network） 计算机网络的性能七dark指标 1、速率 计算机发送出的信号都是数字形式的。比特（bit）来源于binary digit，意思是一个”二进制数字“，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率。速率的单位是bit/s（比特每秒）（或b/s，有时也写作bps，即bit per second）。 当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的速率。 2、带宽 ”带宽“有以下两种不同的意义： （1）带宽本来指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫兹（或千赫、兆赫、吉赫等），在过去很长的一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号）。因此表示某信道允许通过的信号频带范围就称为该信道的带宽。 3、吞吐量 吞吐量表示在单位时间内通过某个网络的实际数据量。 4、时延 时延是指数据从网络的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或者迟延。 网络中的时延是由一下几个不同的部分组成的： （1）发送时延 发送时延是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做传输时延。发送时延的计算公式是： 发送时延=数据帧长度（bit）/发送速率（bit/s） （2）传播时延 传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是： 传播时延=信道长度（m）/电磁波在信道上大的传播速率（m/s） 电磁波在自由空间的传播速率是光速。即3.0*10^5km/s。 发送时延发生在机器内部的发送器中，与传输信道的长度没有任何关系。传播时延发生在机器外部的传输信道媒体上，而与信道的发送速率无关。信号传送的距离越远，传播时延就越大。 （3）处理时延 主机或路由器在收到分组时需要花费一定时间进行处理，例如分析分组的首部，从分组中提取数据部分、进行差错检验或查找合适的路由等，这就产生了处理时延。 （4）排队时延 分组在进行网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待，在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延无穷大。 这样数据在网络中经历的总时延就是以上四种时延之和：总时延=发送时延+传播时延+处理时延+排队时延。 一般来说，小时延的网络要优于大时延的网络。 5、时延带宽积 把传播时延和带宽相乘，就可以得到：传播时延带宽积，即： 时延带宽积=传播时延*带宽0 6、往返时间RTT 在计算机网络中，往返时间RTT是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。 7、利用率 利用率有信道利用率和网络利用率等。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道利用率是零。网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 信道或网络的利用率过高会产生非常大的时延。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"算法分析与设计(持续更新...)","slug":"算法分析与设计","date":"2021-03-03T16:08:16.956Z","updated":"2021-03-08T15:59:48.000Z","comments":true,"path":"2021/03/04/算法分析与设计/","link":"","permalink":"/2021/03/04/算法分析与设计/","excerpt":"","text":"算法分析与设计 chapter①：算法引论定义：解决某种问题的方法 特征：输入，输出，确定性（指令清晰无歧义），有限性（指令执行次数有限） 算法复杂性の分析 时间复杂性：T=T(N[问题规模],I[算法的输入],A[算法本身]) 空间复杂性 ：S=S(N,I) 渐进时间复杂性＝时间复杂度 大O表示法（算法时间运行时间的上界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≤C(g(n))，则称f(n)=O(g(n))，也称f(n)的阶不高于g(n)的阶 大Ω表示法（算法时间运行时间的下界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≥C(g(n))，则称f(n)=Ω(g(n))，也称f(n)的阶不低于g(n)的阶 θ表示法（算法时间运行时间的准确界） C1(g1(n))≤f(n)≤C2(g2(n)) chapter②：递归与分治策略神魔是递归？) 还是…… 从上面的两张图我们可以看出，递归就是自己调用自己的过程。在算法中就是算法自己调用自己，这就是递归算法 很容易知道函数中自身调用自己就成为递归函数 分治（divide&amp;conquer）是乜嘢？凡治众如治寡，分数是也。分治分治，分而治之。大白话就是说把一个规模很大的问题分解成一个个规模较小的子问题，逐个求解，然后子问题的解再“治理”成大问题的最终解 如何使用分治法解决问题？ 解决小规模的问题 分解问题（divide） 递归求解子问题 将所有子问题的解合并为主问题的解 分治?=递归分治是解决问题的一种思想，递归是解决问题的一种方法，也就是说用分治法解决问题的具体实现形式大多是采用递归的方法 有关递归的经典算法实例：汉诺塔问题（略） 整数划分问题问题定义：一个非负正整数都能拆分成若干个数之和或者恰好为自身，比如6这个整数。可以被划分为 6 5+1 4+2 4+1+1 3+3 3+2+1 3+1+1+1 2+2+2 2+2+1+1 2+1+1+1+1 1+1+1+1+1+1 一共有11种划分。并且我们注意到最大的加数是它本身。所以这称为6的划分。如果我们想要得到最大加数≯m的划分个数。比如我们想要最大加数≯5的划分个数，通过上面的表格可以很容易地知道个数是9个，我们用一个函数来表示这个关系f(n,m) 我们很容易知道当n=1时，也就是——————f(1,m)，因为1的划分只能是1，什么你说1+0+0+0+0…不行么，我劝你还是关闭网页吧（bushi） m=1时，——————f(n,1)，也就是说n=(1+1+…+1)[n个1] 当n=m时，从上面的表格可以知道，f(n,n)=1+f(n,n-1)，”1“指的是加数是整数本身时的划分个数，而f(n,n-1)则指的是不包括整数本身的划分个数 当n&gt;m&gt;1时，f(n,m)： 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1); 当划分中包含m时，{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m。此时的划分个数其实就是n-m的划分个数，也就是f(n-m,m) 所以f(n,m)=f(n,m-1)+f(n-m,m)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Keep searching......","slug":"hello-world-zy","date":"2021-03-03T15:55:42.178Z","updated":"2021-02-04T06:16:34.000Z","comments":true,"path":"2021/03/03/hello-world-zy/","link":"","permalink":"/2021/03/03/hello-world-zy/","excerpt":"","text":"Fran还在努力寻找资源……","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"待添加......","slug":"hello-world-tech","date":"2021-03-03T15:55:42.177Z","updated":"2021-02-04T06:14:22.000Z","comments":true,"path":"2021/03/03/hello-world-tech/","link":"","permalink":"/2021/03/03/hello-world-tech/","excerpt":"","text":"2 b continued……","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"蛋疼のNode学习之路(持续更新...)","slug":"蛋疼のNode学习之路","date":"2021-02-28T23:00:00.000Z","updated":"2021-03-12T09:41:06.080Z","comments":true,"path":"2021/03/01/蛋疼のNode学习之路/","link":"","permalink":"/2021/03/01/蛋疼のNode学习之路/","excerpt":"","text":"蛋疼のNode学习之路（持续更新…）Day1Previously on ‘Preface’，对于一个几乎零基础的我来说，搭建博客的过程是十分痛苦的，这现在只是一个简单的修改博客主题和编辑的过程啊（前端知识盲区o(╥﹏╥)o）。所以我决定花上一定时间来学习Node.js。希望学完之后我能更好的运维我的BLog（顺便复【yu】习一下Web相关知识，HTML5，CSS3，JavaScript什么的都快忘光光啦）话不多说，今天开始第一天的学习！ ①那么，Node.js是乜嘢？（what？）解释： 不是一门语言，不是库，不是框架。而是一个js的运行时 ，通俗地说就是能够一个能够运行js的平台环境。 可提供服务器级别的api（需要引入相关的模块，比如文件读写需要’fs’，也就是File-System）：文件读写，网络服务构建，网络通信，http服务器（http模块）……//后面会讲模块系统 特性： 事件驱动 非阻塞IO模型（异步）————————————-啊啥是同步和异步？，又要去恶补了o((⊙﹏⊙))o 轻量和高效 与Node.js相关的东东npm：全称是Node Package Manager。世界上最大的开源生态系统（大多数的js相关的包都在npm里）可在命令行通过下列语法获取相关包 npm install [jquery] ②Node.js能干啥哇？（do what？） web服务器后台（能干类似活的有Java,，PHP，Python，balabala…….） 命令行工具 npm git hexo （这个我熟哈哈） ③参考资源（resource） 《深入浅出Node.js》（偏理论） 《Node.js权威指南》 JavaScript标准参考教程（alpha）作者：阮一峰（惊了，英文名也叫Frank） Node入门（fen） cNode社区 ④安装Node（install）会的都会，不会的戳一戳下面的教程： 参考教程：https://www.runoob.com/nodejs/nodejs-install-setup.html ⑤模块系统（Module system） 在Node中，每一个js文件都是一个模块，另外Node中也没有全局作用域的概念。 在Node中，只能通过require()方法加载js文件。 require()方法只加载其中的代码。既然没有全局作用域，那么各个js文件之间是模块作用域。 模块全封闭。 外部和内部之间是无法互相访问的。 其实每个模块中有都一个exports专属的对象，该对象中可以封装各自模块中的数据和方法，方便其他模块应用 举个例子 var demo =require(&#39;./a&#39;)//调用模板a，并且获得a的exports对象,并且用一个变量demo接收 ——————-分割线，下面进入简单的实操环节——————– 启动一个简单服务器 var http = require(&#39;http&#39;)//创建http对象 var server = http.createServer()//利用http对象创建一个服务器对象server server.listen(4000, function () {//选择端口 console.log(&quot;贪玩蓝月服务器，琦动！&quot;) }) server.on(&#39;request&#39;, function (request, response) {//server监听是否收到客户端发送过来的request，收到后根据回调函数再返回响应 console.log(&quot;收到请求&quot;) response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;})//&lt;-----------解决乱码的方法 var url = request.url if (url == &#39;/&#39;) { response.end(&quot;欢迎来到贪玩蓝月，是兄弟就来砍我&quot;) } else if(url==&#39;/login&#39;){ response.end(&quot;貪玩藍月登錄註冊界面...&quot;) } else if(url==&#39;/register&#39;){ response.end(&quot;快進到貪玩藍月の註冊界面&quot;) } else{ response.end(&quot;404 not found...&quot;) } }) 但是第一次运行的时候出现这种情况……. 不用慌，在回调函数里的第一行加上 response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;}) 运行后的截图 当然一个网站肯定不能只是傻傻地响应同一段内容，服务器必须根据浏览器(客户端)发来的请求信息来对应地响应合适的内容。 实现方法也特别简单，加入一组if-else的判断就可。（详情见上代码line10-21） 实现效果： And: 2.模块系统 解释：在demo中引入模板a—&gt;执行a的代码，在控制台打印starting语句—&gt;引入模板b—&gt;打印模板b的opening和closed—&gt;a中的引用结束，打印a的end—&gt;打印从a模板获取的值foo=200 从中我们发现输出的foo值是模板a中的，而不是b模板中的。这也体现了模块作用域的好处：可以加载执行多个文件，可以完全避免变量命名而产生的冲突（认真脸） ⑥相关知识补充 同步（Synchronous） A程序调用B程序，必须等待B程序完成才能返回到A程序，A程序继续执行……从流程上看是一条”直线“ 异步（Asynchronous） A程序调用B程序，此时A不会等待B程序是否执行完毕，而是继续往后执行自己的代码……从流程上看是出现了一条从主线产生的“支线” 回调函数 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（来自谷歌的解释） 通俗讲就是 ①你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 什么还不懂？行，还有个例子：②约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。~（单身的看例子①就好了） Day2 今天主要围绕模板引擎的概念以及应用方式、渲染这两点展开，并且相对应地结合两个小案例来更进一步的理解感受它们。话不多少，先介绍主要概念。 神么是模板引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。这就好比于我们的写作模板，我们想写什么类型的文章比如说明文，记叙文，抒情文，应用文。它们都有固定的一套模式，我们只要按照这套模式来，往里面添加我们自己的内容即可。 常用模板：art-template（art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。） 安装方法： npm install art-template --save 啥是渲染？在电脑绘图中，渲染是指在指用软件从模型生成图像的过程。而在HTML中则是指如何加工并且显示出最终的HTML页面。我们又根据加工场景位置的不同把HTML渲染分为服务端渲染和客户端渲染。 互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时ajax的兴起，使得业界就开始推崇前后端分离的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的客户端渲染了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。 服务端渲染aka后端渲染（service-side render）の优缺点： 优点 减轻前端压力 不用占用前端的资源，比如在用手机浏览网页时，浏览器的负担减轻，因此能够节省手机的电量 有利于SEO（Search Engine Optimization）搜索引擎优化。爬虫能够爬取到在后端的HTML文档 缺点 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则前端一般就是写一个静态html文件，然后后端再修改为模板，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； 或者是前端直接完成html模板，然后交由后端。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。 占用服务器端资源。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。 客户端渲染aka前端渲染（client-side render）的优缺点： 艾达王替矩（advantages）： 前后端分离，前端能够自定义UI而不用去过度依赖后端 diss艾达王替矩： 前端的响应速度会变慢，这就是为什么我们在浏览一些网页时，经常会“爱的魔力转圈圈”。（后端的渲染速度要比前端的快） 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。因为服务器端可能没有保存完整的html，而是前端通过js进行dom的拼接，那么爬虫无法爬取信息。 除非搜索引擎的seo可以增加对于JavaScript的爬取能力，这才能保证seo。 小案例一：模拟Apacheの目录HTML（服务端渲染）在此之前我们还需要用到fs模块的readFile()和readdir()方法，简单介绍一下这两个方法： readFile()：能够读取指定路径下的文件并保存到data中，data是一个二进制的数据流（里面全是010101），因此要将其转变为我们认识的字符串需要用到toString()方法。 readdir()： 读取指定目录下的所有文件夹名，并返回一个由这些文件夹名构成的字符串数组files。 var fs = require(&#39;fs&#39;); fs.readdir(&#39;readdirtest&#39;, function(err,files){ if(err){ console.log(err); } console.log(files); }) 操作描述： 加载必要的模块fs，http… 设置端口号xxxx 为服务器设置响应信息 读取模板文件template.html（目录显示页），并且将要替换的区域使用特殊符号进行标记，这里我使用了-.-这个标记 读取目录列表的所有文件夹 并将要替换的部分用一个变量content表示 用forEach方法依次取出files里的文件夹名并构建content（见代码20—24） 将第一步读取的data转换为字符串 简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 发送响应 下面是一小段代码： var fs = require(&#39;fs&#39;) var http = require(&#39;http&#39;) var server = http.createServer() var wwwDir = &#39;F:/www&#39; server.on(&#39;request&#39;, function (req, res) { fs.readFile(&#39;./template.html&#39;, function (err, data) {//获得模板template.html if (err) { console.log(&#39;找不到文件......请重试&#39;) } fs.readdir(wwwDir, function (err, files) {//得到wwwDir的目录列表中的文件名和目录名 if (err) { return console.log(&#39;读取目录失败&#39;) } console.log(files)//files是一个字符数组，元素为目录中的文件名 var content = &#39;&#39;//将模板中要替换的部分构建为content files.forEach(function (item) {//利用forEach，取出files数组的每个元素（item），进行渲染${item}替换 content += `&lt;tr&gt;&lt;td data-value=&quot;新建 Microsoft Word 文档.docx&quot;&gt;&lt;a class=&quot;icon file&quot; draggable=&quot;true&quot; href=&quot;/F:/www/%E6%96%B0%E5%BB%BA%20Microsoft%20Word%20%E6%96%87%E6%A1%A3.docx&quot;&gt;${item}&lt;/a&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;0 B&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1612679895&quot;&gt;2021/2/7 下午2:38:15&lt;/td&gt; &lt;/tr&gt;` }) data = data.toString()//将二进制流的data转换为字符串 data=data.replace(&#39;-.-&#39;, content)//简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 res.end(data)//发送响应数据 }) }) }) server.listen(4001, function () { console.log(&#39;服务器，琦动！&#39;) }) 结果截图： 小案例二：art-template需要一个用于储存模板的html和一个js文件 html模板: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;This is Frank&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is {{ name }}.&lt;/p&gt; &lt;p&gt;I am {{ age }} years old.&lt;/p&gt; &lt;p&gt;I am from {{ province }}.&lt;/p&gt; &lt;p&gt;I like {{ each hobbies }} {{ $value }} {{/each}}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果没有art-template，运行结果如下： 加了art-template后： var fs=require(&#39;fs&#39;) var http=require(&#39;http&#39;) var template=require(&#39;art-template&#39;) http .createServer(function(req,res){ var url=req.url if(url===&#39;/&#39;){ fs.readFile(&#39;./Frank.html&#39;,function(err,data){ if(err){ return res.end(&#39;你访问的网址不存在噢&#39;) } data=data.toString() var Frank=template.render(data,{ name:&#39;Frank&#39;, age:20, province:&#39;ChongQing&#39;, hobbies:[&#39;打篮球&#39;,&#39;写博客&#39;,&#39;吹水&#39;] }) res.end(data) }) } }) .listen(3000,function(){ console.log(&#39;琦动！&#39;) 由此可见，art-template只关注中的值，不会去关心html中的格式。因此可以理解为js数据传到html中展示出来 Day3Node中的模块系统模块の定义： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。 使用Node编写应用程序主要就是在使用： Ecmascript 核心模块 文件操作fs http服务的http url路径操作的模块 path路径处理模块 os操作系统模块 第三方模块 art-template 必须通过npm下载 开发者自个儿写的模块（自定义的） 模块化 文件作用域 通信规则 加载require 导出CommonJs模块规范 这就是要谈论的——模 块 系 统 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员 加载require操作： var 自定义变量名称=require(&#39;模块&#39;) 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有成员只在当前文件模块有效 如果我们想要访问其他模块的成员，可以把这些成员加载到exports上去 导出多个成员： exports.demo=foo exports.test=&#39;233&#39; exports.fun=function(){ xxxxxxxxxxxxx } 也可以这样导出多个成员： module.exports={ add: function(){ return xxxxxxx }, foo:&#39;123&#39; } 导出单个成员（指定的）： module.exports=&#39;666&#39; module.exports=function(){ } 注意：在使用module.exports时，后一个的会覆盖前一个的module.exports 原理在底层代码中：exports是module.exports的一个引用—&gt;exports=module.exports console.log(exports===module.exports)//会返回true exports.foo=&#39;666&#39; module.exports.foo=&#39;666&#39;//等价 require方法加载规则 核心模块 模块名 第三方模块 模块名 开发者自己写的 路径 优先从缓存加载 加载过的模块会暂存入缓存中，若下次还有调用，直接从缓存中读取， 能有效提高模块加载效率 package.json每一个项目最好有一个包描述文件（package.json，就像产品的说明书）。可通过npm init生成 。有了该文件，再用npm install就能把文件里的依赖项全部下载回来，就相当于原先有了备份，现在进行备份还原 在每个项目的根目录下应该有一个package.json文件 每次安装第三方包时，应该在后面加上–save`，可以用来保存依赖项信息 npm [npm网站]: npmjs.com 命令行工具 npm install --global npm//更新命令 常用命令 npm init -y//快速生成package.json文件 npm install npm install 包名//下载指定包 npm install --save 包名//下载指定包并保存到package.json的dependencies中 npm uninstall 包名 npm help//查看使用帮助 npm 命令 --help//查看指定命令的使用帮助 如何解决npm被墙的问题 安装淘宝的cnpm： npm install --global cnpm//--global表示安装到全局，不能省略。以后就能用cnpm代替npm了 如果不想安装cnpm但是又想用淘宝的服务器下载，可以通过: npm config set registry https://registry.npm.taobao.org//默认使用淘宝服务器下载 Express一种Web开发框架 npm install express --save//安装express 拿到框架的第一步当然是Hello World！ var express=require(&#39;express&#39;) var app=express()//相当于以前的server对象 app.listen(3000,function(){ console.log(&#39;服务器，琦动&#39;) }) app.get(&#39;/&#39;,function(req,res){//以get方法请求&#39;/&#39;，并执行对应的处理函数 res.send(&#39;Hello World!&#39;) }) 静态服务（静态 资源获取）// 开放静态资源 // 1.当以/public/开头的时候，去./public/目录中找对应资源 // 访问：http://127.0.0.1:3000/public/login.html app.use(&#39;/public/&#39;,express.static(&#39;./public/&#39;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问 // 访问：http://127.0.0.1:3000/login.html // app.use(express.static(&#39;./public/&#39;)); // 3.访问：http://127.0.0.1:3000/a/login.html // a相当于public的别名 // app.use(&#39;/a/&#39;,express.static(&#39;./public/&#39;)); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 // 通过requery方法获取用户输入的数据 // req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） var express = require(&#39;express&#39;) // 引包 var bodyParser = require(&#39;body-parser&#39;) var app = express() // 配置body-parser // 只要加入这个配置，则在req请求对象上会多出来一个属性：body // 也就是说可以直接通过req.body来获取表单post请求数据 // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })) // parse application/json app.use(bodyParser.json()) 使用： app.use(function (req, res) { res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;) res.write(&#39;you posted:\\n&#39;) // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2)) }) 在express中配合和使用art-template安装： npm install --svae art-template npm install --save express-art-template 配置： app.engine(&#39;html&#39;,require(&#39;express-art-template&#39;))//第一个参数表示渲染以art结尾的文件 使用： app.get(&#39;/&#39;,function(req,res){ //express默认会从项目的views目录去寻找index.html res.render(&#39;index.html&#39;,{ title:&#39;hello world&#39; }) }) 如果希望修改视图渲染的目录（原本是views），可： app.set(&#39;views&#39;,目录路径) CRUD(待更…)其他项①修改完代码自动重启以前每次修改完代码都要傻乎乎地去node xxx.js现在有了nodemon这一个第三方命令行工具，就能解决这一问题。 安装方法，懂得都懂 npm install nodemon --global ②封装异步API回调函数：获取异步操作的结果 function fn(callback){ // var callback = funtion(data){ console.log(data); } setTimeout(function(){ var data = &#39;hello&#39;; callback(data); },1000); } // 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取 fn(function(data){ console.log(data); }) ③关于json文件格式の坑json文件格式要求极其严格，比如 致命错误在：id为5的一行末尾的逗号，一定要去掉！！！结尾的一个花括号不能有逗号（就这个错误折磨了我半个小时……） 小项目一个简单的表单提交网站 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: /** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */ var fs = require(&#39;fs&#39;); // Express专门提供了一种更好的方式 // 专门用来提供路由的 var express = require(&#39;express&#39;); // 1 创建一个路由容器 var router = express.Router(); // 2 把路由都挂载到路由容器中 var Students=require(&#39;./student&#39;) router.get(&#39;/students&#39;, function(req, res) { // res.send(&#39;hello world&#39;); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 Students.find(function(err,students){ if (err) { return res.status(500).send(&#39;Server error.&#39;) } res.render(&#39;index.html&#39;,{students:students}) }) }); router.get(&#39;/students/new&#39;,function(req,res){ res.render(&#39;new.html&#39;) }); router.post(&#39;/students/new&#39;,function(req,res){ //获取表单数据 console.log(JSON.stringify(req.body)) //处理数据 //将数据写入json文件 //发送响应 //读取json文件并转换为对象--&gt;在对象中添加数据--&gt;将对象转换为字符串--&gt;将字符串写入json文件 Students.save(req.body,function (err){ if(err){ return res.status(500).send(&#39;Server error.&#39;) } res.redirect(&#39;/&#39;) }) }); router.get(&#39;/students/edit&#39;,function(req,res){ }); router.post(&#39;/students/edit&#39;,function(req,res){ }); router.get(&#39;/students/delete&#39;,function(req,res){ }); // 3 把router导出 module.exports = router; app.js: var router = require(&#39;./router&#39;); // router(app); // 把路由容器挂载到app服务中 // 挂载路由 app.use(router); 数据操作文件模块/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */ var fs = require(&#39;fs&#39;); var dbPath = &#39;./db.json&#39; /** * 获取所有学生列表 * return [] */ exports.find = function (callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } callback(null, JSON.parse(data).students) }) } /** * 获取添加保存学生 */ exports.save = function (student, callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } //将json字符串转换为数组对象 var students = JSON.parse(data).students //将对象保存到数组对象中 if (students.length==0) { student.id =1 } else{ student.id=students[students.length-1].id+1 } students.push(student) //将数组对象转换为json文件（字符串） var newData = JSON.stringify({students: students}) //字符串写入到文件中 fs.writeFile(dbPath, newData, function (err) { if (err) { return callback(err) } callback(null) }) }) } /** * 更新学生 */ exports.update = function () { } /** * 删除学生 */ exports.delete = function () { } 成功插入数据の截图： 点击submit，成功重定向回主页并渲染完成の截图 小结：通过这个小项目的练习，可以体会到当进行异步编程时，要想获取异步函数的数据就要使用回调函数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Preface","slug":"Preface","date":"2021-01-31T16:00:00.000Z","updated":"2021-03-12T09:41:22.812Z","comments":true,"path":"2021/02/01/Preface/","link":"","permalink":"/2021/02/01/Preface/","excerpt":"2021年1月31日半夜","text":"2021年1月31日半夜,躺在床上想着.因为今天下午的一道算法题我死活也写不出来(涉及知识盲区),翻了好多CSDN大佬们的博客终于有了思路.我在想,我是不是也可以搭一个属于自己的博客?就这样我溜到电脑旁,开始在网上寻找搭建博客的教程.相比于教程所演示的步骤以及最后的结果,我的却是漏洞百出. 第不知道第几个の漏洞:) ) 内心OS![] 就这样,我嗯是折腾到了凌晨2点半(2点的那条朋友圈发出来之后,我又发现博客有问题,然后又爬起来改……) And…就这样,2021年2月1日,Franの杂货铺算是“正式”测试营业了.你们可能想问博客都应该写些啥东西,都说了是杂货铺,种类肯定会比较繁多.不过可能还是会以知识技术(计算机)有关. However…以我现在的程度,能学会总结一些学科的知识点就已经很不错了.(我的总结能力有所欠缺,所以我总是一学就懂,一做就错.新知识”复写”(override)旧知识) Finally…我希望自己能坚持下去,不断完善博客的功能(留言板，评论板……),提高自己的总结能力,另外能加强自己语言表达能力就更好了(我的表达能力像稀饭一样).为什么我大一的时候没有想到搭博客……(掌嘴中)","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}