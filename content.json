{"meta":{"title":"欢迎来到Franの杂货铺","subtitle":null,"description":"Halo, my friend!!!!!!","author":"Kitholt Frank","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-04-07T13:28:54.776Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-04T05:33:56.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-06T15:32:04.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"我的Valine邮箱验证成功啦，欢迎大家来喷我 胡言乱语，乱说一气 :D 获取中... —— :D 获取中... fetch('https://v1.hitokoto.cn/?c=b') .then(response => response.json()) .then(data => { const hitokoto = document.getElementById('hitokoto_text') const from = document.getElementById('from') hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid hitokoto.innerText = data.hitokoto from.innerText = data.from }) .catch(console.error)","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-04T09:10:00.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"散百块，你懂我意思么？(冠希哥.gif)"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-04T05:22:24.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-04T09:06:10.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"环球音乐集团"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-04T07:39:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Fran的小黑屋 到我房间来......&nbsp; 给你看我新买的夜光手表&nbsp; （ ） bot_ui_ini()","keywords":"关于我？"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"临时抱佛脚之数据库","slug":"临时抱佛脚之数据库","date":"2021-06-13T04:00:00.000Z","updated":"2021-06-13T04:58:42.513Z","comments":true,"path":"2021/06/13/临时抱佛脚之数据库/","link":"","permalink":"/2021/06/13/临时抱佛脚之数据库/","excerpt":"","text":"临时抱佛脚之数据库面向死记硬背的Oracle数据库 因为懒得打开学习通 第一单元：实例 Oracle进程结构中完成更新控制文件与数据文件,使其同步并触发DBWR进程,使其将脏缓存块写入数据文件中的进程是( )。—后台进程CKPT 当Oracle服务器启动时,下列哪种文件不是必须的( )。—归档日志文件 ( )是数据库数据字典的所有者。—sys 在同一个表空间中，可以有多个但是不会存在重复的是（）—文件号 可以在Oracle 11g服务器的安装目录下的( )文件中查看Oracle11g服务器的各种参数的使用情况。—initorcl.ora Oracle数据库的实例由( )组成。—SGA(系统全局区)和后台进程 以下内存区不属于实例的是( )。—PGA 如果服务器进程无法在数据缓冲区中找到空闲块,为添加从数据文件中读出的数据块,则系统会启动如下哪一个进程( )。—DBWR 数据字典表和视图存储在( )。—SYSTEM表空间 Bob试图正常关闭数据库,Oracle显示实例处于空闲状态,他试图启动数据库,Oracle显示数据库已启动,Bob最好使用( )命令关闭数据库。—ABORT Oracle进程结构中完成将重做记录从重做日志高速缓冲区写入重做日志文件的进程是( )。—后台进程LGWR 将修改过的数据块写入数据文件的进程是( )。—DBWR 关闭数据库的各种方式中,最省时又不会出现数据不一致(不一致即需要恢复数据库)的情况的是( )。—immediate 使用哪一条SHUTDOWN语句关闭数据库时,下次打开数据库是需要做恢复操作( )。—SHUTDOWN ABORT 指定( )表空间参与排序操作,可以提高排序效率。—TEMPORARY 最近使用过的SQL语句存储在( )。—共享池 下列哪种表空间可以被设置为脱机状态( )。—用户表空间 ( )不属于数据库物理存储结构。—表空间 Oracle分配磁盘空间的最小单位是( )。—数据块 Oracle 数据库启动时需要经历三个步骤和状态变换,以下顺序正确的是( )。—nomount→mount→open 回退段存储( )。—事务修改的数据原值 段是表空间中一种逻辑存储结构,以下( )不是ORACLE数据库使用的段类型。—代码段. 回退段的作用是( )。—数据库恢复、事务回滚、数据的读一致性 已提交的事务所做的数据改变由( )进程记录。–-DBWR Oracle中标准的数据块大小应该由参数 ( )决定。—DB_BLOCK_SIZE Oracle事务提交即( ) 。—LGWR进程成功写入日志 数据块的哪三个部分合称为块头部?( )—表目录、行目录、标题 数据库启动过程中哪一步读取初始化参数文件?( )—实例启动 ( )是用于保存数据库的所有变化信息的,从而保护数据库的安全。—重做日志文件 ( )是较小的二进制文件,用来描述数据库结构。—控制文件 启动DBWR进程的条件有( )。—当数据缓存的LRU列表的长度达到初始化 DB_ BLOCK _WRITE _BATCH指定值的一半时、当检查点发生时,将启动DBWR进程、若发生超时(大约3秒未被启动)、执行INSERT、UPDATE等操作时 ,没有足够的空闲块 下面属于SGA组成部分的是( )。—数据高速缓冲区、大型池、共享池、Java池 启动LGWR进程的条件包括( )。—每隔3秒,即发生一次超时,将启动LGWR、重做日志缓存被写满三分之一、用户通过COMMIT语句提交当前事务、DBWR进程开始将脏缓存块写入数据文件时先启动LGWR CKTP进程一定会引起更新的文件有( )。—控制文件、联机重做日志文件、数据文件 第二单元：结构管理 在非归档日志方式下,操作的数据库禁用了( )。—归档日志 当复用了控制文件后,其中一个控制文件损坏,理想的解决方法是( )。—用好的控制文件,覆盖坏的控制文件 创建一个数据库需要多少个控制文件?( )— 1 利用哪个参数可以设置撤销空间的管理方式?( )—UNDO_MANAGEMENT Oracle数据文件的管理策略不包含( )。—重做日志文件最好与数据文件存放在同一个磁盘上。 如何修改数据库所允许的重做日志个数( )。—修改控制文件 UNDO 数据的自动管理方式下( )。—使用 UNDO 表空间统一存储还原数据 控制文件中不包含( )。—实例信息 以下哪一个文件记录了在数据库恢复期间使用的检查点信息?( )—控制文件3 启动数据库时,如果一个或多个CONTROL_FILES参数指定的文件不存在或不可用,会出现什么样的结果?( )—Oracle返回警告信息,但不加载数据库 尽管oracle默认每个重做日志组中至少有一个成员,但是oracle建议在生产数据库中重做日志文件应该至少有几个成员?( )—4 增加控制文件的镜像文件,说法正确的是( )。—需要修改初始化参数文件 当创建一个新数据库时,以下哪种方法可以正确地多重映像控制文件?( )—在发CREATE DATABASE语句之前使用参数文件中的CONTROL_FILES初始化参数来说明至少两个控制文件的名字和位置 关于脱机表空间的说法哪一个是正确的?( )—如果将表空间设置为脱机状态,下次启动数据库时,不会对该表空间的数据文件进行可用性检查。 对撤销表空间不能执行哪些操作?( )—CREATE TABLE 在创建数据库时,必需的表空间是( )。—SYSTEM TABLESPACE DBA使用( )命令显示当前归档状态。—ARCHIVE LOG LIST DBA 在执行下列语句时返回了错误,DROP TABLESPACE USRES;可能的原因是下列哪个?( )—该表空间为非空,包含数据对象。 如果UNDO空间有活动事务,那么( )。—可以正常切换,切换后活动事务对应的撤销段保留在旧的 UNDO 表空间。 如果日志文件尺寸过小,最可能引起的问题是?( )—日志经常处于等待 在为已有的数据库增加重做日志文件时,数据库应处于哪种状态?( )—OPEN 当创建控制文件时,数据库必须处于什么状态?( )—未加载 在( )状态下可对重做日志组进行删除。—inactive 哪一个表空间不能切换为脱机状态?( )—系统表空间 假如一个表空间只具有一个大小为 100MB 的数据文件,现需将该数据文件的大小修改为 10MB,哪种方法是正确的?( )—使用带有 RESIZE 子句的 ALTER DATABASE DATAFILE 语句 如果某个数据库拥有两个重做日志组,但是第 2 重做日志组突然损坏(其中所有的成员日志都不可用),这时 DBA 应采取下列哪项操作?( )—删除原有的第 2 重做日志组,然后再使用 ALTER DATABASE ADD LOGFILE GROUP2 语句建立新的第 2 重做日志组。 表空间与数据文件关系属性正确的是( )。—一个数据文件只可属于一个表空间 把多路复用控制文件存储于不同磁盘的最大好处是( )。—防止失败 以下哪个不是撤销段的作用( )。—存储数据库对象 一个实例最多可以建立( )个归档进程。—10 删除表空间数据文件的说明正确的是( )。—只能删除空的数据文件。 在向一个现有的数据库中添加了一个数据文件之后,紧接着要做的操作是什么?( )—*备份控制文件 启动Oracle Database 11g至少需要( )个联机重做日志组。—2 如果某个数据库 LGWR 进程经常会因为检查点未完成而进入等待状态,DBA 应当采取什么措施来解决这个问题?( )—增加新的重做日志组 如果需要将oracle数据库的模式从NOARCHIVE 改为ARCHIVE模式,需要在什么状态进行?( )—mount 用于显示所有表空间描述信息的视图是（ ）—v$tablespaces 表空间管理策略,正确的是( )。—A、 [将表空间的数据文件分散保存到不同的硬盘上,平均分布物理I/O操作。] B、 [将回滚数据与用户数据分离,避免硬盘损坏而导致永久性的数据丢失。] C、 [将数据字典与用户数据分离,避免由于数据字典对象和用户对象保存在一个数据文件中而产生I/O冲突。] D、 [能够将表空间设置为脱机状态或联机状态,以便对数据库的一部分进行备份或恢复。] E、 [为不同的应用创建独立的表空间,避免多个应用之间的相互干扰。] F、 [能够将表空间设置为只读状态,从而将数据库的一部分设置为只读状态。] 关于联机重做日志,以下哪两个说法是正确的?( )—同一组中的所有成员文件都是同样大小、同一组的成员文件应置于不同的磁盘、同一组的成员文件内容完全相同 在以下有关控制文件设置与备份的论述中,哪个是正确的?( )—应该在向一个现有的数据库中添加一个数据文件之后备份控制文件、应该在创建一个表空间之后备份控制文件 第三单元：模式对象 在Oracle中创建用户时,比较适合DEFAULT TABLESPACE的表空间是( )—USERS 关于创建表时,对于表的存储参数设置说法错误的是()—同一个表空间中的表的存储参数不能冲突 关于索引使用的说法,错误的是()—Oracle对索引使用的决定都是最优的 关于模式的描述下列哪一项不正确( )。—一个表可以属于多个模式 下列的约束中,不会自动创建索引的是()—foreign key 什么是模式?( )—数据库对象的逻辑组织结构 在Oracle中,一个用户拥有的所有数据库对象统称为 ( )。—模式 下列( )不是Oracle系统中提供的约束。—控制约束 在Oracle中当一个数据表产生了大量存储碎片时,最好的调整方式是()—表结构重组 关于索引的存储,说法错误的是()—索引的存储参数必须跟表的参数一致 表结构重组时,不会发生变化的是()—段的名称 关于约束的延迟检查,说法错误的是()—可以一次性将某个表中所有的可延迟的约束设置为延迟 分区表中的索引类型，不存在的是（）—本地非分区索引 下列不属于分区表类型的是（）—Time分区 唯一值约束和主键约束的区别是什么?( )—唯一值约束的列可以为空、主码列不可以为空 关于约束禁用与激活,说法错误的是()—禁用主键约束、惟一性约束时,会删除其对应的索引,无法保留。 删除表时,不会删除的内容是()—与该表相关的区 关于B树索引的效率与数据量相关性低的原因,正确的是()—B树索引会优先扩展同层节点,而不是增加层数 关于分区表中各个分区的数据存储，说法正确的是（）—可以忽略分区，直接向表中添加数据 第四单元：安全与备份 关于闪回技术,说法错误的是( )—闪回技术可以保护系统表空间中的表。 DML误操作可以使用( )来恢复。—还原段 创建用户的命令中,( )子句限制用户对象在数据库中占用的空间。—QUOTA 数据库运行在归档模式时,关于RMAN操作的描述正确的是( )。—RMAN需要恢复目录 完全备份时,数据库应该处于( )—mount状态 下面不是常用的对象权限的是( )。—grant 要恢复一个丢失的数据文件,而归档重做日志文件已经损坏,DBA应该执行的命令是( )。—RECOVER DATABASE UNTIL CANCEL; 使用RMAN进行数据库不完全恢复,目标数据库必须处于的状态为( )。—MOUNT 下列关于角色描述,说法有误的是( )—角色可以授予自己,也可以循环授予。 以下哪个权限是对象权限?( )—INDEX Oracle有不同类型的备份,不包括( )。—人工备份 利用下面闪回技术不能直接进行数据恢复的是( )。—闪回事务查询 为了执行一次完整的数据库介质恢复操作,数据库必须处于那种状态?( )—处于Mount状态,但不打开数据库 当数据库系统崩溃以后首要任务是()。—让数据库开启并对外提供服务 数据库运行在非归档模式,数据库的一个表空间不可用,DBA恢复数据库的方法是( )。—利用数据库的一致性备份修复数据文件、控制文件和重做日志文件 修复Recover是利用重做日志文件或数据库的增量备份文件重新建立已经丢失的数据,这是一种( )。—逻辑修复 概要文件中SESSIONS_PER_USER限制了什么?( )—每用户会话数量 若用户要连接数据库,则该用户必须拥有的权限是( )。—create session 哪个参数限制用户在断开前的最大空闲时间?( )—IDLE_TIME 给用户定义缺省角色时,下列哪种情况不行? ( )—当角色有密码时 关于闪回技术的描述正确的是( )。—闪回技术是数据库物理备份与恢复、逻辑备份与恢复的重要补充 使用( )命令,被授予权限的用户可以进一步将这个权限授予其他用户。—WITH ADMIN OPTION 以下权限哪个是系统权限?( )—BACKUP ANY TABLE 概要文件不能限制下列哪个资源的使用?( )—读取数据块时间 数据库处于归档模式,不可进行( )类型的备份。—使用ALTER DATABASE BACKUP TABLESPACE备份联机表空间 以下4种关闭数据库的方式中,只有( )在系统重新启动时需要进行数据库的恢复。—shutdown abort 以下哪种备份方式需要完全关闭数据库( )—非归档日志模式下的数据库备份 在数据库打开状态下进行备份时,下面描述不正确的是( )。—数据库必须处于READ ONLY状态 Oracle数据库利用( )进行资源限制和口令管理。—概要文件 在Oracle数据库中,管理员以管理员身份登录后,进入的模式是( )。—SYS 闪回数据库功能需要满足的条件有( )。—数据库必须处于归档模式、数据库设置了闪回恢复区、数据库必须使用管理员帐号登录、数据库启用了FLASHBACK DATABASE特性 用户属性包括( )。—A、账户状态B、表空间配额C、临时表空间D、默认表空间E、概要文件F、用户身份认证方式 概要文件资源限制类型包括( )。—用户连接数据库的总时间、CPU使用时间、用户连接数据库的空闲时间、逻辑读时间 备份原则与策略正确的有( )。—A、对于重要的表中的数据,可以采用逻辑备份方式进行备份。 B、在归档模式下,当数据库结构发生变化时,如创建或删除表空间、添加数据文件、重做日志文件等,应该备份数据库的控制文件 C、在刚建立数据库时,应该立即进行数据库的完全备份 D、至少保证两个归档重做日志文件的归档目标,不同归档目标应该分散于不同磁盘 E、将所有的数据库备份保存在一个独立磁盘上 F、根据数据库数据变化的频率情况确定数据库备份规律","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"动态规划矩阵连乘","slug":"动态规划之矩阵连乘","date":"2021-05-14T15:00:00.000Z","updated":"2021-05-14T15:08:32.071Z","comments":true,"path":"2021/05/14/动态规划之矩阵连乘/","link":"","permalink":"/2021/05/14/动态规划之矩阵连乘/","excerpt":"","text":"Throw the problem事情是这样的，有这样一群捣鼓矩阵的人，他们模拟数的运算法则，整出了矩阵的运算法则。他们发现矩阵A和矩阵B相乘得到矩阵C要做很多次乘法。两个矩阵相乘，计算这个有手就行。三个矩阵相乘还可以接受，四个的话就有点慌，五个的话就有点吃力，六个、七个…既然人算费力，那就交给鸡算，呸，机算。虽然说不用人算，但是矩阵链的长度一上来，电脑也顶不住啊。这帮人开始思考能不能尽可能用最少的乘法次数来实现矩阵的连乘，他们联想到数的运算法则的乘法结合律,因为相邻的矩阵之间是可以若干个组合的。如果给他们加上括号以此来决定乘法的优先级，岂不美哉？光想没用，那就是试试呗。这一试就试出“问题”了。他们发现通过这种“结合运算”的方式，都能得到最终的结果，但是中间用到的乘法次数多少却是“两极分化”! 举个栗子 ：比如 A1 = 10x100，A2 = 100x5，A3 = 5x50，假如矩阵组合的方式为 ((A1A2)A3) 那么总的相乘次数应为 101005+10550 = 7500，而假如矩阵的组合方式为 (A1(A2A3)) 那么相乘的次数应为 100550+1010050 = 75000，我们可以发现两种不同的组合方式的相乘次数竟然相差这么多。 因此，如何找到最少的相乘次数显得尤为重要，那么该如何解决这个问题呢？ How 2 solve this shit？Recursion对于一个规模比较庞大的问题，我们首先想到的就是嫩不能把问题分解成若干个子问题。对于矩阵链（MatrixChain），我们可以递归一下 图中用红色方框框起来的代表在递归的过程中，会被重复计算的矩阵链，这还只是四个矩阵，那如果是四十个，四百个…重复计算的矩阵链只会越来越多（这谁顶得住啊.jpg），因此我们希望寻找更好的方法来解决它。 Dynamic planning要解决重复计算的问题，我们能想到的是用一张表来保存每次计算出的矩阵连乘积，如果在后续的计算中要用到原先的结果，只需要去表中查找就好了。于是乎，动态规划就起了作用。那么，啥是动态规划？ What is it?先来看它的官方定义：动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。 PS：其实在生活中，我们有时候也会使用动态规划这一思想。比如，公司评选优秀员工（最），直接评选不好安排，但是我们可以“自底向上”地比较筛选，那方法就是：选出每个小组表现优秀的员工，又因为一个部门有很多小组，这样能选出一个部门的优秀员工，最后公司又是由很多部门组成的，最后通过类似“集成”的形式就能选出最优秀的员工了。 Exert it！那么，对于矩阵链连乘积次数的求法，也能用类似的思路（自底向上），因为一个矩阵相乘的需要的连乘积次数为0。 所以我们先算出两个两个矩阵相乘的连乘积，然后把结果分别存入一张记录表里 接着计算三个矩阵链的… 四个的 五个的 ……………. 最后我们需要几个变量 p 数组用于存放每个矩阵的维数（每个矩阵对应的行和列） m 一个二维数组，用于存放计算某一个矩阵链所需的【连乘积】的次数 s 还是一个二维数组，用于存放矩阵链Ai···Aj的断裂点（k的位置） 承接纸上，解释代码三层for循环的r，i，k的取值范围 拿两个矩阵相乘的情况举例，起始矩阵下标i从1开始，而i最后的位置应该为n-2，因为我们当前为两个矩阵相乘，到最后时结尾矩阵下标j位于整个矩阵序列的结尾处，所以此时起始矩阵下标i应该在结尾矩阵的下标j往回减2。结尾坐标的起始位置就是起始坐标的下标加上当前相乘矩阵的数目。举个例子，比如当前为两个矩阵相乘，那么 r = 2，那么起始坐标 i 的开始位置就是 1，结束位置就为 n - r+1，结尾下标为 j = i + n - 1。 然后我们在这个区间内再来求取断点 k ，断点的取值范围应该为[i,j)，然后对区间内的所有情况进行计算，即 m[i][k] + m[k+1][j] + 结果矩阵相乘次数（这里需要注意一下，这里是为了好理解，其实按照我们给定的输入，它的每三个数字代表两个矩阵，即比如 {35，30，25}，对应的矩阵应为 A1 = 35x30，A2 = 30x25。所以完全写成递归式应该为 m[i][k] + m[k+1][j] + p[i]p[k+1]*p[j]），比如当 i = i，r = 2 时，j = 1，k = i = 1 那么这时当前断点开始处的计算结果应为 m[1][1] + m[2][2] + p[0]p[1]p[2]. Code Segment（Less important）public class matrixChain { /*** * * @param p 用于存放每个矩阵的维数（每个矩阵对应的行和列） * @param m 一个二维数组，用于存放计算某一个矩阵链所需的【连乘积】的次数 * @param s 还是一个二维数组，用于存放矩阵链Ai···Aj的断裂点（k的位置） * @return */ public static int solution(int[]p,int[][]m,int[][]s){ int n=p.length-1;//矩阵个数 for(int r=2;r&lt;=n;r++){ for(int i=1;i&lt;=n-r+1;i++){ int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++){ int temp=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(temp&lt;m[i][j]){ m[i][j]=temp; s[i][j]=k; } } } } return m[1][n]; } public static void traceback(int i, int j, int[][] s) { // 输出A[i:j] 的最优计算次序 if (i == j) { // 递归出口 System.out.print(&quot;A&quot;+i); return; } else { System.out.print(&quot;(&quot;); // 递归输出左边 traceback(i, s[i][j], s); // 递归输出右边 traceback(s[i][j] + 1, j, s); System.out.print(&quot;)&quot;); } } public static void main(String[] args) { int[] p = new int[]{5,200, 2, 100, 30, 200}; int[][] m=new int[p.length][p.length]; int[][] s=new int[p.length][p.length]; int result=matrixChain.solution(p,m,s); System.out.println(result); traceback(1, p.length-1, s); } } Result of running the code","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"霍夫曼树の创建、编码、解码","slug":"霍夫曼树の创建、编码、解码","date":"2021-04-14T08:30:00.000Z","updated":"2021-04-14T16:05:24.000Z","comments":true,"path":"2021/04/14/霍夫曼树の创建、编码、解码/","link":"","permalink":"/2021/04/14/霍夫曼树の创建、编码、解码/","excerpt":"","text":"开头霍夫曼树的相关概念就不一一赘述了，直接上代码。放心，必要的地方我会加上我自己都看不懂的注释 Mr.Winterの实验要求： 读取一个文本文件，并统计出每个字符的出现次数。随后将一个字符的出现次数作为字符的权值（霍夫曼树中的叶子节点的权值） 将字符和其权值保存起来（链表？or动态数组？） 利用得到的所有字符，构建霍夫曼树（拿到霍夫曼树的根节点） 对每一个字符进行霍夫曼编码，并得到一张编码表 根据编码表，输入一个编码后能够对其进行解码并返回其所对应的字符 步骤读取文本文件并统计各个字符的出现次数（权值）package readtxt; import java.io.*; import java.util.HashMap; import java.util.Map; public class ReadTxt { /** * 传入txt路径读取txt文件 * * @param txtPath * @return 返回读取到的内容 */ public static HashMap&lt;String, Integer&gt; readTxtAndCount(String txtPath) throws IOException { File file = new File(txtPath); FileInputStream fileInputStream = new FileInputStream(file); InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); StringBuffer sb = new StringBuffer(); String text = null; while ((text = bufferedReader.readLine()) != null) {//按行读取字符串 sb.append(text);//将每一行保存到StringBuffer缓冲里 } String txt = sb.toString();//保存为字符串 char[] TXT = txt.toCharArray();//将字符串保存为字符数组 Map&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;();//创建哈希表（类似键值对），统计字符出现的次数 for (char c : TXT) { String s = String.valueOf(c);//取出一个字符 if (null != m.get(s)) {//若该字符不是第一次出现 int count = m.get(s);//取出之前出现的次数count m.put(s, count + 1);//+1 } else { m.put(s, 1);//若一次也没有出现，则置为1 } } return (HashMap&lt;String, Integer&gt;) m; } public static void main(String[] args) throws IOException { HashMap&lt;String,Integer&gt; m=ReadTxt.readTxtAndCount(&quot;U:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;); } } 值得一提的是，哈希表yyds。它的作用类似Python里面的字典（键值对），字符:出现次数 创建节点类Node保存字符信息package node; public class Node implements Comparable&lt;Node&gt; { //字符 public String sign; //每个叶子节点对应的哈夫曼编码 String code; //叶子节点的权重 public int weight; //非叶子节点的左右孩子 public Node lchild; public Node rchild; Node next;//叶子节点的enxt，用于专门指向root，便于后续的解码操作 public Node(String sign, int weight) { this.sign = sign; this.weight = weight; } public String getCode() { return code; } @Override public int compareTo(Node o) { return this.weight - o.weight; } @Override public String toString() { return &quot;Node{&quot; + &quot;sign=&#39;&quot; + sign + &#39;\\&#39;&#39; + &quot;, weight=&quot; + weight + &#39;}&#39;; } public void CodingByPreOrder(String code, Node root) {//先序遍历哈夫曼树 if (!this.sign.equals(&quot;非叶子节点&quot;) &amp;&amp; !this.sign.equals(&quot;根节点&quot;)) { this.code = code; System.out.println(this.sign + &quot;的哈夫曼编码&quot; + code); } if (this.lchild != null) { this.lchild.CodingByPreOrder(code += &quot;0&quot;, root); } //StringBuilder能够替换原字符串的最后一个字符（仅仅是替换最后一个），不使用String的substring方法是因为这个方法会替换所有与替换字符相同的字符 StringBuilder sb = new StringBuilder(code);//回溯时，需要修改最后一个字符，将其置为空，下一次向右递归code的最后一个字符就会被置为1 //replace(参数1，参数2，参数3)，参数1为要替换的开始位置，参数2为要替换的结束位置，参数3为替换内容, code = sb.replace(code.length() - 1, code.length(), &quot;&quot;).toString(); if (this.rchild != null) { this.rchild.CodingByPreOrder(code + &quot;1&quot;, root); } //将所有叶子节点的next都指向root节点，方便后续的解码操作 if (!this.sign.equals(&quot;非叶子节点&quot;) &amp;&amp; !this.sign.equals(&quot;根节点&quot;)) { this.next = root; } } /*** * * @param root 霍夫曼树根节点 * @param code 输入的一个编码 * @param index code的索引下标 * @return */ public String Decoding(Node root, String code, int index) { Node ROOT=root; StringBuilder s = new StringBuilder(); while (index &lt; code.length()) {//遍历code的每一个字符（也就是那一串01...） if (code.charAt(index) == &#39;0&#39;) { ROOT = ROOT.lchild;//向左子树移动 } if (code.charAt(index) == &#39;1&#39;) { ROOT = ROOT.rchild;//向右子树移动 } if (ROOT.next == root) {//如果到达叶子节点，也就是它的next指向了根节点 s.append(ROOT.sign); ROOT=root;//当解码出一个字符，需要将ROOT重置为root根节点，方便进行下一个字符的解码 } index++;//索引后移 } if(ROOT==root){//编码全部正确 System.out.println(code+ &quot;解码后对应的字符为&quot; + s.toString()); return s.toString(); } else if(!s.toString().equals(&quot;&quot;)&amp;&amp;ROOT.next==null){//部分编码正确的情况 System.out.println(&quot;输入的编码部分有误，仅能解码出部分字符&quot;+s.toString()+&quot;...&quot;); return s.toString(); } else {//编码全部错误 System.out.println(&quot;输入的编码完全错误，无法解码...&quot;); return null; } } } 利用得到的节点类构建霍夫曼树package huffmantree; import node.Node; import java.util.*; public class HuffmanTree { /* public static void main(String[] args) throws IOException { Node root = createHuffmanTree(ReadTxt.readTxtAndCount(&quot;E:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;)); root.sign = &quot;根节点&quot;; preOrder(root); }*/ //构建哈弗曼树 public static Node createHuffmanTree(HashMap&lt;String, Integer&gt; arr) { //int count = 0; List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //将字符出现的次数作为权值value，并以此加入node节点中 for (String key : arr.keySet()) { nodes.add(new Node(key, arr.get(key))); } //System.out.println(nodes);//打印所有节点（验证） Collections.sort(nodes);//将节点排序 System.out.println(&quot;各个字符对应的权重：&quot;); System.out.println(&quot;nodes =&quot; + nodes); while (nodes.size() &gt; 1) { //取出根节点权值最小的兩顆二叉树 //取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); //取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //构建一棵新的二叉树 Node parent = new Node(&quot;非叶子节点&quot;, leftNode.weight + rightNode.weight); parent.lchild = leftNode; parent.rchild = rightNode; //删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //将parent加入到nodes nodes.add(parent); //重新排序 Collections.sort(nodes); //System.out.println(&quot;第&quot; + (++count) + &quot;次处理后&quot; + nodes); } return nodes.get(0); } public static void preOrder(Node root) {//利用先序遍历打印霍夫曼编码表 if (root != null) { root.CodingByPreOrder(&quot;&quot;, root); } else { System.out.println(&quot;空树无法遍历...&quot;); } } public static String deCoding(Node root, String code, int index) {//解码 return root.Decoding(root, code, index); } } PS：另外，编码和解码的核心代码在Node类中 主程序的测试代码import java.io.IOException; import java.util.Scanner; import huffmantree.HuffmanTree; import node.Node; import readtxt.ReadTxt; public class Test { public static void main(String[] args) throws IOException { boolean flag=true; Scanner sc=new Scanner(System.in); int key=0; Node root=new Node(null,0); while(flag){ menu(); while(true) { key = sc.nextInt(); if(key&lt;1||key&gt;3){ System.out.println(&quot;请输入正确的序号...&quot;); menu(); }else{ break; } } switch (key){ case 1: root=HuffmanTree.createHuffmanTree(ReadTxt.readTxtAndCount(&quot;U:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;)); HuffmanTree.preOrder(root); break; case 2: System.out.println(&quot;请输入一个来自编码表的编码...&quot;); String s=sc.next(); HuffmanTree.deCoding(root,s,0); break; case 3: flag=false; break; } } } public static void menu() { System.out.println(&quot;\\n §※§※§※§※§※§ 霍夫曼编码与解码.§※§※§※§※§※§\\t\\n&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 1. 霍夫曼の编码(获得编码表).※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 2. 霍夫曼の解码.※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 3. 退出程序.※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\n\\t请选择：\\t&quot;); } } 结果截图： 结尾 各位爷，代码也看了注释也读了思路应该也理清一点点了，接下来应该做啥就不用我说了吧（可怜巴巴）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于我写了个装载问题的野鸡算法的那档事","slug":"关于我写了个装载问题的野鸡算法的那档事","date":"2021-04-10T13:00:00.000Z","updated":"2021-04-10T13:11:40.277Z","comments":true,"path":"2021/04/10/关于我写了个装载问题的野鸡算法的那档事/","link":"","permalink":"/2021/04/10/关于我写了个装载问题的野鸡算法的那档事/","excerpt":"","text":"由于原来的（书上的）算法我实在是看不懂…所以我想仿照我之前解决全排列的思路（逐个选择法）解决这个问题 import java.util.Arrays; public class Loading { static int[] w={5,2,1,3}; int n=4,c1=10,cw=0,bestw=0; static int[] isVisit=new int[w.length]; /*** * * @param c1 第一艘船的最大载重 * @param w 数组，用于记录每件货物的重量 * @param cw 当前最大载重 * @param bestw 最佳载重 * @param isVisit 整形数组（相当于解空间的其中一个解），若将货物搬上第一艘船，则用1表示，否则置为0，数组一开始初始化值均为0，表示还没货物上船 * @param index 从第几号货物开始，然后按照顺序决定是否将其搬上船 * @return * * 另外这代码的返回值是bestw，如果在某个阶段找到了bestw，则在回溯的时候bestw会被一直保留，在回溯的过程中bestw也有可能被替换 * 唯一的缺陷就是，在回溯的过程找到了最佳bestw无法单独打印出来，截图的效果就是缺陷，最后一种装载方案就是最佳的装载方案 */ public static int loading(int c1,int[] w,int cw,int bestw,int[] isVisit,int index){ for(int i=index;i&lt;w.length;i++) { if (isVisit[i]!=1&amp;&amp;(cw+w[i]&lt;=c1)){//如果当前货物A没上船并且（当前最大载重＋A的重量）＜第一艘船的最大载重 isVisit[i]=1;//A货物上船 cw+=w[i];//改变当前载重 if(cw&gt;bestw){//如果当前载重＞最佳载重，则更新最佳载重 bestw=cw; System.out.println(Arrays.toString(isVisit)); } else{//如果没有则直接返回，结束返回上一级函数 return bestw; } bestw=loading(c1,w,cw,bestw,isVisit,index+1); cw-=w[i]; isVisit[i]=0; } } //System.out.println(Arrays.toString(container)); return bestw; } public static void main(String[] args) { int[] w={5,2,1,3}; int c1=10,cw=0,bestw=0; int[] container=new int[w.length]; int bw= Loading.loading(c1,w,cw,bestw,isVisit,0); System.out.println(&quot;第一艘货船最多能载的货物重量为&quot;+bw); System.out.println(&quot;其中最后一种装载方案是最优的...&quot;); } } 最后的结果截图（也是这段代码最大的问题…虽然结果对了）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"汇编语言学习笔记（注：本篇笔记均摘自一位热心的B站用户---_惜取少年时_）","slug":"汇编语言学习笔记","date":"2021-03-14T06:00:00.000Z","updated":"2021-04-17T02:06:00.000Z","comments":true,"path":"2021/03/14/汇编语言学习笔记/","link":"","permalink":"/2021/03/14/汇编语言学习笔记/","excerpt":"","text":"汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）[TOC] 注：本篇笔记均摘自一位热心的B站用户—惜取少年时 第一章 基础知识【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】 汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。 1.汇编课程的研究重点 如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作 2.汇编语言的主体是汇编指令 3.汇编指令和机器指令的差别在于指令的表示方法上 汇编指令是机器指令便于记忆的书写格式 4.汇编语言时机器指令的助记符 5.汇编语言的组成 1.汇编指令（机器码的助记符） 2.伪指令（由编译器执行） 3.其他符号（由编译器识别，如：+ - * /） 汇编语言的核心是汇编指令，他决定了汇编语言的特性 6.CPU对存储器的读写 CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互 1.地址信息：存储单元的地址 2.控制信息：芯片的选择，读或写命令3.数据信息：读或写的数据 第二章 寄存器（CPU工作原理）CPU=运算器+控制器+【寄存器】，器件之间通过总线相连 8086CPU有14个寄存器，名称分别为： AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW 2.1 通用寄存器 1.8086CPU所有的寄存器都是16位的，可以存放2个字节 2.AX、BX、CX、DX通常用来存放一般性数据 被称为通用寄存器 3.8086上一代CPU中的寄存器都是8位的，为了保证兼容性 这四个寄存器都是可以分为2个独立的8位寄存器使用 AX=AH+AL BX=BH+BL CX=CH+CL DX=DH+DL 4.AX的低8位（0-7）构成AL寄存器 高8位（8-15）构成了AH寄存器 AH和AL寄存器是可以独立使用的8位寄存器 2.2 字在寄存器中的存储 8086一个字16位 2.3 几条汇编指令 1.汇编指令不区分大小写 2.几条汇编指令 mov ax,18 ;AX=18 mov ah,78 ;AH=78 add ax,8 ;AX=AX+8 mov ax,bx ;AX=BX add ax,bx ;AX+=BX 3.用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方 mov ax,2 ;ax=2 add ax,ax ;ax=4 add ax,ax ;ax=8 add ax,ax ;ax=162.4 物理地址 1.CPU访问内存单元时，要给出内存单元的地址。 2.所有的内存单元够成的存储空间是一个一维的线性空间 3.我们将这个唯一的地址称为物理地址2.5 16位结构的CPU 16位结构描述了一个淳朴具有以下几个方面特征： 1.运算器一次最多可以处理16位的数据 2.寄存器的最大宽度为16位 3.寄存器和运算器之间的通路是16位的2.6 8086CPU给出物理地址的方法 1.8086有20位地址总线，可传送20位地址，实际上的寻址能力为1M 2.8086内部为16位结构，它只能传送16位的地址，理论上表现出的寻址能力却只有64K 3.问题：8086CPU如何用内部16位的数据转换成20位的地址？ 1.8086CPU采用一种在内部用两个16位地址合成的方法，来形成20位的物理地址 即：段地址+偏移地址=物理地址 2.地址加法器合成物理地址的方法： 物理地址=段地址×16+偏移地址 3.“地址段×16”即是数据左移4位（二进制位的左移4位，十六进制的左移1位） 在地址加法器中，如何完成“段地址×16”？ 二进制形式的段地址左移4位2.7 “段地址×16+偏移地址=物理地址”的本质含义 1.即可以用两个16位的二进制数来表示一个20位的二进制数 2.8086CPU中内部为16位结构，但地址线却是20位的，使用地址加法器可以把16位地址变成20位地址 具体操作就是：段地址×16+偏移地址2.8 段的概念 1.内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址×16+偏移地址=物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存 2.以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段， 使用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元 3.注意 1.段地址必然是16的倍数，即一个段的起始地址必然是16的倍数 2.偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K 3.CPU可以用不同的段地址和偏移地址形成同一个物理地址2.9 段寄存器 1.段寄存器就是提供段地址的 8086CPU有4个段寄存器： 1.CS（code segment） 2.DS（data segment） 3.SS（stack segment） 4.ES（extra segment） 2.当8086CPU要访问内存时，有这4个段寄存器提供内存单元的段地址2.10 CS和IP 1.CS和IP时候8086CPU中最关键的寄存器 他们指示了CPU当前读取指令的地址。 2.CS和IP的含义 CS：代码段寄存器 IP：指令指针寄存器【专用寄存器】 3.8086CPU工作过程的简要描述 1.从CS:IP指向内存单元，读取指令，读取的指令进入指令缓冲器 2.IP=IP+所读取指令的长度，从而指向下一条指令 3.执行指令，转到步骤1，重复这个过程 4.开机时的CS和IP 1.在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为 CS=FFFFH，IP=0000H 2.即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行 3.FFFF0H单元中的指令是8086PC机开机后执行的第一条指令 5.修改CS、IP的指令 1.在CPU中，程序员能够【用指令读写】的部件只有【寄存器】， 程序员可以通过改变寄存器中的内容实现对CPU的控制 2.CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容 控制CPU执行目标指令 3.如何修改CS和IP？ 1.通过mov改变AX等，但是不能通过mov改变CS和IP 2.【jmp 段地址:偏移地址】 可以用来同时修改CS和IP 指令中的段地址修改CS 偏移地址修改IP 3.【jmp 某一合法的寄存器】 仅修改IP的内容 比如：jmp ax 或者 jmp bx（类似于mov IP ax） 4.jmp是只具有一个操作对象的指令2.11 代码段 1.可以将长度为N（N&lt;=64KB）的一组代码，存放在一组地址连续、其实地址为16的倍数的内存单元中 这段内存是用来存放代码的，从而定义了一个代码段 2.CPU中只认被CS:IP指向的内存单元中的内容为指令 【实验一】查看CPU和内存，用机器指令和汇编指令编程 1.R命令：查看、改变CPU寄存器的内容 r后面加寄存器的名称可以改变CPU寄存器的内容 2.D命令：查看内存中的内容 3.E命令：改写内存中的内容 4.U命令：将内存汇总的机器指令翻译成汇编指令 5.T命令：执行一条机器指令 6.A命令：以汇编指令的格式在内存中写入一条机器指令 1.debug中输入的默认是16位数 2.空格数量任意 7.按Q可以退出 第三章 寄存器（内存访问）3.1 内存中字的存储 1.任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个存储单元 也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元2.注意：在内存的表示中，从高到低，是从0号单元开始，然后逐渐变大， 即在书写时，低位写在高的地方，高位写在低的地方， 如上图所示：4E20H即是0号字节存储20，1号字节存储4E3.2 DS和[address] 1.8086中有一个DS寄存器，通常用来存放要访问的数据的段地址 2.例如：我们要读取10000H单元的内容可以用如下程序段进行： mov bx,1000H mov ds,bx mov al,[0] 上面的三条指令将10000H（1000:0）中的数据读到al中 1.复习：已知mov指令可以完成的两种传送功能 1.将数据直接送入寄存器 2.将一个寄存器中的内容送入另一个寄存器中 2.除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器 mov指令格式：mov 寄存器名,内存单元地址 […]表示一个内存单元，“[…]”中的…表示内存单元的【偏移地址】 执行指令时，8086CPU自动取DS中的数据为内存单元的【段地址】 3.如何把1000H放入DS中？ 要通过通用寄存器把段地址传入到DS中 8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器 即：mov ds,1000H 是非法的 数据-&gt;通用寄存器-&gt;段寄存器 3.写几条指令，将AL中的数据送入内存单元10000H？ mov bx,1000H mov ds,bx mov [0],al ;al中的字节型数据送入到1000H:0中3.3 字的传送 1.8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据 即：一次可以传送一个字 2.比如 mov bx,1000H mov ds,bx mov ax,[0] ;1000H:0处的字型数据送入ax中 mov [0],cx ;cx中的16位数据送入到1000H:0中3.4 mov、add、sub指令 1.复习：已学mov指令的几个形式 1.mov 寄存器,数据 ;立即寻址 2.mov 寄存器,寄存器 ;寄存器寻址 3.mov 寄存器,内存单元 ;直接寻址 4.mov 内存单元,寄存器 ;寄存器寻址？ 5.mov 段寄存器,寄存器 ;寄存器寻址 6.mov 寄存器,段寄存器 ;寄存器寻址 2.add、sub同mov一样，都有两个操作对象 1.add的用法 1.add 寄存器,数据 ;立即寻址 2.add 寄存器,寄存器 ;寄存器寻址 3.add 寄存器,内存单元 ;直接寻址 4.add 内存单元,寄存器 ; 2.sub的用法 【不带借位的减法】 指令格式 sub op1,op2 ;意为：op1=op1-op2 1.sub 寄存器,数据 ;立即寻址 2.sub 寄存器,寄存器 ;寄存器寻址 3.sub 寄存器,内存单元 ;直接寻址 4.sub 内存单元,寄存器 ;3.5 数据段 如何访问数据段中的数据？ 将一段内存当作数据段，是我们在编程时的一种安排 具体操作：用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元3.6 栈 1.8086CPU提供相关的指令来以栈的方式访问内存空间 这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用 2.8086CPU提供入栈和出栈指令：（最基本的） push（入栈） pop（出栈） 1.push ax：将寄存器ax中的数据送入栈中 2.pop ax：从栈顶取出数据送入ax 3.8086CPU的入栈和出栈操作都是以【字（16位）】为单位进行的 4.pop和push可以在寄存器和内存之间传送数据 3.CPU如何知道一段内存空间被当做栈使用？ 1.8086CPU中，有两个寄存器 1.段寄存器SS：存放栈顶的段地址 2.寄存器SP：存放栈顶的偏移地址【专用寄存器】 2.任意时刻SS:SP指向栈顶元素，当栈为空的时候，也就不存在栈顶元素 ss:sp也就指向栈最高地址单元的下一个单元 4.执行push和pop的时候，如何知道哪个单元是栈顶单元？ 1.执行push ax时 1.sp=sp-2 2.将ax中的内容送入到ss:sp指向的内存单元 ss:sp此时指向新栈顶 2.执行pop ax时 1.将ss:sp指向的内存单元的内容送入到ax中 注意：这里取出的内容在内存中还是存在的，并没有被重置 下一轮push会覆盖 2.sp=sp+2 5.如果栈是空的，sp指向哪里？ sp指向最高地址单元的下一个单元3.7 栈顶超界的问题 ss、sp只记录了栈顶的地址，依靠ss、sp可以保证在入栈和出栈时找到栈顶 可以，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？ 1.8086CPU不保证栈的操作不会越界 2.当栈空的时候，再执行pop出栈 或者 当栈满的时候再使用push入栈 都会发生栈顶超界问题，会操作到栈以外的数据， 这些数据可能是其他用途的数据或者代码 栈顶超界是危险的！！！ 3.8086CPU没有记录栈顶上下限的寄存器3.8 栈段 1.将一段内存当做栈段，仅仅是我们在编程时的一种安排， 2.ss:sp指向我们定义的栈段的栈顶； 3.当栈空时，sp指向最高地址的下一个单元 4.思考：一个栈段最大可以设为多少？ 64KB 5.设栈顶的变化范围是0-FFFFH，从栈空时sp=0（最高地址单元FFFFH的下一个单元0000H） 一直压栈，直到栈满，sp=0； 如果再次压栈，栈顶将环绕，覆盖原来栈中的内容 6.一段内存，既可以是代码的存储空间，又可以是数据的存储空间，还可以是栈空间 也可以是什么都属实。 关键在于CPU中寄存器的设置，即：cs、ip、ss、sp、ds的设置 **可以通过mov直接给sp赋值【立即数寻址】，但是不能通过mov给cs、ip、ss、ds赋值 给cs和ip赋值需要使用jum指令 给ss和ds赋值需要使用mov ss或ds,寄存器 ;【寄存器寻址】 【实验二】 第四章 第一个汇编程序4.1 一个源程序从写出到执行的过程 1.一个汇编语言程序从写出到最终执行的简要过程 编写-&gt;编译连接-&gt;执行 2.对源程序进行编译连接 1.使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】 2.再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】。 3.可执行文件包含两部分内容 1.程序（从源程序的汇编指令翻译过来的机器码）和数据（源程序中定义的数据） 2.相关的描述信息（比如：程序有多大、要占多少内存空间等） 4.执行可执行文件中的程序 1.在操作系统（如：MSDOS）中，执行可执行文件中的程序 2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存 并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序 4.2 源程序的主要结构 源程序由 汇编指令+伪指令+宏指令 组成 伪指令：编译器处理 汇编指令：编译为机器码 1.伪指令 1.没有对应的机器码的指令，不能由CPU直接执行 2.伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作 2.segment和ends【定义一个段】 1.segment和ends是一对成对使用的伪指令 2.编写汇编程序【必须】使用到的指令 3.segment和ends的功能是定义一个段 segment：说明一个段开始 ends：说明一个段结束 4.一个段必须有一个名称来标识，使用格式为 段名 segment 段名 ends 5.一个汇编程序由多个段组成 这些段用来存放【代码、数据、或当作栈空间】来使用 一个有意义的汇编程序至少要有一个段，这个段用来存放代码。 3.end【真正的没了】 1.end是一个汇编程序的结束标记 2.编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译 3.如果程序写完了，要在结尾处加上伪指令end 否则，编译器无法知道程序在何处结束 4.【切记】不要把end和ends搞混了 end：汇编程序的结束标记 ends：与segment成对出现 4.assume【寄存器和段的关联假设】 1.它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联 2.通过assume说明这种关联，在需要的情况下， 编译程序可以将段寄存器和某一具体的段相联系 5.程序和源程序 1.我们将源程序文件中的所有内容称为【源程序】 2.将源程序中最终由计算机执行处理的指令或数据称为【程序】 3.程序最先以汇编指令的形式，存储在源程序中 然后经过编译、连接后转变为机器码，存储在可执行文件中 6.标号，标号与段名称有所区别 1.一个标号指代了一个地址，即是段名称。 2.段名称 放在segment的前面，作为一个段的名称 这个段的名称最终将被汇编、连接程序处理为一个段的段地址 7.DOS中的程序运行 1.DOS是一个单任务操作系统 2.一个程序结束后，将CPU的控制权交还给是他得以运行的程序 我们称这个过程为：程序返回 8.程序返回 mov ax，4c00H int 21H ;【中断机制】是DOS最伟大的机制,Windows系统上是【消息机制】 这两条指令所实现的功能就是程序返回 9.几个和结束相关的内容 1.段结束：伪指令 通知编译器一个段的结束【ends】 2.程序结束：伪指令 通知编译器程序的结束【end】 3.程序返回：汇编指令 mov ax,4c00H int 21H 10.语法错误和逻辑错误 1.语法错误 1.程序在编译时被编译器发现的错误 2.容易发现 2.逻辑错误 1.在编写时不会表现出来的错误、在运行时会发生的错误 2.不容易发现 4.3 以简化的方式进行汇编和连接 汇编使用的程序：masm.exe 连接使用的程序：link.exe 简化方式进行汇编和连接的程序：ml.exe 4.4 汇编和连接的作用 连接的作用 1.当源程序很大时，可以将他们分成多个源程序文件夹编译 每个源程序编译成为目标文件后，再用连接程序将它们连接在一起， 生成一个可执行文件 2.程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起 生成一个可执行文件 3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接 用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。 所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用 连接程序对目标文件进行处理，生成可执行文件 4.5 可执行文件中的程序装入内存并运行的原理 1.在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2 将P1从可执行文件中加载入内存，将CPU的控制权交给P1，P1才能得以运行 2.当P1运行完毕后，应该将CPU的控制权交还给使他得以运行的程序 3.操作系统的外壳 1.操作系统是由多个功能模块组成的庞大、复杂的软件系统 任何通用的操作系统，都需要提供一个称为shell（外壳）的程序， 用户（操作人员）使用这个程序来操作计算机系统工作 2.DOS中有一个程序command.com，这个程序在DOS中称为命令解释器 也就是DOS系统的shell 4.执行可执行文件1.exe时， （1）什么程序将CPU的控制权交给了1.exe？ （2）将程序1.exe加载入内存后，如何使程序得以运行？ （3）1.exe程序运行结束后，返回到了哪里？ 1.在DOS中直接执行1.exe时，是正在运行的cmd.exe将1.exe中的程序加载入内存 2.cmd.exe设置CPU的CS:IP指向程序的第一条指令（即，程序的入口） 从而使程序得以运行 3.程序运行结束后，返回cmd.exe中，CPU继续运行cmd.exe 【实验三】 第五章 【bx】和loop指令5.1 [bx] 1.和[0]类似，[0]表示内存单元，它的偏移地址是0； 2.[bx]同样也表示一个内存单元，它的段地址在DS中 它的偏移地址在bx中，至于是取字还是取字节， 要看他放入的寄存器是8位还是16位 3.补充：inc指令：相当于C语言中的++运算符5.2 Loop指令 这个指令和循环有关 1.指令格式：loop 标号 CPU执行loop指令的时候，要进行两步操作 1.(cx)=(cx)-1; 2.判断cx中的值，若不为零，则转至标号处执行程序 若为零，则向下执行。 2.通常，loop指令实现循环，cx中存放循环的次数 3.标号 在汇编语言中，标号代表了一个地址，标号标识了一个地址 4.使用cx和loop指令相配合实现循环功能的三个要点 1.在cx中存放循环次数 2.loop指令中的标号所标识地址要在前面 3.要循环执行的程序段，要写在标号和loop指令的中间 5.用cx和loop指令相配合实现循环功能的程序框架 mov cx,循环次数 S:循环执行的程序段 loop s5.3 在Debug中跟踪供loop指令实现的循环程序 **注意：在汇编程序中，数据不能以字母开头，如果要输入像FFFFH这样的数 则要在前面添加一个0 在debug程序中引入G命令和P命令 1.G命令 G命令如果后面不带参数，则一直执行程序，直到程序结束 G命令后面如果带参数，则执行到ip为那个参数地址停止 2.P命令 T命令相当于单步进入（step into） P命令相当于单步通过（step over）5.4 Debug和汇编编译器Masm对指令的不同处理 1.在debug中，可以直接用指令 mov ax,[0] 将偏移地址为0号单元的内容赋值给ax 2.但通过masm编译器，mov ax,[0] 会被编译成 mov ax,0 1.要写成这样才能实现：mov ax,ds:[0] 2.也可以写成这样： mov bx,0 mov ax,[bx] ;或者mov ax,ds:[bx]5.5 loop和[bx]的联合应用 1.计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中 1.注意两个问题 1.12个8位数据加载一起，最后的结果可能会超出8位（越界），故要用16位寄存器存放结果 2.将一个8位的数据加入到16位寄存器中，类型不匹配，8位的数据不能与16位相加 2.【解决办法】 把原来8位的数据，先通过通用寄存器ax，将它们转化成16位的 3.代码如下 assume cs:codesg codesg segment start: ;指定数据段 mov ax,0ffffh mov ds,ax ;初始化 mov ax,0 mov dx,0 mov bx,0 ;指定循环次数，12次 mov cx,0ch circ: ;把8位数据存入al中,即ax中存放的是[bx]转化之后的16位数据，前8位都是0 mov al,[bx] ;进行累加 add dx,ax ;bx自增，变化内存的偏移地址 inc bx loop circ ;程序返回 mov ax,4c00h int 21H codesg ends end start 5.6 段前缀 1.指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中 2.我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器 比如 mov ax,ds:[0] mov ax,ds:[bx] 这里的ds就叫做【段前缀】 5.7 一段安全的空间 1.8086模式中，随意向一段内存空间写入内容是很危险的 因为这段空间中可能存放着【重要的系统数据或代码】 2.在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用【0:200~0:2FF】 的256个字节的空间。所以，我们使用这段空间是安全的 第六章 包含多个段的程序6.1在代码段中使用数据 1.dw的含义【定义字型数据：define word，16字节】 在数据段中使用dw定义数据，则数据在数据段中 在代码段中使用dw定义数据，则数据在代码段中 堆栈段也是一样 2.在程序的第一条指令前加一个标号start，并且这个标号在伪指令end后面出现 可以通知编译器程序在什么地方结束，并且也可以通知编译器程序的入口在哪里6.2在代码段中使用栈 **补充：如果题目要求【逆序】存放，就要想到栈（FILO） 使用dw向系统申请一段空间，然后把这个空间当做栈6.3将数据、代码、栈放入不同的段 1.在前面的6.1和6.2中，我们在程序中用到了数据和栈，我们在编程的时候要注意 何处是数据，何处是栈、何处是代码 2.这样做显然有两个问题 1.把他们放在一个段中是程序显得混乱 2.前面程序中处理的数据很少，用到的栈空间也小，放在一个段里面没有问题 但数据、栈、代码需要的空间超过64KB，就不能放在一个段中 (8086中一个段的容量不能大于64KB) 3.我们可以和定义代码段一样的方法来定义多个段 然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间 4.将数据、代码、栈放入不同的段 1.我们可以在源程序中为这三个段起具有含义的名称 用来存放数据的段，我们将其命名为“data” 用来存放代码的段，我们将其命名为“code” 用来作栈空间的段，我们将其命名为“stack” 但是CPU看得懂吗？【不能】 2.我们在源程序中用伪指令 “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连 这样做了之后，CPU是都就会将cs指向code，ds指向data，ss指向stack 从而按照我们的意图来处理这些段呢？【不能】 伪指令CPU看不懂，伪指令是给编译器看的 3.若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令 才是CPU要执行的内容 需在在code段中给DS，CS、SS设置相应的值才能让CPU识别出数据段、代码段、堆栈段 其中汇编程序开始的地方（即代码段开始的地方）由end后面的标号所指向的地方给出 5.assume指令不可省略，至于为什么，需要以后多多体会 【实验五】 1.如果段中的数据占N个字节，则程序加载后，这段实际占有的空间为：N%16==0?N:16×(N/16+1); 因为一个段最小占用16字节，即有16个字节只有这个段可以访问到 2.在编辑源程序的时候，如果调换各个段的编写位置，最后CS、DS、SS的值会发生变化 3.如果去掉start，编译器会从上到下执行，如果第一个段是代码段，则可以正常运行 若第一个段不是代码段，则不会正常运行 4.代码示例1 assume cs:code,ds:data,ss:stack ;数据段 data segment ;8个数据 dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends ;栈段 stack segment ;8个数据 dw 0,0,0,0,0,0,0,0 stack ends ;代码段 code segment start: ;栈空间初始化 mov ax,stack mov ss,ax mov sp,16 ;数据段初始化 mov ax,data mov ds,ax push ds:[0];一个栈单元是一个字 push ds:[2] ;存放数据不会改变 pop ds:[2] pop ds:[0] ;程序返回 mov ax,4c00h int 21h code ends end 5.将a，b数据段中的内容分别相加，结果放入data数据段中 assume cs:code ;数据段 a segment db 1,2,3,4,5,6,7,8 a ends ;数据段 b segment db 1,2,3,4,5,6,7,8 b ends ;数据段 data segment db 0,0,0,0,0,0,0,0 data ends ;代码段 code segment start: mov bx,0 mov ax,0 mov dx,a mov ss,dx mov dx,b mov es,dx mov dx,data mov ds,dx mov cx,8 circ: add al,ss:[bx] add al,es:[bx] mov [bx],al inc bx mov al,0 loop circ ;程序返回 mov ax,4c00h int 21h code ends end start 6.将a数据段中的前8个字型数据逆序存储到b段中 assume cs:code a segment dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh a ends b segment dw 0,0,0,0,0,0,0,0 b ends code segment start: mov ax,0 mov ax,a mov ss,ax mov sp,0 mov ax,0 mov ax,b mov ds,ax mov bx,0 mov cx,8 circ: pop [bx] add bx,2 loop circ mov ax,4c00h int 21h code ends end start 第七章 更灵活地定位内存地址本章主要讲解一些更灵活的定位内存地址的方法和相关的编程方法 7.1 and和or指令 1.and指令：逻辑与指令，按位进行与运算 1.如:mov al,01100011B and al,00111011B 执行后： al=00100011B 2.通过and指令可将操作对象的相应位设为0，其他位保持不变 例如al的第6位设为0：and al,10111111B 例如al的第7位设为0：and al,01111111B 例如al的第0位设为0：and al,11111110B 2.or指令，逻辑或运算，按位进行或运算 1.如:mov al,01100011B or al,00111011B 执行后： al=01111011B 2.通过该指令可将操作对象的相应位设为1，其他位不变 or al,01000000B;将al的第6位设为1 or al,10000000B;将al的第7位设为1 or al,00000001B;将al的第0位设为17.2 关于ASCII码 一种编码方案，在计算机系统中通常被采用，8位 7.3 以字符形式给出的数据 1.在汇编程序中，可以使用’×××’的方式指明数据是以字符的形式给出的 2.编译器会将它们转化为相应的ASCII码 3.例如 1.db ‘unIX’ ;相当于：db 75H,6EH,49H,58H ‘u’、’n’、’I’、’X’的ASCII码分别为75H,6EH,49H,58H 2.mov al,’a’ ;相当于：mov al，61H ‘a’的ASCII码为61H 4.ASCII码中，大写字母和小写字母之间的规律 小写字母=大写字母+32 小写字母=大写字母+20H 大写字母从41H开始排，小写字母从61H开始排大写|二进制|小写|二进制-|-|-|-A|01000001|a|01100001B|01000010|b|01100010C|01000011|c|01100011D|01000100|d|01100100 7.4 大小写转换的问题 1.方案一： 1.识别出是该字节是表示一个的大写英文字符，还是小写的 用于条件判断的汇编程序，目前还没有学到 2.根据+20H 或者 -20H进行大小写转换 2.方案二： 1.若全部转化为大写，则将第5位置0 and al,11011111B 2.若全部转化为小写，则将第5位置1 or al,00100000B7.5 [bx+常数] mov ax,[bx+200]的含义： 1.将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个入一个子单元 该字单元的偏移地址为bx中的数值加上200，段地址在ds中 2.也可以写成 1.mov ax,200[bx] 2.mov ax,[bx].2007.6 用[bx+idata]的方式进行数组的处理 在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写 1.我们观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5 2.我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放 3.我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符 4.注意这个数组的定位方式，对比C语言 C语言的数组定位方式：a[i]，b[i]， a、b是地址常量 汇编语言的数组定位方式：0[bx],5[bx] 所以：[bx+常数]的方式为高级语言实现数组提供了便利的机制 assume cs:codesg,ds:datasg datasg segment db &#39;BaSiC&#39; db &#39;MinIX&#39; datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 mov cx,5 ;做5次循环 circ: mov al,[bx] and al,11011111b mov [bx],al mov al,[bx+5];等价于mov al,5[bx];等价于mov al,[bx].5 or al,00100000b mov 5[bx],al inc bx loop circ mov ax,4c00h int 21h codesg ends end start 7.7 SI和DI 已经学过的10个寄存器：AX、BX、CX、DX、DS、CS、SS、ES、IP、SP 1.SI和DI是8086CPU中和bx功能相近的寄存器 bx不够用，所以引进了SI和DI 2.SI和DI（16位）不能够分成两个8位寄存器来使用【和bx的区别】 3.下面三组指令实现了相同的功能 1.mov bx,0 mov ax,[bx] 2.mov si,0 mov ax,[si] 3.mov di,0 mov ax,[di] 4.下面三组指令也实现了相同的功能 1.mov bx,0 mov ax,[bx+123] 2.mov si,0 mov ax,[si+123] 3.mov di,0 mov ax,[di+123] 5.用寄存器SI和DI实现将字符串&#39;welcome to masm!&#39;复制到它后面的数据区中 通常用ds:si指向要复制的源始字符串 通常用ds:di指向要复制的目的空间 **注意si、di是16位寄存器，循环中自增时，应该+2 assume cs:code,ds:data data segment db &#39;welcome to masm!&#39; db &#39;................&#39; data ends code segment start: mov ax,data mov ds,ax mov si,0 mov di,16 mov cx,8 circ: mov ax,0[si] mov [di],ax inc di inc di inc si inc si loop circ mov ax,4c00h int 21h code ends end start 7.8 [bx+si]和[bx+di] 1.[bx+si]和[bx+di]的含义类似，我们以[bx+si]为例进行讲解 [bx+si]表示一个内存单元，它的偏移地址为bx中的数值加上si中的数值 它的偏移地址在ds中 2.[bx+si]也可以写成[bx][si]7.9 [bx+si+常数]和[bx+di+常数] 1.以[bx+Si+常数]为例讲解 [bx+si+常量]表示一个内存单元，偏移地址为bx的值+si的值+常数 2.指令mov ax,[bx+si+常数]也可以写成如下形式 1.mov ax,200[bx+si] 2.mov ax,200[bx][si] 3.mov ax,[bx].200[si]7.10 不同的寻址方式的灵活应用 1.总结几种定位内存的方法 1.ds:[常数] 【直接寻址】 用一个常量来表示地址，可用于直接定位一个内存单元 2.[bx] 【寄存器间接寻址】 用一个寄存器的值来表示内存地址，可以间接定位一个内存单元 3.[bx+常数] 【？？】 用一节寄存器的值和常量表示内存地址，可在一个起始地址的基础上用变量间接定位一个内存单元 4.[bx+si] 5.[bx+si+常数] 2.编程，给定数据段data，将data段中每个单词的头一个字母改写成大写字母 assume cs:code,ds:data data segment db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends code segment start: mov ax,data mov ds,ax mov bx,0 mov cx,6 circ: mov al,[bx+3] and al,11011111b mov [bx+3],al add bx,16 loop circ mov ax,4c00h int 21h code ends end start 3.编程，给定数据段data，将data段中的每个单词改为大写字母 1.【loop指令cx-1之后，在判断是否为0】 2.双重循环用汇编怎么实现？ 应该在每次开始内循环的时候，将外层循环的cx的值保存起来， 在执行外层循环的loop指令前，在恢复外层循环的cx数值。 **可以用寄存器来临时保存，也可以用栈空间（内存）保存【没有多余的寄存器】 更好的方法是使用：栈 1.使用寄存器实现 assume cs:code,ds:data data segment db 4,4,6,4,7,4;单词的字母数 db &#39; &#39;;补齐 db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends code segment start: mov ax,data mov ds,ax mov bx,16 mov si,0 mov di,0 mov cx,6;外层循环6次 outer:;外层循环 mov dx,cx;用寄存器将外层循环的次数保存，C语言中是用栈来保存的 mov cx,0 mov cl,[di];内循环的次数 inner:;内层循环 mov al,[bx][si+3] and al,11011111b mov [bx][si+3],al inc si loop inner add bx,16 mov si,0 inc di mov cx,dx;恢复外层循环的次数 loop outer mov ax,4c00h int 21h code ends end start 2.使用栈实现【更好的方法】 assume cs:code,ds:data,ss:stack data segment db 4,4,6,4,7,4;单词的字母数 db &#39; &#39;;补齐 db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends stack segment dw 1,2,3,4,5,6,7,8 stack ends code segment start: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,16 mov bx,16 mov si,0 mov cx,6;外层循环6次 outer:;外层循环 push cx;将外层循环的次数保存 mov cx,0 mov cl,[di];内循环的次数 inner:;内层循环 mov al,[bx][si+3] and al,11011111b mov [bx][si+3],al inc si loop inner add bx,16 mov si,0 inc di pop cx;恢复外层循环的次数 loop outer mov ax,4c00h int 21h code ends end start 第八章 数据处理的两个基本问题本章对前面的所有内容是具有总结性的 计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中： 1.处理的数据在什么地方？ 2.要处理的数据有多长？ 这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作 8.1 bx、si、di、bp 1.在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中，用来进行内存单元的寻址 2.在“[…]”中，这四个寄存器（bx、bp、si、di）可以单个出现， 或者只能以以下4种组合出现 1.bx和si 2.bx和di 3.bp和si 4.bp和di 3.错误的用法 mov ax,[bx+bp] mov ax,[si+di] 4.只要在[…]中使用寄存器bp，则指令中没有显性给出段地址，那么 段地址就默认在ss中，比如： mov ax,[bp] ax的值为栈空间中，偏移地址为bp的内存单元 mov ax,[bp+常数] mov ax,[bp+si] mov ax,[bp+si+常数]8.2 机器指令处理的数据所在的位置 1.绝大部分机器指令进行数据处理的指令大致可分为3大类 读取、写入、运算 2.在机器指令这一层，并不关心数据的值是多少，而关心指令执行前一刻 它将要处理的数据所在的位置 3.指令在执行前，所要处理的数据可以在三个地方 CPU内部（寄存器）、内存、端口8.3 汇编语言中数据位置的表达 汇编语言中用三个概念来表达数据的位置 1.立即数 2.寄存器 3.段地址（SA）和偏移地址（EA） 1.存放段地址的寄存器可以是默认的， 既可以是默认在ds中，也可以是在ss中（使用bp寄存器） 2.存放段地址的寄存器也可以显性的给出 mov ax,ds:[bp] mov ax,es:[bx] mov ax,ss:[bx+si] mov ax,cs:[bx+si+8]8.4 寻址方式 8.5 指令要处理的数据有多长？ 1.8086CPU的指令，可以处理两种尺寸的数据，byte和word 所以在机器指令中要指明，指令进行的是字操作还是字节操作 2.8086CPU确定数据长度的几种方法 1.通过寄存器名指明要处理的数据的尺寸 mov al,1 ;指明数据是字节型的 mov bx,ds:[0] ;指明数据是字型的 2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度 X在汇编指令中可以为word或byte 1.下面的指令中，用byte ptr指明了指令访问的内存单元是字节型单元 mov byte ptr ds:[0],1 inc byte ptr [bx] inc byte ptr ds:[0] add byte ptr [bx],2 2.下面的指令中，用word ptr指明了指令访问的内存单元是字型单元 mov word ptr ds:[0],1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 3.其他方法 有些指令默认了访问的内存单元类型 pop、push指令，一定是字型数据 3.在没有寄存器参与的内存单元访问指令中，用word ptr或者byte ptr 显性地指明所要访问的内存单元的长度，是非常有必须要的 否则，CPU无法得知所要访问的单元是字单元，还是字节单元8.6 寻址方式的综合应用8.7 div指令 1.div是除法指令（division），使用div作除法的时候，要求 1.除数：8位或16位，在寄存器或内存单元中 2.被除数：（默认）放在AX或DX和AX中 3.除数与被除数的相互关系 除数 被除数 8位 16位（AX） 16位 32位（DX+AX） 4.结果存放的位置 运算 8位 16位 商 AL AX 余数 AH DX 2.div指令格式 1.div 寄存器 2.div 内存单元 除数是寄存器或内存单元的内容 3.div指令示例 1.div byte ptr ds:[0] ;被除数是16位，除数是ds:[0]的内容(8位) 含义：(al)=(ax)/((ds)16+0)的商 (ah)=(ax)/((ds)16+0)的余数 2.div word ptr es:[0] ;被除数是32位，除数是es:[0]的内容(16位) 含义：(ax)=[(dx)10000H+(ax)]/((es)16+0)的商 (dx)=[(dx)10000H+(ax)]/((es)16+0)的余数 4.利用除法指令计算100001/100 1.被除数100001大于65535，要使用dx和ax两个寄存器联合存放 即说要进行的16位的除法 2.除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位 除数应为16位，所以要用16位寄存器来存放除法100 3.现将100001表示成十六进制数：186A1H，即dx中存放1H，ax中存放86A1H mov dx,1 mov ax,86A1H mov bx,100 div bx ;默认除数是16位的 8.8 伪指令dd 1.dd是用来定义双字型数据的 2.示例 data segment db 1 ;字节型数据 dw 1 ;字型数据 dd 1 ;双字型数据 data ends 3.已知data段数据，用div计算data中第一个数据除以第二个数据后的结果， 商存放在第3个数据的内存单元中 assume cs:code,ds:data data segment dd 100001 dw 100 dw 0 data ends code segment start: mov ax,data mov ds,ax mov bx,0 mov ax,[bx] ;低位存放在ax中 mov dx,[bx+2] ;高位存放在dx中 div word ptr [bx+4] mov [bx+6],ax ;商存放在ax中，把ax中的内容放入内存中 mov ax,4c00h int 21h code ends end start 8.9 dup 1.dup是一个操作符，在汇编语言中，同db、dw、dd等一样，也是有编译器识别处理的符号 2.dup和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复 3.dup示例 1.db 3 dup(0) ;定义了3个字节，他们的值都是0 2.db 3 dup(0,1,2) ;定义了9个字节，他们是0、1、2、0、1、2、0、1、2 3.db 3 dup(‘abc’,’ABC’) ;定义了18个字节，相当于db’abcABCabcABCabcABC’ 4.dup的使用格式 db 重复的次数 dup(重复的字节型数据) dw 重复的次数 dup(重复的字型数据) dd 重复的次数 dup(重复的双字型数据) 【实验七】 没调试成功 assume cs:code,ds:data,ss:stack,es:table stack segment ;空栈时，sp指向16 dw 8 dup(0) stack ends data segment ;表示21年的21个字符串 ;起始地址0，终止地址21*4-1：83 db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39; db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39; db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39; ;表示21年公司总收入的21个双字型数据 ;起始地址21*4：84，终止地址21*4+21*4-1：167 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;表示21年公司雇员人数的21个字型数据 ;起止地址21*8：168，终止地址21*8+21*2-1：209 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends table segment db 21 dup(&#39;year summ ne ?? &#39;) table ends code segment start: mov ax,data mov ds,ax mov ax,table mov es,ax mov ax,stack mov ss,ax mov sp,16 mov si,0 mov di,0 mov bx,0 mov bp,0 mov cx,21 outer: push si add si,si mov ax,ds:[bp] mov es:[bx][di],ax mov ax,ds:84[bp] mov es:[bx][di+5],ax pop si mov al,168[si] mov es:[bx][di+10],al inc si add di,2 push si add si,si mov ax,ds:[bp] mov es:[bx][di],ax mov ax,ds:84[bp] mov es:[bx][di+5],ax pop si mov al,168[si] mov es:[bx][di+10],al inc si add di,2 add bx,16 loop outer mov ax,4c00h int 21h code ends end start 第九章 转移指令的原理8086CPU的转移指令分为以下几类： 1.无条件跳转指令（如：jmp） 2.条件跳转指令 3.循环指令（如：loop） 4.过程，就像C语言中的函数 5.中断 9.1 操作符offset 操作符offset在汇编语言中由编译器处理，它的功能是取标号的偏移地址 如：s:mov ax,offset s9.2 jmp指令 1.无条件转移，可以只修改ip，也可以同时修改cs和ip 1.【jmp 段地址:偏移地址】 可以用来同时修改CS和IP 指令中的段地址修改CS 偏移地址修改IP 这种用法编译器不认识，只能做在debug中使用 2.【jmp 某一合法的寄存器】 仅修改IP的内容 比如：jmp ax 或者 jmp bx（类似于mov IP ax） 2.jmp指令要给出两种信息： 1.转移的目的地址 2.转移的距离（段间转移、段内短转移、段内近转移）9.3 依据位移进行转移的jmp指令 1.jmp short 标号【转到标号处执行指令,段内短转移】 此格式实现的是：段内短转移，它对ip的修改范围为-128~127 2.也就是说，它向前转移时可以最多越过128个字节，负数使用补码表示 向后转移可以最多越过127个字节 3.CPU不需要目的地址就可以实现对ip的修改 jmp指令的机器码中不包含目的地址，但是可以实现跳转 实现的方式，是在原地址的基础上进行一个偏移量，即位移 4.还有一种和指令“jmp short 标号”功能类似的指令格式： jmp near ptr 标号，它实现的是段内近转移 功能为：(ip)=(ip)+16位位移 jmp short 标号是8位的位移，而jmp near ptr 标号是16位位移9.4 转移的目的地址在指令中的jmp指令 前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前ip的转移位移 1.指令“jmp far ptr 标号” 实现的是段间转移，又称为远转移,这时机器码中应该明确给出【段地址】 2.指令“jmp far ptr 标号”功能如下： (CS)=标号所在段的段地址 (IP)=标号所在段中的偏移地址 far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip9.5 转移地址在寄存器中的jmp指令 指令格式：jmp 16位寄存器 功能：修改ip寄存器中的值，把16位寄存器中的值送入到ip寄存器中9.6 转移地址在内存中的jmp指令 转移地址在内存中的jmp指令有两种格式： 1.jmp word ptr 内存单元地址（段内转移） 功能：将内存中的那个字视为一个偏移地址，然后跳转到那个偏移地址 与【jmp 寄存器】功能相似 内存单元地址可用寻址方式的任意格式给出 2.jmp dword ptr 内存单元地址（段间转移） (ip)=(内存单元地址) ;双字中的低位字是给ip的 (cs)=(内存单元地址+2) ;双字中的高位字是给cs的 跟【jmp 段地址:偏移地址】功能类似 内存单元地址可用寻址方式的任意格式给出 补充：不能直接向内存单元中加入立即数 要通过寄存器，把立即数加进去9.7 jcxz指令 1.有条件跳转指令，所有的有条件跳转指令都是短转移 对应的机器码中包含转移的位移，而不是目的地址。对ip的修改范围都为：-128~127 另一个有条件跳转指令【loop指令】 2.指令格式：jcxz 标号 如果（cx）=0，则跳转到标号处执行 3.jcxz 标号 指令的操作： 1.当(cx)=0时，(ip)=(ip)+8位位移 2.当(cx)!=0时，什么也不做（程序继续向下执行）9.8 loop指令 1.循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移 2.指令格式：loop 标号 3.指令的内部操作 1.cx=cx-1 2.如果cx!=0，(ip)=(ip)+8位位移，跳转 3.(cx)=0，什么也不做，程序向下执行 cx用来控制循环的次数9.9 根据位移进行转移的意义 1.根据位移进行转移，这样设计，方便了程序段在内存中的浮动装配 可以实现代码的复用 2.如果在机器码中直接给出【段地址:偏移地址】， 这段程序在内存中换一个位置，则会运行不正确 3.段内近转移、段内短转移都是根据位移进行转移，一共有四种方式 1.jmp short ptr 标号 2.jmp near ptr 标号 3.jcxz 标号 4.loop 标号9.10 编译器对转移位移超界的检测 注意，根据位移进行转移的指令，他们的转移范围会受到限制 如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错 【实验八、九】【这个实验要重点看】 第十章 call和ret指令call和ret指令都是转移指令，它们都能修改ip，或同时修改cs和ip 10.1 ret和ref 1.ret指令用栈中的数据，修改ip的内容，从而实现【近转移】 CPU执行ret指令时，进行下面两步操作： 1.(ip)=((ss)16+(sp)) ;ip的值修改为栈顶的内容 2.(sp)=(sp)+2 ;栈顶移动 2.retf指令用栈中的数据，修改cs和ip的内容，从而实现【远转移】 CPU执行retf指令时，进行下面四步操作 1.(ip)=((ss)16+(sp)) ;ip的内容修改为栈顶的内容 2.(sp)=(sp)+2 ;栈顶移动 3.(cs)=((ss)16+(sp)) ;cs的内容修改为栈顶移动之后，栈顶的内容 4.(sp)=(sp)+2 ;栈顶移动 栈顶的两个字，低位字修改为ip，高位字修改为cs 3.可以看出，如果我们用汇编语法来解释ret和retf指令，则 1.CPU执行ret指令，相当于 pop ip 2.执行retf指令时，相当于 pop ip pop cs10.2 call指令 1.call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作： 1.将当前的ip或cs和ip压入栈中 2.转移 2.call指令不能实现短转移，除此之外， call指令实现转移的方法和jmp指令的原理相同 【依据位移进行转移的call指令】 3.CPU执行“call 标号”这种格式的call指令时，进行如下操作： 1.(sp)=(sp)-2 ;栈顶移动 2.((ss)16+(sp))=(ip) ;当前ip内容压栈 3.(ip)=(ip)+16位位移 ;跳转到标号处 4.call指令格式：call 标号 相当于执行： push ip jmp near ptr 标号10.4 转移的目的地址在指令中的call指令 1.指令格式：call far ptr 标号 实现的是段间转移 2.执行这种格式的call指令时CPU的操作 1.(sp)=(sp)-2 ;栈顶移动 2.((ss)×16+(sp))=(cs) ;先把cs压栈 3.(sp)=(sp)-2 ;栈顶移动 4.((ss)×16+(sp))=(ip) ;然后把ss压栈 3.CPU执行“call far ptr 标号”时，相当于进行 push cs push ip jmp far ptr 标号10.5 转移地址在寄存器中的call指令 1.指令格式：call 16位寄存器 2.执行这种指令时，在CPU中的操作 1.(sp)=(sp)-2 2.((ss)×16+(sp))=(ip) 3.(ip)=(16位寄存器) 3.相当于 push ip jmp 16位寄存器10.6 转移地址在内存中的call指令 转移地址在内存中的call指令有两种格式： 1.call word ptr 内存单元地址 汇编语法解释 push ip jmp word ptr 内存单元地址 2.call dword ptr 内存单元地址 汇编语法解释 push cs ;cs存放在高位 push ip ;ip存放在低位 jmp dword ptr 内存单元地址10.7 call和ret的配合使用10.8 mul指令 相乘的两个数；要么都是8位，要么都是16位 1.8位：AL中和8位寄存器或内存字节单元中 AL中的内容作为被乘数 结果放在AX中 2.16位：AX中和16位寄存器或内存字单元中 AX中的内容作为被乘数 结果放在DX（高位）和AX（低位）中。 3.格式如下： mul 寄存器 mul 内存单元（byte ptr或 word ptr指明是字还是字节）10.9 模块化程序设计10.10 参数和结果传递的问题 【编程】计算data段中第一组数据的3次方，结果保存在后面一组dword单元中 data sgement dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0 data ends 10.11 批量数据的传递 使用寄存器、内存、栈传递数据 【编程】将一个全是字母，以0结尾的字符串，转化为大写 【实验十 编写子程序】 1.显示字符串 2.解决除法溢出问题 3.数值显示 【课程设计1】 第十一章 标志寄存器8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW） 本章中的标志寄存器（以下简称为flag）是我们要学习的最有一个寄存器 flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息 8086CPU的flag寄存器的结构： 1.flag的1、3、4、12、13、14、15位共7位在8086CPU中没有使用，不具有任何含义 而0、2、4、6、7、8、9、10、11位共9位都具有特殊的含义 2.示意图 11.1 ZF标志 1.flag的第6位是ZF，零标志位。 它记录相关指令执行后， 1.结果为0，ZF=1 2.结果不为0，ZF=0 2.示例： mov ax,1 sub ax,1 指令执行后，结果为0，则ZF=1 mov ax，2 sub ax，1 指令执行后，结果不为0，则ZF=0 3.注意，在8086CPU的指令集中，有的指令的执行会影响标志寄存器 比如：add、sub、mul、div、inc、or、and等 他们大都是运算指令（逻辑运算或者算术运算） 有的指令的执行对标志寄存器没有影响， 比如：mov、push、pop等，他们大都是传送指令11.2 PF标志 flag的第2位是PF，奇偶标志位 它记录指令执行后，结果的所有二进制位中1的个数 1.为偶数，PF=1 2.为奇数，PF=011.3 SF标志 1.flag的第7位是SF，符号标志位 2.它记录指令执行后 1.结果为负。sf=1 2.结果为正，sf=0 sf标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负 sf标志把所有数当作有符号数 如果把数据当作无符号数运算，sf的值则没有意义，虽然相关指令会影响它的值 3.也就是说，CPU在执行add等指令时，是必然要影响sf标志位的值 至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算11.4 CF标志 1.flag的第0位是CF，进位标志位 一般请况下，在进行无符号数运算的时候， 它记录了运算结果的最高有效位向更高位的进位值， 或从更高位的借位值 代表假想的更高位 2.CPU在运算时，不会丢弃进位值，而是记录在一个特殊的寄存器的某一位上 8086CPU就用flag的cf为来记录这个进位值，借位也一样 3.在debug中的显示 4.无符号的时候产生的结果 11.5 OF标志 flag中的第11位 进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出 1.这里所讲的溢出，只是对有符号数运算而言 就像进位只是相对于无符号数而言！ 2.一定要注意cf和of的区别 当需要把机器码看成有符号数则使用of 当需要把机器码看成无符号数则使用cf11.6 adc标志 adc是带进位的加法指令，他利用了cf上记录的进位值 1.格式：adc 操作对象1，操作对象2 2.功能：操作对象1=操作对象1+操作对象2+cf 比如：adc ax,bx实现的功能是： (ax)=(ax)+(bx)+cf 3.执行adc指令的时候，加上的cf的值的含义，由adc指令前的指令决定 也就是说，关键在于所加上的cf值是被什么指令设置的 4.如果cf是被sub指令设置的，那么他的含义就是借位值 如果是被add指令设置的，那么它的含义就是进位值 5.下面的指令和add ax,bx具有相同的结果 add al,bl adc ah,bh CPU提供adc指令的目的，就是来进行加法的第二步运算的 adc指令和add指令相配合就可以对更大的数据进行加法运算 【实验：编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中】11.7 sbb标志 sbb是带借位减法指令，他利用了cf位上记录的借位值 1.格式：sbb 操作对象1，操作对象2 2.功能：操作对象1=操作对象1-操作对象2-cf 3.利用sbb指令，我们可以对任意大的数据进行减法运算 4.sbb和adc是基于相同的思想设计的两条指令， 在应用思路上和adc类似11.8 cmp标志 1.cmp是比较指令，功能相当于减法指令，只是不保存结果 2.cmp指令执行后，将对标志寄存器产生影响 3.其他相关指令通过识别这些被影响的标志寄存器，来得知比较结果 4.cmp指令格式：cmp 操作对象1,操作对象2 5.功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置 6.比如：cmp ax,ax 做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关位 指令执行后 zf=1 ;结果为0 pf=1 ;结果的1的个数为偶数 sf=0 ;结果为正号 cf=0 ;结果没有产生进位或借位 of=0 ;结果没有溢出 7.根据flag，判断cmp指令的结果（无符号数） 8.cmp既可以对无符号数进行比较，也可以对有符号数进行比较 cmp 操作数1,操作数2 ;操作数1、操作数2都是有符号数 1.of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负 of=0，sf=1 则 操作数1比操作数2小 of=0，sf=0 则 操作数1比操作数2大 2.of=1，说明有溢出，逻辑上真正结果的正负与实际结果的正负相反 of=1，sf=1 则 操作数1比操作数2大 of=1，sf=0 则 操作数1比操作数2小 11.9 检测比较结果的条件转移指令 1.这些条件转移指令通常和cmp相配合使用 2.因为cmp指令可以同时进行两种比较，无符号数和有符号数的比较 所以，这些转移指令也分为两种，即： 1.根据【无符号数】的比较结果进行转移的条件转移指令， 他们检测zf、cf的值 2.根据【有符号数】的比较结果进行转移的条件转移指令 他们检测sf、of和zf的值 3.无符号比较，条件转移指令小结【无符号，6个】 1.je 等于则转移 zf=1 2.jne 不等于则转移 zf=0 3.jb 低于则转移 cf=1 【b表示below】 4.jnb 不低于则转移 cf=0 5.ja 高于则转移 cf=0，zf=0【a表示above】 6.jna 不高于则转移 cf=1或zf=111.10 DF标志和串传送指令 1.flag的第10位DF，方向标志位 在串处理指令（movsb，movsw）中，控制每次操作后si、di的增减 df=0：每次操作后si，di递增 df=1：每次操作后si，di递减 2.格式：movsb 3.功能：（以字节为单位传送） 1.((es)16+(di))=((ds)16+(si)) 2.如果df=0，则：(si)=(si)+1 (di)=(di)+1 如果df=1，则：(si)=(si)-1 (di)=(di)-1 3.功能文字描述 movsb的功能是将ds:si指向的内存单元中的字节 送入es:di中，然后根据标志寄存器df位的值， 将si和di递增或递减 4.movsw 传送一个字 5.movsb和movsw都和rep配合使用 格式：rep movsb rep的作用根据cx的值，重复执行后面的串传送指令 6.cld指令和std指令 cld指令：将标志寄存器的df置为0【c:clear】 std指令：将标志寄存器的df置为1【s:set】 11.11 pushf和popf pushf：将标志寄存器的值压栈 popf：从栈中弹出数据，送入标志寄存器中 pushf和popf为直接访问标志寄存器提供了一种方法 11.12 标志寄存器在debug中的表示 第十二章 内中断**引言和简介 1.中断是CPU处理外部突发事件的一个重要技术 2.它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后 又立即返回断点，继续进行CPU原来的工作。 3.引起中断的原因【即：发出中断请求的来源叫作中断源】 4.根据中断源的不同，可以把中断分为：【软件中断】和【硬件中断】两大类 而硬件中断又可以分为【外部中断】和【内部中断】两类 12.1 内中断的产生 1.外部中断一般是指计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断。 外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。 2.内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断）所引起的中断。 内部中断是不可屏蔽的中断 3.软件中断其实并不是真正的中断，他们只是可被调用执行的一般程序， DOS的系统功能调用（int 21h）都是软件中断 4.CPU为了处理并发的中断请求，规定了中断的优先权，优先权由高到低的顺序是： 1.除法错、溢出中断、软件中断 2.不可屏蔽中断 3.可屏蔽中断 4.单步中断12.2 中断处理程序简介 1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系 使得CPU根据中断信息可以找到要执行的处理程序。 2.中断信息中包含有表示中断的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序的。 3.CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址 即中断类型码是中断向量在中断向量表中的索引12.3 中断向量表【中断向量表就是中断向量的列表】 1.中断向量表在内存中保存，其中存放着256个【2^8,8位中断类型码】中断源所对应的中断处理程序的入口 对于8086PC机，中断向量表指定放在内存地址0处 2.从0:0-0:03ffh的1024个字节【2564，物理地址使用段地址和偏移地址存放，需要4个字节】中存放着中断向量表12.4 中断过程 1.可以用中断类型码，在中断向量表中找到中断处理程序的入口 找到这个入口地址的最终目的是用它设置cs和ip，使CPU执行中断处理程序 2.用中断类型码找到中断向量，并用它设置cs和ip，这个工作时由CPU的硬件自动完成的 CPU硬件完成这个工作的过程被称为【中断过程】 3.中断过程 8086CPU的中断过程 1.（从中断信息中）取得中断类型码 2.标志寄存器的值入栈（保护标志位） 3.设置标志寄存器的第8位TF和第9位IF设置为0（后面讲解本步的目的） 4.cs内容入栈 5.ip内容入栈 6.从内存地址为中断类型码4和中断类型码4+2的两个子单元中 读取中断处理程序的入口地址设置cs和ip 4.使用汇编语言描述中断过程，如下 1.取得中断类型码N 2.pushf 3.TF=0，IF=0 4.push cs 5.push ip 6.（ip）=（N4），（cs）=（N*4+2）12.5 中断处理程序 1.由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序， 所以，中断处理程序必须一致存储在内存某段空间中 2.而中断处理程序的入口地址，即【中断向量】，必须存储在对应的中断向量表表项中 3.中断处理程序的编写方法和子程序的比较类似，下面是常规的步骤 1.保存用到的寄存器 2.处理中断 3.恢复用到的寄存器 4.用iret指令返回 **iret指令的功能用汇编语法描述为 pop ip pop cs popf iret通常和硬件自动完成的中断过程配合使用 iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序12.6 除法错误中断的处理 当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的终端信息 CPU将检测到这个信息，然后引发中断程序，转去执行0号中断对应的中断处理程序 例如： mov ax 1000h mov bh，1 div bh 此程序会产生溢出 运行之后，会显示 12.7 编程处理0号中断 现在重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to here!”的广告词，然后返回到操作系统 把中断处理程序放到安全空间中 中断程序的框架 12.8 安装 计算中断程序的长度：offset 标号1-offset 标号2 在代码段中存放数据12.9 do012.10 设置中断向量12.11 单步中断 如果检测到标志寄存器的tf位为1，则产生单步中断，引发中断过程12.12 响应中断的特殊情况 第十三章 int指令13.1 int指令 1.int格式：int n ;n为中断类型码 它的功能是引发中断过程 2.CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下 1.取中断类型码 2.标志寄存器入栈，if=0，tf=0 3.cs，ip入栈 4.从此处转去执行n号中断的中断处理过程 3.可以在程序中使用int指令调用任何一个中断的中断处理程序 可以用int指令调用这些子程序，也可以自己编写一些中断处理程序供别人使用13.2 编写供应用程序调用的中断例程 【实例1】编写、安装中断7ch的中断例程，实现求一个word型数据的平方 1.功能：求一word型数据的平方 2.参数：（ax）=要计算的数据 3.返回值：dx、ax中存放结果的高16位和低16位 4.应用举例：求2*3456^2 ;程序1：调用中断程序计算平方 code segment assume cs: code start: mov ax,3456; (ax)=3456 int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方 add ax,ax adc dx,dx ;存放结果，讲结果乘以2 mov ax,4c00h int 21h code ends end start ;程序2：编写中断程序 ;程序2中要做三部分工作 ; 1.编程实现求平方功能的程序 ; 2.安装程序，我们将其安装在0:200处 ; 3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。 code segment assume cs:code start: mov ax,cs mov ds,ax mov si,offset sqr ;设置ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov cx,offset sqrend - offset sqr ;设置cx为传输长度 cld ;设置传输方向为正 rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h ;设置中断向量地址，偏移地址 mov word ptr es:[7ch*4+2],0 ;设置中断向量地址，段地址 mov ax,4c00h int 21h sqr: mul ax iret sqrend: nop code ends end start 【实例2】编写、安装中断7ch的中断例程，实现将一个全是字母，以0结尾的字符串，转化为大写。 code segment assume cs:code start: mov ax,cs mov ds,ax mov si,offset capital mov ax,0 mov es,ax mov di,200h mov cx,offset capitalend - offset capital cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h capital: push cx push si change: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b inc si jmp short change ok: pop si pop cx iret capitalend: nop code ends end start 13.3 对int、iret和栈的深入理解 【问题】用7ch中断例程完成loop指令的功能 不要随便修改sp，可以使用bp进行间接访问13.4 BIOS和DOS所提供的中断例程13.5 BIOS和DOS中断例程的安装过程 1.开机后，CPU一加电，初始化（cs）=0ffffh，ip=0，自动从ffff:0单元开始执行程序 ffff:0处有一条跳转指令，CPU执行该指令后，转去执行bios中的硬件系统的检测和初始化程序。 2.初始化程序将建立bios所支持的中断向量，即将bios提供的中断例程的入口地址登记在中断向量表中。 3.硬件系统检测和初始化完成后，调用19h进行操作系统的引导。从此将计算机交由操作系统控制。 4.DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量13.6 BIOS中断例程的应用 1.int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序 一般来说，一个供程序员调用的中断例程中，往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序 2.bios和dos提供的中断例程，都用ah来传递内部子程序的编号13.7 DOS中断例程应用 int 21h中断例程是dos提供的中断例程，其中包含了dos提供给程序员造编程时调用的子程序 【实验13】 **介绍一本汇编语言的书《The Art of Assembly Language》 第十四章 端口CPU可以直接读写3个地方的数据 1.CPU内部的寄存器 2.内存单元 3.端口 14.1 端口的读写 1.对端口的读写不能用mov、push、pop等内存读写指令 端口的读写指令只有两条：【in】和【out】分别用于从端口读取数据和往端口写入数据 2.CPU执行内存访问指令和端口访问指令时，总线上的信息： 1.访问内存 mov ax,ds:[8]; 假设执行前（ds）=0 执行时，与总线相关的操作： 1.CPU通过地址线将地址信息8发出 2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 3.存储器将8号单元中的数据通过数据线送入CPU 2.访问端口 这里的【端口】是对硬件开放的端口 in al,60h; 从60h号端口读入一个字节 执行时与总线相关的操作 1.CPU通过地址线将地址信息60h发出 2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据 3.端口所在的芯片将60h端口中的数据通过数据线送入CPU 注意：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据 访问8位端口时用al，访问16位端口时用ax 3.对0-255以内的端口进行读写 in al,20h ;从20h端口读一个字节 out 20h,al ;往20h端口写一个字节 4.对256-65535的端口进行读写时，端口号放在【dx】中 mov dx,3f8h ;将端口号3f8送入dx in al,dx ;从3f8h端口读一个字节 out dx,al ;从3f8h端口写一个字节14.2 CMOS RAM芯片 1.PC机中有一个CMOS RAM芯片，其有如下特征 1.包含一个实时钟和一个有128个存储单元的RAM存储器。（早期的计算机为64字节） 2.该芯片靠电池供电。因此，关机后其内部的实时钟仍可以正常工作，RAM中的信息不丢失 3.128字节的RAM中，内部实时钟占用0-0dh单元来保存时间信息，其余大部分分单元用于 保存系统配置信息，供系统启动时bios程序读取 bios也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息 补充：BIOS BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。 在IBM PC兼容系统上，是一种业界标准的固件接口。BIOS这个字眼是在1975年第一次由CP/M操作系统中出现。 BIOS是个人电脑启动时加载的第一个软件 4.该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS RAM。 5.70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据 或要写入到其中的数据 2.比如：读CMOS RAM的2号单元： 1.将2送入端口70h 2.从71h读取2号单元的内容 14.3 shl和shr指令 shl和shr是逻辑移位指令，后面的课程中我们要用到移位指令 1.shl逻辑左移指令，功能为： 1.将一个寄存器或内存单元中的数据向左移位 2.将最后移出的移位写入cf中 3.最低位用0补充 例如有如下指令： mov al,01001000b shl al,1 ;将al中的数据左移一位 执行后(al)=100100000b，cf=0. 如果移动位数大于1时，必须将移动位数放在cl中 2.shr逻辑右移指令，与shl刚好相反14.4 CMOS RAM中存储的时间信息 在CMOS RAM中存放着当前时间 秒：00h 分：02h 时：04h 日：07h 月：08h 年：09h 这6个信息的长度都为1个字节 这些数据以BCD码的方式存放，一个字节可以表示两个BCD码 CMOS RAM存储时间信息的单元中存储了用两个BCD码表示的两个十进制数 高4位的BCD码表示十位，低四位的BCD码表示个位 【编程】：在屏幕中间显示当前的月份 1.CMOS RAM芯片回顾： 1.70h为地址端口，存放要访问的CMOS RAM单元的地址 2.71h为数据端口，存放从选定的CMOS RAM单元中【读取】的数据，或【写入】其中的数据 2.分析 这个程序主要做两部分工作 1.从CMOS RAM的8号单元读取当前月份的BCD码 要读取CMOS RAM的信息，我们首先要向地址端口70h写入要访问的单元的地址 mov al,8 out 70h,al 然后从数据端口71h中取得指定单元中的数据 in al,71h 2.将用BCD码表示的月份以十进制的形式显示到屏幕上 ;编程：在屏幕中间显示当前的月份 code segment assume cs:code start: mov al,8 out 70h,al in al,71h mov ah,al mov cl,4 shr ah,cl and al,00001111b add ah,30h add al,30h mov bx,0b800h ;显存 mov es,bx mov byte ptr es:[160*12+40*2],ah ;显示月份的十位数码 mov byte ptr es:[160*12+40*2+2],al ;显示月份的个位数码 mov ax,4c00h int 21h code ends end start 【实验十四】编程：以“年/月/日 时:分:秒”的格式，显示当前日期和时间 第十五章 外中断**CPU除了有运算能力，还有I/O能力 15.1 接口芯片和端口 1.在PC系统的接口卡和主板上，装有各种接口芯片，这些外设接口芯片的内部装有若干寄存器 CPU将这些寄存器当做【端口】访问 2.外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的【端口】中 3.CPU向外设的输出也是要先送入【端口】中，再由相关芯片送入到外设 4.CPU可以向外设输出控制命令，这些控制命令也是先送到【端口】中，然后相关芯片根据命令进行相关工作 5.可见：CPU与外部设备的交流是通过【端口】进行的 CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入15.2 外中断信息 1.在PC系统中，外中断源一共有两类 1.可屏蔽中断 2.不可屏蔽中断 2.可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断 要看标志寄存器的IF位的设置 当CPU检测到可屏蔽中断信息时： 1.若IF=1，则CPU在执行完当前指令后相应中断，引发中断过程 2.若IF=0，则不响应可屏蔽中断 3.可屏蔽中断所引发的中断过程，除在第一步的实现上与内中断有所不同外，基本上和内中断的中断过程相同 4.因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的 而内中断的中断码是在CPU内部产生的 5.IF设置为0的原因：在进入中断处理程序后，禁止其他的可屏蔽中断 当然，如果中断处理程序中需要处理可屏蔽中断，可以用指令将IF设置为1 6.8086CPU提供的设置IF的指令如下： sti ;用于设置IF=1 cli ;用于设置IF=0 7.不可屏蔽中断是CPU必须相应的外中断。 当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后 立即响应，应发中断过程 8.8086CPU不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码 9.不可屏蔽中断的中断过程 1.标志寄存器入栈，IF=0，TF=0 2.CS，IP入栈 3.（IP）=（8），（CS）=（0AH） ;固定地址 10.几乎所有外中断，都是可屏蔽中断。当外设有需要处理的事件发生时 相关芯片向CPU发出可屏蔽中断信息。 不可屏蔽中断是系统中有必须处理的紧急情况发生时用来通知CPU的中断信息，本门课程中，主要讨论可屏蔽中断 15.3 PC机键盘的处理过程 1.下面看一个键盘输入的处理过程，并以此来体会PC机处理外设输入的基本方法 1.键盘输入 2.引发9号中断 3.执行int 9中断例程 2.PC机键盘的处理过程 1.键盘上每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一触键的开关状态进行扫描。 2.按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明按下的键在键盘上的位置 扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H 3.松开控下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时 产生的扫描码也被送入60H端口中。 一般按下一个键时，产生的扫描码称为通码，松开一个键产生的扫描码称为断码 扫描码长度为一个字节，通码的第七位为0，断码的第七位为1 即：断码=通码+80H **BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要的工作如下： 1.读出60H端口中的扫描码 2.如果是字符键的扫描码，将该扫描码对应的字符码（即：ASCII码）送入内存中的BIOS键盘缓冲区 3，如果是控制键和切换键的扫描码，则将其转变为状态字节，写入内存中存储状态字节的单元 4.键盘的输入到达60H端口时，相关的芯片会向CPU发出中断类型码为9的可屏蔽中断信息。 5.CPU检测到中断信息后，如果IF=1，则相应中断，同时将IF设置为0（不让其他可屏蔽中断进行干扰），引发中断过程，转去执行int9中断例程 3.BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接受的键盘输入的内存区 4.该内存区可以存储15个键盘输入，int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码， 所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高字节存放扫描码，低字节存放字符码 5.0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下： 15.4 编写int9中断例程,并安装 梳理键盘输入的处理过程 1.键盘产生扫描码 2.扫描码送入60H端口 3.一旦侦测到60H端口有动静，引发9号中断 4.CPU执行int9中断例程处理输入 以上的过程，前三步都由硬件系统自动完成，能够修改的只有第四步，修改int9中断程序 【任务演示】在屏幕中依次显示“a”~“z”并可以让人看清。在显示过程中，按下Esc键后，该表显示的颜色 ;程序1：实现连续显示“a”~“z” ;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。 ;部分功能代码： stack segment db 128 dup (0) stack ends code segment assume cs:code start: mov ax,stack mov ss,ax mov sp,128 mov ax,0b800h mov es,ax mov ah,&#39;a&#39; s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,&#39;z&#39; jna s mov ax,4c00h int 21h delay: push ax push dx mov dx,0010h ;循环10000000h次 mov ax,0 s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret code ends end start ;程序2：实现改变颜色 ;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。 stack segment db 128 dup (0) stack ends data segment dw 0,0 data ends code segment assume cs:code start: mov ax,stack mov ss,ax mov sp,128 mov ax,data mov ds,ax mov ax,0 mov es,ax push es:[9*4] pop ds:[0] push es:[9*4+2] pop ds:[2] ;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中 mov word ptr es:[9*4],offset int9 mov es:[9*4+2],cs ;在中断向量表中设置新的int 9中断例程的入口地址 mov ax,0b800h mov es,ax mov ah,&#39;a&#39; s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,&#39;z&#39; jna s mov ax,0 mov es,ax push ds:[0] pop es:[9*4] push ds;[2] pop es;[9*4+2] ;将中断向量表中int 9中断例程的入口恢复为原来的地址 mov ax,4c00h int 21h delay: push ax push dx mov dx,0010h mov ax,0 s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret ;------以下为新的int 9中断例程-------------------- ;int9中断例程是在进行键盘输入之后，由系统自动调用 int9: push ax push bx push es in al,60h pushf pushf pop bx and bh,11111100b push bx popf call dword ptr ds:[0] ;对int指令进行模拟，调用原来的int 9中断例程 cmp al,1 jne int9ret mov ax,0b800h mov es,ax inc byte ptr es:[160*12+40*2+1] ;属性增加1，改变颜色 int9ret: pop es pop bx pop ax iret code ends end start 第十六章 直接定址表16.1 描述了单元长度的标号 1.本章讨论如何有效合理地组织数据，以及相关的编程技术 1.前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址 2.还可以使用一种标号，这种标号不但可以表示内存单元的地址，还表示了内存单元的长度 即：表示在此标号处的单元，是一个字节单元，还是字单元还是双字单元 2.例如 1.标号1 a : db 1,2,3,4,5,6,7,8 b : dw 0 此种标号只能标记地址 此种加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用 2.标号2 a db 1,2,3,4,5,6,7,8 ;标号a，描述了地址code:0,和从这个地址开始，以后的内存单元都是字节单元 b dw 0 ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元 此种标号既可以标记地址，也可以表示此标号处的单元 3.使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据 这种标号此后称为数据标号，它标记了存储数据的单元的地址和长度 4.数据标号的用法 指令：mov ax,b ;相当于：mov ax,cs:[8] 指令：mov b,2 ;相当于：mov word ptr cs:[8],2 指令：inc b ;相当于：inc word ptr cs:[8] 指令：mov al,a [si] ;相当于：mov al,cs:0[si] 指令：mov al,a[3] ;相当于：mov al,cs:0[3] 指令：mov al,a[bx+si+3] ;相当于：mov al,cs:0[bx+si+3]16.2 在其他段中使用数据标号 1.注意，如果想在代码段中，直接用数据标号访问数据， 则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来。 否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。 2. 当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要， 用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。 3.我们可以将数据标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。 1.把数据标号当做数据来定义时，使用【dw】定义数据 比如： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw a,b ;数据标号c处存储的两个字型数据为标号a、b 的偏移地址。 data ends 数据标号c处存储的两个字型数据为标号a、b 的偏移地址。 相当于： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a, offset b data ends 2.把数据标号当做数据来定义时，使用【dd】定义数据 再比如： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dd a,b ;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。 data ends 数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。 相当于： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a, seg a, offset b, seg b ;seg操作符，功能为取得某一标号的段地址。 data ends seg操作符，功能为取得某一标号的段地址。 16.3 直接定址表 本节课，我们将使用“查表”的方法，编写相关程序的技巧 【任务】编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据 code segment assume cs:code start: mov al,0eh ;al中存放了byte型数据 call showbyte mov ax,4c00h int 21h ;子程序： ;用al传送要显示的数据 showbyte: jmp short show table db &#39;0123456789ABCDEF&#39; ;字符表 show: push bx ;保护现场 push es mov ah,al shr ah,1 shr ah,1 shr ah,1 shr ah,1 ;右移4位，ah中得到高4位的值 and al,00001111b ;al中为低4位的值 mov bl,ah mov bh,0 mov ah,table[bx] ;用高4位的值作为相对于table的偏移，取得对应的字符 mov bx,0b800h mov es,bx mov es:[160*12+40*2],ah mov bl,al mov bh,0 mov al,table[bx] ;用低4位的值作为相对于table的偏移，取得对应的字符 mov es:[160*12+40*2+2],al pop es pop bx ret code ends end start 16.4 程序入口地址的直接定址表 【编程】实现一个子程序setscreen，为显示输出提供如下功能： 1.清屏 2.设置前景色 3.设置背景色 4.向上滚动一行 1.入口参数说明： 1.用ah寄存器传递功能号 0：清屏；1：设置前景色；2：设置背景色；3：向上滚动一行 2.对于2、3号功能，用al传递颜色值 al∈{0，1，2，3，4，5，6，7} 2.各种功能如何实现 1.清屏： 将显存中当前屏幕中的字符设为空格符； 2.设置前景色： 设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位； 012位存放前景色 3.设置背景色： 设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位； 456位存放背景色 4.向上滚动一行： 依次将第 n+1行的内容复制到第n行处：最后一行为空。 ;功能子程序1：清屏 sub1: push bx ;保护现场,调用子程序的时候，注意要保护现场，运行子程序的时候，可能会修改一些寄存器的值 push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 sub1s: mov byte ptr es:[bx],&#39; &#39; ;循坏2000次 add bx,2 loop sub1s pop es ;恢复现场 pop cx pop bx ret ;功能子程序2：设置前景 sub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: and byte ptr es:[bx],11111000b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;功能子程序3：设置背景色 sub3: push bx push cx push es mov cl,4 shl al,cl mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: and byte ptr es:[bx],10001111b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;功能子程序4：向上滚动一行 sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160 ;ds:si指向第n+1行，第1行 mov di,0 ;es:di指向第n行，第0行 cld mov cx,24;共复制24行 sub4s: push cx mov cx,160 rep movsb ;复制 pop cx loop sub4s mov cx,80 mov si,0 sub4s1: mov byte ptr es:[160*24+si],&#39; &#39; ;最后一行清空 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret ;sub4 ends 3.可以将这些功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应 ;编程：实现一个子程序setscreen，为显示输出提供如下功能： ;(1) 清屏。 ;(2) 设置前景色。 ;(3) 设置背景色。 ;(4) 向上滚动一行。 ; ;入口参数说明： ;(1) 用 ah 寄存器传递功能号：0 表示清屏，1表示设置前景色，2 表示设置背景色，3 表示向上滚动一行； ;(2) 对于2、3号功能，用 al 传送颜色值，(al) ∈{0,1,2,3,4,5,6,7} setscreen: jmp short set table dw sub1,sub2,sub3,sub4 set: push bx cmp ah,3 ;判断传递的是否大于 3 ja sret mov bl,ah mov bh,0 add bx,bx ;根据ah中的功能号计算对应子程序的地址在table表中的偏移 call word ptr table[bx] ;调用对应的功能子程序，学会本句代码，是本章节的【精髓】 sret: pop bx iret ;功能子程序1：清屏 sub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 sub1s: mov byte ptr es:[bx],&#39; &#39; add bx,2 loop sub1s pop es pop cx pop bx ret ;sub1 ends ;功能子程序2：设置前景色 sub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: and byte ptr es:[bx],11111000b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;sub2 ends ;功能子程序3：设置背景色 sub3: push bx push cx push es mov cl,4 shl al,cl mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: and byte ptr es:[bx],10001111b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ; sub3 ends ;功能子程序4：向上滚动一行 sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160 ;ds:si指向第n+1行 mov di,0 ;es:di指向第n行 cld mov cx,24;共复制24行 sub4s: push cx mov cx,160 rep movsb ;复制 pop cx loop sub4s mov cx,80 mov si,0 sub4s1: mov byte ptr es:[160*24+si],&#39; &#39; ;最后一行清空 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret ;sub4 ends 第十七章 使用BIOS进入键盘输入和磁盘读写**引言 1.大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。 2.程序和数据通常需要长期存储，磁盘是最常用的存储设备。 3.BIOS 为这两种外设的I/O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。 17.1 int9中断例程对键盘输入的处理 CPU 在9 号中断发生后，执行int 9中断例程，从60h 端口读出扫描码， 并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。 17.2 使用int16h中断例程读取键盘缓冲区 1.BIOS提供了int 16h 中断例程供程序员调用。 2.int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。 3.下面的指令从键盘缓冲区（缓冲区的最低位）中读取一个键盘输入，并且将其从缓冲区中删除： mov ah,0 int 16h 结果：(ah)=扫描码，(al)=ASCII码。 4.int 16h 中断例程的 0 号功能，进行如下的工作： （1）检测键盘缓冲区中是否有数据； （2）没有则继续做第1 步；（缓冲区随时有可能输入数据） （3）读取缓冲区第一个字单元中的键盘输入； （4）将读取的扫描码送入ah，ASCII 码送入al； （5）将己读取的键盘输入从缓冲区中删除。 5.可见，B1OS 的int 9 中断例程和int 16h 中断例程是一对相互配合的程序， int 9 中断例程向键盘缓冲区中写入， int 16h 中断例程从缓冲区中读出。 它们写入和读出的时机不同，int 9 中断例程在有键按下的时候向键盘缓冲区中写入数据； 而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。 【编程】接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， 将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。 ;编程： ;接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， ;将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。 ;A、B、C处的程序指令比较有技巧，请读者自行分析 code segment assume cs:code start: mov ah,0 int 16h ;int 16h 0号功能实现从键盘缓冲区读取一个键盘输入 mov ah,1 ;A cmp al,&#39;r&#39; je red cmp al,&#39;g&#39; je green cmp al,&#39;b&#39; je blue jmp short sret red: shl ah,1 ;B green: shl ah,1 ;C blue: mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 s: and byte ptr es:[bx],11111000b ;设置颜色 or es:[bx],ah ;设置颜色 add bx,2 loop s sret: mov ax,4c00h int 21h code ends end start 17.3 字符串的输入 int 21h的0a号功能可以实现字符串的输入 也可以用int 16h，通过显示键盘缓冲区中的内容，实现字符串的显示 1.使用int 16h显示字符串程序的处理过程如下 ① 调用int 16h读取键盘输入； ② 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行① ； ③ 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行① ； ④ 如果是Enter 键，向字符栈中压入0，返回。 2.子程序：字符栈的入栈、出栈和显示 参数说明 (ah)=功能号，0表示入栈，1表示出栈，2表示显示； ds : si 指向字符栈空间； 对于0 号功能：(al)=入栈字符； 对于1 号功能：(al)=返回的字符； 对于2 号功能：(dh)、(dl) =字符串在屏幕上显示的行、列位置。 ;使用int 16h显示字符串的子程序：字符栈 ;最基本的字符串输入程序，需要具备下面的功能： ;（1） 在输入的同时需要显示这个字符串； ;（2）一般在输入回车符后，字符串输入结束； ;（3）能够删除已经输入的字符。 ;编写一个接收字符串的输入子程序，实现上面三个基本功能。 ;因为在输入的过程中需要显示，子程序的参数如下： ; (dh)、(dl)=字符串在屏幕上显示的行、列位置； ; ds:si 指向字符串的存储空间，字符串以O 为结尾符。 ;功能子程序实现 charstack: jmp short charstart table dw charpush,charpop,charshow top dw 0 ;栈顶 charstart: push bx push dx push di push es cmp ah,2 ja sret mov bl,ah mov bh,0 add bx,bx jmp word ptr table[bx] ;使用直接定址表 charpush: mov bx,top mov [si][bx],al inc top jmp sret charpop: cmp top,0 je sret dec top mov bx,top mov al,[si][bx] jmp sret charshow: mov bx,0b800h mov es,bx mov al,160 mov ah,0 mul dh mov di,ax add dl,dl mov dh,0 add di,dx mov bx,0 charshows: cmp bx,top jne noempty mov byte ptr es:[di],&#39; &#39; jmp sret noempty: mov al,[si][bx] mov es:[di],al mov byte ptr es:[di+2],&#39; &#39; inc bx add di,2 jmp charshows sret: pop es pop di pop dx pop bx ret 17.4 应用int13h中断例程对键盘进行读写 1.磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。 2.注意，我们只能以扇区为单位对磁盘进行读写。 在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。 3.BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。 4.我们可以通过调用BIOS中断例程来访问磁盘。 BIOS 提供的访问磁盘的中断例程为int 13h 。 如下，读取0面0道1扇区的内容到0:200： 返回参数： 操作成功：（ah）=0，（al）=读入的扇区数 操作失败：（ah）=出错代码 将0:200中的内容写入0面0道1扇区示例 返回参数： 操作成功： (ah)=0，(al)=写入的扇区数 操作失败： (ah)=出错代码 5.注意：使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的， 很可能覆盖掉重要的数据。 【编程】将当前屏幕的内容保存在磁盘上 分析：1 屏的内容占4000个字节，需要8 个扇区（一个扇区512B），我们用0面0道的1~8扇区存储显存中的内容。 code segment assume cs:code start: mov ax,0b800h mov es,ax mov bx,0 ;es:bx 指向将写入磁盘的数据的内存区 mov al,8 ;写入的扇区数 mov ch,0 ;磁道号，从0开始 mov cl,1 ;扇区号 从1开始 mov dl,0 ;驱动器号0:软驱A, 1:软驱B,硬盘从80h开始， 80h:硬盘C，81h:硬盘D mov dh,0 ;磁头号，（对于软盘即面号，因为一个面用一个磁头来读写） mov ah,3 ;传递 int 13h 写入数据的功能号 int 13h ;返回参数 ;操作成功:(ah) = 0,(al) = 写入的扇区数 ;操作失败:(ah) = 出错代码 return: mov ax,4c00h int 21h code ends end start 【实验17和课程设计2】 课程设计1在第十章 综合研究研究试验1 搭建一个精简的C语言开发环境 研究试验2 使用寄存器 研究试验3 使用内存空间 研究试验4 不用main函数编程 研究试验5 函数如何接受不定数量的参数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"全排列问题","slug":"全排列问题","date":"2021-03-12T09:30:00.000Z","updated":"2021-03-12T09:50:54.000Z","comments":true,"path":"2021/03/12/全排列问题/","link":"","permalink":"/2021/03/12/全排列问题/","excerpt":"","text":"全排列问题问题定义：给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [[1,2,3], [1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 问题分析：人脑建模过程（类似“走迷宫”，试一步走一步，当前的路走不通就返回上一个路口）： 先取原数组的第一个数，把它“固定”在一个temp数组的首位，比如：[1，num，num] 再取出原数组的第二个数，把它“固定”在temp数组的第二位，比如：[1，2，num] 再取出原数组的第三个数，把它“固定”在temp数组的第三位，比如：[1，2，3] 此时我们得到了第一个排列 接着我们会想，如果在第二步中，取出的是第三个数，也就是[1，3，num]，那么显然就有[1，3，2] 再接着我们又会往前想，如果我们在第一步取的是第二个数，然后进行后续的操作。同样的如果第一步是是第三个数呢？ 由图可知，我们每次不重复地从arr中取出一个数进行“固定”，每一次的“固定”都会影响下一次的“固定”的选择。通俗地讲，就是高中学过的排列组合里面的排列，第一次可以有三种选择，第二次有两种选择，第三次只有一种选择。 问题解决：话不多说，先上代码： import java.util.Arrays; public class fullPermutation { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] temp = new int[arr.length]; boolean isVisit[] = new boolean[arr.length]; perm(arr, 0, temp, isVisit); } /** * * @param arr 需要进行全排列的数 * @param index 指向“固定”的位置的指针，值为0时，指向第一个固定位置，也就是temp[0] * @param temp 临时数组，用于存放被“固定”的数 * @param isVisit 用来标记该数是否已经被选择“固定” */ public static void perm(int[] arr, int index, int[] temp, boolean[] isVisit) { if (index==arr.length) {//结束递归条件 System.out.println(Arrays.toString(temp)); return; } for (int i = 0; i &lt; arr.length; i++) {//遍历数组的每个数 if (!isVisit[i]) {//判断数是否被使用，如果未使用则继续后面的操作 temp[index] = arr[i];//将该数插入temp数组 isVisit[i]=true;//将该数标记为已使用 perm(arr, index + 1, temp, isVisit);//开始递归，插入下一个数 isVisit[i] = false;//执行到这一步的时候，说明有一个排列已经打印出来了，这时从后往前将每个数重置为未访问使用 } } } } 人脑在“固定”数时能避开选择重复数，但是计算机本身是不能避开的。那么如何解决这个问题呢？很简单，我们可以给每个数arr[i]“贴上”一个名叫isVisit[i]的布尔值。如果第一次选择到的数，isVisit[i]会被赋值为true，表示该数已被访问使用，再加上一个if（! isVisit[i]）判断，所以在下一次再选择到这个数的时候就会跳过选择【见line 24】 我们可以通过一个index指针来指向“固定（插入）”的位置 用一个temp数组来储存所有全排列的数 for循环遍历所有数组，如果当前数arr[i]对应的isVisit[i]=true，则跳过继续for循环，直到某个数对应的isVisit值为false，将其插入temp 然后开始递归，再回溯，回溯的时候将末尾数的isVisit赋值为false 当index等于temp数组长度时打印temp并return 问题结果：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"复习堆排序","slug":"复习堆排序","date":"2021-03-10T02:00:00.000Z","updated":"2021-03-14T06:43:02.000Z","comments":true,"path":"2021/03/10/复习堆排序/","link":"","permalink":"/2021/03/10/复习堆排序/","excerpt":"","text":"复习堆排序堆的定义：堆是一个具有以下性质的二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称之为大顶堆。反之称之为小顶堆。 那么，在代码中如何表示大小顶堆？arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2]//大顶堆 arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2]//小顶堆 堆排序の思想 先把待排序序列构建成一个大（小）顶堆 这时，整个序列的最大值就是堆顶的根节点（也就是数组的第一个元素） 将其与末尾元素进行交换，此时末尾就是最大值 然后将剩余的n-1个元素重新构造成一个新的堆，这样就得到n-1个元素的次小值，如此反复，就能得到一个有序序列——[重复（1），（2），（3）步骤] 代码实现：import java.util.Arrays; public class heapSort { public static void main(String[] args){ int[] arr={25, 30, 11, 7, 22, 16, 18, 33, 40, 55}; int temp=0; for(int i=arr.length/2-1;i&gt;=0;i--){//从左往右，从下往上寻找非叶子节点进行初始的堆排序 adjustHeap(arr,i, arr.length); } for(int j=arr.length-1;j&gt;=0;j--){//初始堆建成后，首尾的元素进行交换，此时大顶堆的结构被破坏 temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j);//因为是首尾交换所以只有最顶部的结点不符合顶堆的定义，中间的非叶子节点均符合堆顶义，所此时的i等于0，也就是只从顶部开始调整 } System.out.println(&quot;排序后的数组为：&quot;+Arrays.toString(arr)); } /** * * @param arr 待排序数组 * @param i 以i为父节点进行堆排序的树（数组） * @param length 数组长度 */ public static void adjustHeap(int[] arr,int i,int length){ int temp=arr[i]; for(int k=2*i+1;k&lt;length;k=2*k+1){//k指向i的较大的一个子结点 if((k+1&lt;length)&amp;&amp;arr[k]&lt;arr[k+1]){//判断i叶子结点的左右结点的大小，如果左边的小于右边的，则k++ k++; } if(arr[k]&gt;temp){//如果该子结点大于它的父结点，则将该子结点赋值给父节点 arr[i]=arr[k]; i=k;//以k为父节点继续和它的子节点比较 } } arr[i]=temp;//将最开始保存的arr[i]放到末尾 } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机组成原理与汇编语言(持续更新...)","slug":"计算机组成原理与汇编语言","date":"2021-03-05T07:00:00.000Z","updated":"2021-03-17T02:58:34.000Z","comments":true,"path":"2021/03/05/计算机组成原理与汇编语言/","link":"","permalink":"/2021/03/05/计算机组成原理与汇编语言/","excerpt":"","text":"计算机组成原理与汇编语言note①相关概念机器数：数字在计算机中的二进制表达形式，在二进制的最高位存放正或负符号，正数为0，负数为1 真值：带符号位的机器数对应的真正的数值 原码：符号位加上真值的绝对值 反码：正数の反码还是本身，而负数的反码：符号位不变，其余位按位取反 补码：反码+1 那么，为什么要引入反码和补码？ 人脑计算：我们会自动将符号位分开并进行计算 电脑（计算机）计算：因为符号位也是0,1表示，在做计算时，计算机无法辨别哪些是符号位哪些是数值位。如果硬要让计算机认识的话也不是不行，但是这会使计算机的基础电路设计变得异常复杂（这是要累死设计计算机的人- -） 所以我们希望符号位也能参与到运算当中。另外我们都知道CPU只有加法器而没有减法器，这是为什么呢？我们小学就知道，减法是加法的逆运算（减去一个数等于加上那个数的负数），因此只要解决计算机的加法问题就好啦 At First…原码君出来了，但是在运算中很快就发现了问题，比如一个正数和一个负数相加，就会出问题。比如1-1 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [1000_0010]原 = -2 And…出现了原码君的儿子反码君，值得高兴的是，反码能够使得计算结果的真值正确，但是唯独在0这个值上栽了跟头 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原= [0000_0001]反 + [1111_1110]反 = [1111_1111]反 = [1000_0000]原 = -0 0已经能用[0000_0000]原 表示了，现在又整出一个[1000_0000]，没有意义啊这 Finally!原码君的孙子aka反码君的孙子——补码君诞生了，他很完美地解决了这个问题： 1-1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [0000_0001]补 + [1111_1111]补 = [0000_0000]补 =[0000_0000]原 = 0 Besides…除此之外，还可以用 [1000_0000]补 表示-128： (-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补 -1-127的结果应该是-128，在用补码运算的结果中， [1000_0000]补 就代表-128。 注意，-128并没有原码和反码表示。 使用补码不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数，这就是为什么8位二进制使用原码或反码表示的范围为 [-127, +127]，而使用补码表示的范围为 [-128, 127] 的原因。 因为机器使用补码，所以对于编程中常用到的32位int类型可以表示范围是 [-2^31, 2^31-1] ，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。 note②","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"算法分析与设计(持续更新...)","slug":"算法分析与设计","date":"2021-03-03T01:00:00.000Z","updated":"2021-03-14T06:36:48.000Z","comments":true,"path":"2021/03/03/算法分析与设计/","link":"","permalink":"/2021/03/03/算法分析与设计/","excerpt":"","text":"算法分析与设计 chapter①：算法引论定义：解决某种问题的方法 特征：输入，输出，确定性（指令清晰无歧义），有限性（指令执行次数有限） 算法复杂性の分析 时间复杂性：T=T(N[问题规模],I[算法的输入],A[算法本身]) 空间复杂性 ：S=S(N,I) 渐进时间复杂性＝时间复杂度 大O表示法（算法时间运行时间的上界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≤C(g(n))，则称f(n)=O(g(n))，也称f(n)的阶不高于g(n)的阶 大Ω表示法（算法时间运行时间的下界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≥C(g(n))，则称f(n)=Ω(g(n))，也称f(n)的阶不低于g(n)的阶 θ表示法（算法时间运行时间的准确界） C1(g1(n))≤f(n)≤C2(g2(n)) chapter②：递归与分治策略神魔是递归？) 还是…… 从上面的两张图我们可以看出，递归就是自己调用自己的过程。在算法中就是算法自己调用自己，这就是递归算法 很容易知道函数中自身调用自己就成为递归函数 分治（divide&amp;conquer）是乜嘢？凡治众如治寡，分数是也。分治分治，分而治之。大白话就是说把一个规模很大的问题分解成一个个规模较小的子问题，逐个求解，然后子问题的解再“治理”成大问题的最终解 如何使用分治法解决问题？ 解决小规模的问题 分解问题（divide） 递归求解子问题 将所有子问题的解合并为主问题的解 分治?=递归分治是解决问题的一种思想，递归是解决问题的一种方法，也就是说用分治法解决问题的具体实现形式大多是采用递归的方法 有关递归的经典算法实例：汉诺塔问题（略） 整数划分问题问题定义：一个非负正整数都能拆分成若干个数之和或者恰好为自身，比如6这个整数。可以被划分为 6 5+1 4+2 4+1+1 3+3 3+2+1 3+1+1+1 2+2+2 2+2+1+1 2+1+1+1+1 1+1+1+1+1+1 一共有11种划分。并且我们注意到最大的加数是它本身。所以这称为6的划分。如果我们想要得到最大加数≯m的划分个数。比如我们想要最大加数≯5的划分个数，通过上面的表格可以很容易地知道个数是9个，我们用一个函数来表示这个关系f(n,m) 我们很容易知道当n=1时，也就是——————f(1,m)，因为1的划分只能是1，什么你说1+0+0+0+0…不行么，我劝你还是关闭网页吧（bushi） m=1时，——————f(n,1)，也就是说n=(1+1+…+1)[n个1] 当n=m时，从上面的表格可以知道，f(n,n)=1+f(n,n-1)，”1“指的是加数是整数本身时的划分个数，而f(n,n-1)则指的是不包括整数本身的划分个数 当n&gt;m&gt;1时，f(n,m)： 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1); 当划分中包含m时，{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m。此时的划分个数其实就是n-m的划分个数，也就是f(n-m,m) 所以f(n,m)=f(n,m-1)+f(n-m,m)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机网络(持续更新...)","slug":"计算机网络","date":"2021-03-03T00:00:00.000Z","updated":"2021-06-08T09:11:17.466Z","comments":true,"path":"2021/03/03/计算机网络/","link":"","permalink":"/2021/03/03/计算机网络/","excerpt":"","text":"计算机网络注：按照课时进度整理 Part①网络的分类 电信网络：向客户提供电话，电报以及传真等服务 有线电视网络：向用户传送各类电视节目 计算机网络：能允许用户能够在计算机之间传送数据文件 思考：internet和Internet有何区别？ internet指的是互连网，它泛指有多个计算机网络互相连而成的计算机网络（网络的网络）。在这些网络之间的通信协议可以任意选择，不一定非要TCP/IP协议 Internet则是我们经常谈到的互联网（因特网），它是由当前全球最大的、开放的、由众多网络互相连接而成的互连网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。PS：现在的互联网具有三级结构，即主干网、地区网、校园网（企业网） 相关名词：ISP（Internet Service Provider）：互联网服务提供者，也就是提供IP地址，比如我国的三大通信巨头：“移”不动、“联”不通、“信”不过，根据覆盖面积大小和IP数量的不同，ISP又分为：主干ISP、地区ISP、本地ISP 互联网的组成：边缘部分：连接在互联网的所有的端系统（手机端、电脑端、网络摄像头……），通过C/S方式和P2P方式进行通信 核心部分：路由器使用分组交换向边缘部分的端系统提供连通性 啥是分组交换？在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。 分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。 分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。 分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。 Part②计算机网络的分类 按照作用范围分类 广域网（远程网）WAN（Wide Area Network） 城域网MAN（Metropolitan Area Network） 局域网LAN（Local Area Network） 个人局域网PAN（Personal Area Network） 按照网络的使用者分类 公用网（public network） 专用网（private network） 用来把用户接入到互联网的网络 接入网AN（Access Network） 计算机网络的性能七dark指标 1、速率 计算机发送出的信号都是数字形式的。比特（bit）来源于binary digit，意思是一个”二进制数字“，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率。速率的单位是bit/s（比特每秒）（或b/s，有时也写作bps，即bit per second）。 当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的速率。 2、带宽 ”带宽“有以下两种不同的意义： （1）带宽本来指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫兹（或千赫、兆赫、吉赫等），在过去很长的一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号）。因此表示某信道允许通过的信号频带范围就称为该信道的带宽。 3、吞吐量 吞吐量表示在单位时间内通过某个网络的实际数据量。 4、时延 时延是指数据从网络的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或者迟延。 网络中的时延是由一下几个不同的部分组成的： （1）发送时延 发送时延是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做传输时延。发送时延的计算公式是： 发送时延=数据帧长度（bit）/发送速率（bit/s） （2）传播时延 传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是： 传播时延=信道长度（m）/电磁波在信道上大的传播速率（m/s） 电磁波在自由空间的传播速率是光速。即3.0*10^5km/s。 发送时延发生在机器内部的发送器中，与传输信道的长度没有任何关系。传播时延发生在机器外部的传输信道媒体上，而与信道的发送速率无关。信号传送的距离越远，传播时延就越大。 （3）处理时延 主机或路由器在收到分组时需要花费一定时间进行处理，例如分析分组的首部，从分组中提取数据部分、进行差错检验或查找合适的路由等，这就产生了处理时延。 （4）排队时延 分组在进行网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待，在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延无穷大。 这样数据在网络中经历的总时延就是以上四种时延之和：总时延=发送时延+传播时延+处理时延+排队时延。 一般来说，小时延的网络要优于大时延的网络。 5、时延带宽积 把传播时延和带宽相乘，就可以得到：传播时延带宽积，即： 时延带宽积=传播时延*带宽 6、往返时间RTT 在计算机网络中，往返时间RTT是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。 7、利用率 利用率有信道利用率和网络利用率等。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道利用率是零。网络利用率则是全网络 的信道利用率的加权平均值。信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 信道或网络的利用率过高会产生非常大的时延。 计算机网络的非性能 费用（网络设计和实现的费用，简称“网费”【我猜的】） 质量（构件质量） 标准化 … Part③计算机网络分层：分层基本原则 各层之间相互独立，每层只实现一种相对独立的功能 每层之间界面自然清晰，易于理解，相互交流尽可能少 结构上可分隔开，每层都采用最合适的技术来实现 2保持上层对下层的独立性，上层单向使用下层提供的服务 整个分层结构都应该促进标准化工作 OSI参考模型应用层：所有能和用户交互产生网络流量的程序 表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义） 数据格式转换（翻译官） 数据加密解密 数据压缩和恢复（比如，视频聊天） 会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据（建立同步） 建立管理终止会话 使用校验点可以使会话在通信失效时从 校验点恢复继续通信，实现数据同步（适合传输大文件） 传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或者是用户数据报 可靠传输（在发送数据时，发送端必须收到接收端的确认信息才能够进行下一步发送操作），不可靠传输（不用确认，直接发送 ） 差错控制 流量控制 复用（多个应用层进程可同时使用下面的运输层的服务）分用（运输层把收到的信息分别交付给上面应用层中的相应进程） 网络层（IP层）：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报 路由选择 流量控制（协调发送端的发送速度） 差错控制 拥塞控制（若所有节点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞） 数据链路层：把网络层的数据报组装成帧。数据链路层的传输单位是帧 成帧：定义帧的开始和结束 差错控制（帧错+位错） 流量控制 访问控制（控制对信道的访问）—不懂… 物理层：在物理媒体上实现比特流的透明传输，传输单位是比特 定义接口特性 定义传输模式（单工、半双工、双工） 定义传输速率 比特同步 比特编码 不是笔记的笔记chapter① 死记硬背（期末）\\1. 组成一个网络的必要条件：多个具有独立功能的计算机系统、通讯子网、网络软件 \\2. 计算机网络的生产与发展：面向终端的计算机网络阶段、以共享资源为主要目的的计算机网络阶段、标准、开放的计算机网络阶段、高速、智能的计算机网络阶段 \\3. 计算机网络的组成：物理结构：网络软、硬件子系统 逻辑结构：资源子网、通讯子网 \\4. 计算机网络体系结构：是系统、实体、层次、协议的集合，是计算机网络及其部件所应完成功能的精确定义 \\5. 系统：计算机网络构成的系统通常是包括一个或多个实体的具有信息处理和通信功能的物理整体。 \\6. 实体：在网络分层体系结构中，每一层都由一些实体组成。在一个计算机系统中,能完成某一特定功能的进程或程序都可成为一个逻辑实体。实体既可以是软件实体，也可以是硬件实体。 \\7. 层次：是人们对复杂问题的一种处理方法。通常将系统中能提供某种或某类型服务功能的逻辑构造称为层。 \\8. 协议：是指两个实体间完成通信或服务所必须遵循的规则和约定。 \\9. 接口(Interface)，是同一个节点或节点内相邻层之间交换信息的连接点。 \\10. 同等层：不同系统的相同层次。 \\11. 同等层实体(对等实体)：不同系统同等层上的两个正通信的实体。 \\12. 同等层通信：不同系统同等层实体之间存在的通信。 \\13. 同等层(对等)协议：同等层实体之间通信所遵守的规则。各层的协议只对所属层的操作有约束力，而不涉及到其他层。 \\14. 服务：层次结构中各层都支持其上一层进行工作，这种支持就是服务。 \\15. 服务访问点(SAP)：接口上相邻两层实体交换信息的地方。是相邻两层实体的逻辑接口。如N层SAP就是N+1层可以访问N层的地方。 \\16. 服务原语：是指某一层实体向另一层实体报告事件的发生。 \\17. 服务原语主要有4种类型：请求、指示、响应、确认。 \\18. 数据单元：通常将传递数据的每一个单位叫做数据单元。 \\19. 协议数据单元：通常将不同计算机系统的对等层实体之间所交换的数据单位的每一部分称为协议数据单元。 \\20. 服务数据单元：第N层要求第N-1层提供服务时所要传递的数据单元。 \\21. 接口数据单元：在同一系统的相邻两层实体的一次交互中，将传递的参数和返回的结果。 \\22. OSI是Open System Interconnection 的缩写，意为开放系统互联参考模型 \\23. 任何一个通信系统都可以看作是由发送设备、传输信道和接收设备三大部分组成。我们把产生和发送信息的一端称为信源，把接收信息的一端称为信宿，把信源传送到信宿的通信线路称为信道。 \\24. 信息泛指那些通过各种方式传播的、可被感受的声音、文字、图像、符号等所表征的某一特定事物的消息、情报或知识。 \\25. 数据是一种承载信息的实体，是对客观事物的符号表示，在计算机科学中是指所有输入到计算机中并被计算机程序处理的符号的总称。数据分为模拟数据（连续）和数字数据（离散）两种。 \\26. 信号是数据的具体物理表现形式，它具有确定的物理描述,如电信号、光信号或磁场强度等。信号分为模拟信号（连续）和数字信号（离散）两种。 \\27. 模拟信号：是一种连续变化的电信号，例如电话语音信号、电视信号等，它是随时间变化的函数曲线 \\28. 数字信号：是离散的不连续的电脉冲序列, 通常用“高”和“低”电平脉冲序列组成的编码来表示数据。 \\29. 基带信号(Baseband Signal)直接用两种不同的电压表示数字信号1和0，然后将其送到线路上进行传输。因此，一般将对应矩形电脉冲信号的固有频率称为“基带”，将相应的信号称为基带信号 \\30. 宽带信号(Wideband Signal)用多组基带信号和0分别调制不同频率的载波，并由这些分别占用不同频段的调制载波组成。换言之，宽带信号是指将基带信号进行调制后形成的频分复用模拟信号 \\31. 模拟通信系统：普通的电话、广播、电视等信号都属于模拟信号,由模拟信号所构成的通信系统属于模拟通信系统。模拟通信系统通常由信源、调制器、信道、解调器、信宿以及噪声源组成 \\32. 数字通信系统：计算机通信、数字电话以及数字电视等信号都属于数字信号，由数字信号构成的通信系统属于数字通信系统。数字通信系统通常由信源、编码器、信道、解码器、信宿以及噪声源组成 \\33. 数据传输速率：是指每秒钟传输的二进制比特数，又称数据率或比特率，速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等 \\34. 带宽（bandwidth）：本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等），现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s) \\35. 吞吐量（throughout）是指一组特定的数据在特定的时间段经过特定的路径所传输的信息量的实际测量值。 \\36. 码元传输速率：在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称波特率。 \\37. 波特率：是指数据信号对载波的调制速率，用单位时间内载波调制状态改变的次数来表示（也就是每秒调制的符号数），其单位是波特（Baud，symbol/s）。 \\38. 时延（delay 或Latency）：是指一个报文或分组从一个网络（或一条链路）的一端传送到另一端所需的时间。通常来讲，时延是由以下几个不同的部分组成的。 \\39. 数据经历的总时延(delay或latency)就是发送时延、传播时延、处理时延和排队时延之和 \\40. 发送时延：节点在发送数据时使数据块从节点进入传输介质所需要的时间，也就是从数据块的第一个比特开始发送算起，到最后一个比特发送完毕所需的时间。又称为传输时延。 \\41. 传播时延：电磁波在信道上需要传播一定的距离而花费的时间。 \\42. 处理时延：数据在交换节点为存储转发而进行一些必要的处理所花费的时间。 \\43. 排队时延：分组在经过网络传输时，要经过很多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。因此而产生的时延。 \\44. 时延带宽积：是指某一链路所能容纳的比特数。链路的时延带宽积又称为以比特为单位的链路长度。 \\45. 信道利用率：指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。信道利用率并非越高越好。 \\46. 网络利用率则是全网络的信道利用率的加权平均值。 \\47. 误码率：在一定时间内收到的数字信号中发生差错的比特数与同一时间所收到的数字信号的总比特数之比,就叫做“误码率”，也可以叫做“误比特率”。 \\48. 误码率（BER：bit error rate）是衡量数据在规定时间内数据传输精确性的指标。 \\49. 信道：是指以传输介质为基础的信号通路，它可以细分成狭义信道和广义信道。 \\50. 狭义信道：将有信号传输介质的信道称为狭义信道，按照具体介质的不同类型来划分，可细分为：有线信道、无线信道 \\51. 广义信道：根据研究对象和关心问题的不同，广义信道按照其包含的功能通常也可分成两种：调制信道和编码信道。 \\52. 模拟信道：传输模拟信号的信道。 \\53. 数字信道：传输数字信号的信道 \\54. 信道容量：是指信道在单位时间内可以传输的最大信号量，通常用来表示信道的极限传输能力。 \\55. 香农定理：在信号处理和信息理论的相关领域中，通过研究信号在经过一段距离后如何衰减以及一个给定信号能加载多少数据后得到了一个著名的公式，叫做香农（Shannon）定理 \\56. 并行传输是指数据以成组的方式在多个并行信道上传输。 \\57. 串行传输是指数据以串行方式，在一条信道上传输。 \\58. 同步传输（Synchronous）：位同步（包括外同步法、内同步法）字符同步 \\59. 异步传输（asynchronous）：异步传输一次只传输一个字符,每个字符用一位起始位引导、一位停止位结束。 \\60. 基带传输：是一种不搬移基带信号频谱的传输方式。未对载波调制的待传信号称为基带信号，它所占的基本频带称为基带，基带的高限频率与低限频率之比通常远大于1。基带传输广泛用于音频电缆和同轴电缆等传送数字电话信号 \\61. 频带传输：是在计算机网络系统的远程通信中把数字信息调制成模拟信号后再发送和传输，到达接收端时再把模拟信号解调成原来的数字信号的传输技术。 \\62. 数字数据的数字信号编码：就是如何把数字数据用物理信号的波形表示，是用高低电平的不同组合来表示二进制的方法 \\63. 解码： \\64. 数字数据的模拟信号编码： 数字数据的调制基于调幅、调频、调相3种调制技术，分别称为幅移键控、频移键控和相移键控 \\65. 振幅调制（Amplitude modulation，AM）：是以原来的模拟数据为调制信号对载波的幅值按调制信号的幅值进行调制，调制后载波信号的频率和相位不变,幅值随调制信号的幅值变化而变化 \\66. 频率调制（Frequency modulation，FM）：是以原来的模拟数据为调制信号,对载波的频率按调制信号的频率进行调制,调制后载波信号的相位和幅值不变，频率随调制信号的幅值变化而变化 \\67. 相位调制（Phase modulation，PM）：是以原来的模拟数据为调制信号,对载波的相位按调制信号的相位进行调制，调制后载波信号的频率和幅值不变,相位随调制信号的幅值变化而变化 \\68. 模拟数据数字编码的最常用方法是脉冲编码调制（Pulse Code Modulation，PCM)：PCM的工作过程包括3个步骤：采样、量化与编码 \\69. 多路复用：传输信号要求的带宽与传输介质允许通过的带宽是不一样的，为了节省开销，应当充分利用传输介质的带宽。在一条介质上同时传送多于一路以上信号的传输方式，叫做该介质的多路复用。 \\70. 频分多路复用：在物理信道的可用带宽超过单个原始信号所需带宽情况下，可将该物理信道的总带宽分割成若干个与传输单个信号带宽相同的子信道，每个子信道传输一路信号，这就是频分多路复用 \\71. 时分多路复用：时分多路复用（TDM）是将一条物理信道的传输时间划分为若干个时间片，每个用户分得一个时间片，在其占有的时间片内用户使用通信信道的全部带宽。 \\72. 波分多路复用（WDM）：采用的是波长分隔多路复用技术,在同一传输信道内传输多路不同波长的光信号。 \\73. 码分多路复用(CDM)：是一种用于移动通信系统的新技术,笔记本电脑和掌上电脑等移动性计算机的连网通信将会大量使用码分多路复用技术。 \\74. 有线(导向)传输介质：双绞线、同轴电缆、光纤 \\75. 同轴电缆（Coaxial Cable） ：有基带同轴电缆和宽带同轴电缆。 \\76. 物理层的功能：物理连接的建立、维持和释放、物理服务数据单元的传输(传输数据)、完成物理层的一些管理工作 \\77. 物理层4大接口的特性：机械特性、电气特性、功能特性、规程特性 \\78. 集线器（Hub）：主要功能是对接收到的信号进行再生、整形、放大，以扩大网络的传输距离，同时将所有节点集中在以它为中心的节点上。集线器工作在OSI参考模型中的物理层上。集线器与网卡、网线等传输介质一样，属于局域网中的基础设备，采用CSMA/CD访问方式。 \\79. 链路：指的是从一个节点到相邻节点的一段物理线路，并且在这段物理线路的中间，没有任何其他的交换节点。 \\80. 数据链路：当两个节点在一条路径上传输数据时，它们之间除了必须要有一条物理线路以外，还必须要有一些必不可少的通信协议，来控制数据的传输过程。附加了实现这些协议的硬件和软件的链路，才能被称为数据链路。 \\81. 帧同步：又称帧定界，指接收方能从接收到的比特流中准确提取数据帧，准确地区分出一帧的开始和结束位置。 \\82. 差错控制 ：在数据通信中受物理链路性能和网络通信环境等因素的影响，难免会出现一些传送错误。数据链路层主要是通过“差错控制”技术来实现此功能的。 \\83. 链路管理：包括数据链路的建立、维持、释放 \\84. MAC寻址：数据能发送到正确的目的地、接收方知道发送方的地址、由于局域网有多种媒体接入控制，无法采用统一的数据链路层，局域网的数据链路层分为逻辑链路控制和接入链路控制两层。 \\85. 透明传输 ：比特数据的任何组合都能在链路上传输，当数据的比特组合与控制字符相同时，采用相应的处理。 \\86. 数据链路层提供的服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务 \\87. 流量控制：该功能使发送与接收数据同步，是指采用一定技术措施，使通信网络中部分或全部链路，以及节点上的信息流量不超过某限制值，从而来保证信息流动顺畅，避免由于信息流量过大而造成信息拥挤，使信息通过能力下降，甚至造成系统“死锁”的情况发生 \\88. 停止等待ARQ协议：ARQ (Automatic Repeat reQuest)，直译是自动重传请求，但意思是自动请求重传。 \\89. 差错产生的原因：在数据通信中，接收端收到的数据与发送端的数据不一致 \\90. 常用的检错码有：奇偶校验码、循环冗余码、海明码等。 \\91. 纠错码：每个传输的分组带上足够的冗余信息；接收端能发现并自动纠正传输差错。 \\92. 差错控制的常用方法：反馈纠错、前向纠错、混合纠错 \\93. 差错控制的常用编码：奇偶校验码、循环冗余码CRC \\94. 网桥含义：网桥是第2层的设备，它的功能是连接两个或多个LAN分段。其中每一个分段都是一个独立的冲突域。 \\95. 交换机含义：交换机(Switch)也称为交换器或交换式集线器，是专门为计算机之间能够相互通信且独享带宽而设计的一种包交换设备。 \\96. 交换机的帧转发方式：存储式转发、直通式转发、无碎片式转发 \\97. 交换机的交换技术：端口交换技术、帧交换技术、信元交换技术 \\98. 局域网（Local Area Network，简称LAN）通常是指在某一区域内由多台计算机互连而成的计算机组。局域网可由一间办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 \\99. 局域网系统主要由局域网硬件系统和局域网软件系统这两部分组成。 \\100. 局域网的性能：拓扑结构、传输介质（同轴电缆、双绞线、光纤、电磁波等）、介质访问控制方法 \\101. 局域网的拓扑结构：星形网、环形网、总线网、树形网 \\102. 局域网的类型：共享介质局域网、交换式局域网 \\103. 局域网的网络模式：客户机/服务器模式（Client/Server，C/S）、浏览器/服务器模式、对等服务器网络模式 \\104. 局域网参考模型：局域网的体系结构只包含了数据链路层和物理层，其中，数据链路层又分为逻辑链路控制和介质访问控制两个子层。 \\105. 802.1：A定义了局域网体系结构;B定义了网络互连、网络管理与性能测试 \\106. 802.2：定义了局域网逻辑链路控制LLC子层的功能与服务 \\107. 802.3：定义了局域网CSMA/CD总线介质访问控制子层及物理层规范 \\108. 802.11：定义了无线局域网访问方法和物理层规范 \\109. 介质访问控制方法概念：将传输介质的频带有效地分配给网络上各结点的方法称为介质访问控制方法 \\110. IEEE 802规定了多种局域网媒体介质访问方法：适合总线结构的带冲突检测的载波监听多路访问（CSMA/CD）方法、适合环型结构的令牌总线（Token Bus）方法、适合环型结构的令牌环（Token Ring）方法 \\111. ALOHA系统最初是在无线电信道上实现的。纯ALOHA可以工作在无线信道，也可以工作在总线式网络中 \\112. CSMA：载波监听多点接入CSMA（Carrier Sense Multiple Access）又称载波侦听多路访问，CSMA协议与ALOHA的主要区别就是多了一个载波监听装置，其功能为发送前监听 \\113. CSMA协议的类型：非坚持CSMA、1-坚持CSMA、p-坚持CSMA \\114. 冲突：在信道上可能有两个或更多的设备在同一瞬间都发送帧，从而在信道上因造成帧的重叠而出现差错，这种现象称为冲突 \\115. CSMA/CD接收过程：网上每个站点平时都在监听总线，如果有信息帧到来，则接收信息帧；然后再分析和判断信息帧中的接收端地址，如果该地址为本站地址，则复制接收该帧；否则，简单丢弃该帧。 \\116. 常用的以太网MAC帧格式有两种标准：DIX Ethernet V2标准、IEEE802.3标准 \\117. 以太网数据封装格式：以太网IP数据报的封装在RFC 894中进行了详细的定义，IEEE 802网络的IP数据报封装则是在R.FC1042中定义 \\118. 以太网地址：单播地址(Unicast Address)、多播地址(Multicast Address)、广播地址(Broadcast Address) \\119. 10BASE-T中的T指双绞线，10BASE-5指传输距离500米(即粗缆) IEEE标准共有以下几种: l 10BASE-5：粗缆。最大传输距离500米，使用AUI连接器连接或使用收发器电缆和收发器(MAU)进行连接。 l 10BASE-2：细缆。实际传输距离为185米，使用BNC连接器(T型和N型)。 l 10BASE-T：双绞线。传输距离100米，使用RJ45连接器。 l 10BASE-F：光纤。分为FP，FL，FB 三种链接类型，FP使用无源集线器连接，传输距离500米，FB使用有源连接器，传输距离3000米，FL可以使用多个中继器，可以进一步延长器传输距离。 l 100BASE-TX：双绞线，使用两对非屏蔽双绞线或两对1类屏蔽双绞线连接，传输距离100米 l 100BASE-T4：4对3类非屏蔽双绞线，传输距离100米 l 100BASE-F： 单模或多模光纤，传输距离2000米左右 l 1000BASE-T：5类非屏蔽双绞线，传输距离100米 l 1000BASE-CX：屏蔽类双绞线，传输距离25-50米 l 1000BASE-LX：单模光纤，传输距离5000米/多模光纤，传输距离316-550米 l 1000BASE-SX：多模光纤，连接光纤使用SC型光纤连接器，传输距离275米至550米 \\120. 10Gbit/s万兆以太网，目标在于：扩展以太网，使其能够超越LAN，以进入WAN和MAN \\121. VLAN的概念：虚拟局域网，即VLAN (Virtual Local Area Network)。它是一种把局域网设备从逻辑上划分成更小的局域网，从而实现虚拟工作组的数据交换技术。 \\122. 802.1Q标准：通用标准，基于IEEE 802.1Q附加的VLAN信息，就像在传递物品时附加的标签。因此，它也被称作“标签型VLAN(Tagging VLAN)”。 \\123. ISL( Inner Switch Link)：专用标准，是Cisco特有的标记方法，只有Cisco的设备才可以理解ISL封装的数据帧 \\124. VLAN链路类型：接入链路(Access Link)、干道链路(Trunk Link)、混合(hybrid)链路 \\125. 令牌环网工作流程：截获令牌并且发送数据帧、接收与转发数据、取消数据帧并且重发令牌 \\126. 令牌总线网的工作原理：截获令牌、地址转载、令牌转发 \\127. 局域网的扩展：利用集线器/交换机进行扩展 \\128. 交换式以太网的主要特点：兼顾性、兼容性、易用性、灵活性、支持性 \\129. 无线局域网(Wireless Local-Area Network，WLAN)也称Radio LAN，就像其名字所描述的一样：它挣脱了传统线缆束缚，提供了以太网或者令牌网络的功能 \\130. WLAN的主要类型：红外局域网、扩频无线局域网、窄带微波无线局域网 \\131. IEEE802.11a扩充了标准的物理层，它工作在5.0GHz频带，传输速率为5Mb/s、11Mb/s和54Mb/s，采用正交频分多路复用(OFDM) 技术。 \\132. IEEE802.11b标准工作在2.4GHz频带，采用DSSS扩频技术和补偿编码键控(CCK)调制方式。传输速率为1Mb/s、2Mb/s、5.5Mb/s和11Mb/s。 \\133. IEEE802.11g标准工作在2.4GHz频带，采用正交频分多路复用(OFDM) 技术，速率可达54Mb/s \\134. 无线局域网的组成：有固定基础设施的无线局域网(Infrastructure工作模式)、无固定基础设施的无线局域网(Ad-hoc工作模式) \\135. WLAN的体系结构：IEEE802.11标准中的物理层、IEEE802.11标准中的MAC子层 \\136. 无线局域网中的复杂性问题：具体可分为隐蔽站问题和暴露站问题。 \\137. WLAN的介质访问控制方式：分布控制方式、中心控制方式 \\138. WLAN的组建方式：无线网络网卡、无线网络Hub、无线网络网桥 \\139. 网络层的功能：主要功能是提供路由，选择到达目标主机的最佳路径，并沿该路径传送数据包。其它功能:消除网络拥塞、流量控制、拥塞控制、建立和拆除网络连接、多路复用、分段和组块、服务选择和传输等功能。 \\140. 网络层提供的两种服务：面向连接服务、无连接服务 \\141. 面向连接服务类似于电话系统，而无连接服务则类似于邮政系统 \\142. IP 地址的编址方法：分类的 IP 地址、子网的划分、构成超网。 \\143. 特殊IP地址和专用IP地址：广播地址、有限广播地址、 “0”地址、回送地址 \\144. 子网划分原因：IP 地址空间的利用率有时很低、给每一个物理网络分配一个网络号会使每个网络中的主机数太大，因而使网络性能变坏。两级的 IP 地址不够灵活。 \\145. 掩码：掩码(NetMask)有网络掩码和子网掩码两种 \\146. IP 层转发分组的流程：直接交付和间接交付、使用子网掩码的分组转发 \\147. 网络地址转换类型：静态NAT、动态地址NAT、NAPT \\148. 地址解析协议ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题 \\149. 逆地址解析协议 RARP：使只知道自己硬件地址的主机能够知道其 IP 地址 \\150. DHCP (Dynamic Host Configuration Protocol):动态主机配置协议，l 工作在客户机/服务器(C/S)模式下，包括DHCP服务器和DHCP客户端两个角色，主要提供IP地址、默认网关、子网掩码的信息 \\151. DHCP的工作流程分为四步，分别是客户端请求IP、服务器响应、客户端选择IP、服务器确认IP租约。 \\152. 网际控制报文协议 ICMP(Internet Control Message Protocol)作用：为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 \\153. ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 \\154. ICMP 不是高层协议，而是 IP 层的协议。 \\155. ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。 \\156. 路由选择的不同策略：静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化；动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 \\157. 距离矢量路由选择算法是让每个路由器维护一张表(即向量)，表中给出了到每个目的地已知的最佳距离和路线。通过与相邻路由器交换信息来更新表的信息。距离矢量路由选择算法也被称为Bellman-Ford路由选择算法和Ford-Fulkerson算法，即RIP算法。 \\158. 最常见的距离矢量路由协议主要有：路由信息协议 (Routing Information Protocol,RIP)、内部网关路由协议 (Interior Gateway Routing Protocol,IGRP)等。 \\159. 自治系统AS(Autonomous System)的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS 之间的路由选择协议用以确定分组在AS之间的路由。 \\160. 内部网关协议 IGP (Interior Gateway Protocol) 即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。 \\161. 外部网关协议EGP (External Gateway Protocol) 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。 \\162. 因特网的路由选择协议 ² 内部网关协议 IGP：具体的协议有多种，如 RIP 和 OSPF 等。 ² 外部网关协议 EGP：目前使用的协议就是 BGP。 \\163. 内部网关协议RIP (Routing Information Protocol)：RIP 是一种分布式的基于距离向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 \\164. 内部网关协议OSPF （Open Shortest Path First开放最短路径优先）是分布式的链路状态协议。 \\165. OSPF的区域：为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。 \\166. OSPF三个要点 ① 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 ② 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 ③ 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 \\167. 内部网关路由协议(Interior Gateway Routing Protocol，IGRP)是一种在自治系统中提供路由选择功能的思科专有路由协议。 \\168. IGRP是一种距离矢量内部网关协议(IGP)。增强的内部网关路由选择协议(Enhanced Interior Gateway Routing Protocol，EIGRP)是增强版的IGRP。 \\169. 外部网关协议 BGP：是不同自治系统的路由器之间交换路由信息的协议，它只传输路径信息。BGP 较新版本是BGP-4（BGP 第 4 个版本） \\170. xxxxxxxxxxxxxxxxxxxxxxxxxxxxx \\171. 路由器主要有以下几种功能：网络互联功能、数据处理功能、网络管理功能 \\172. 直接交付和间接交付：互联网络中路由器转发IP分组的物理传输过程与数据报转发交付机制称为分组交付，分组交付可以分为直接交付和间接交付两类。当分组的源主机和目的主机是在同一个网络，或转发是在最后一个路由器与目的主机之间时将直接交付。如果目的主机与源主机不在同一个网络上，分组将间接交付 \\173. 路由器的结构：路由选择部分和分组转发部分；分组转发部分，由三部分组成：交换结构、一组输入端口和一组输出端口 \\174. 路由器交换结构：通过总线进行交换、通过纵横交换结构进行交换、共享存储器 \\175. 路由工作原理:p227 \\176. 路由表类型：静态路由表、动态路由表 \\177. 路由表项包括：目的网络前缀、子网掩码、下一跳字段 \\178. 路由表项的类型：网络路由、主路由、默认路由 \\179. 路由表结构：网络ID 、转发地址 、接口 、跃点数 \\180. IPv6地址主要有：单点传送、多点传送、任意点传送三种类型，它们也分别被称为单播地址、组播地址和泛播地址。 \\181. 单点传送地址是一个单接口标识符，送往单点传送地址的包将会被传送到该地址所标识的接口上。 \\182. 任意点传送地址是一组接口的标识符。送往某个任意点传送地址的包将会被传送到该地址所标识的一组接口中距离源节点最近（根据使用的路由协议进行度量）的一个接口上。 \\183. 多点传送地址是一组接口的标识符。送往某个多点传送地址的包将会被传送到该地址所标识的所有接口上。 \\184. 从 IPv4 向 IPv6 过渡：双协议栈(dual stack)、隧道(Tunneling)技术、NAT-PT (Network Address Translation-Protocol Translation，附带协议转换的网络地址转换) \\185. 端口：当一个应用程序(比如一个用户)进程想和远程的一个应用程序进程建立连接时，它必须指定是与哪个应用程序进程相连。正常采取的方法是定义进程能够侦听连接请求的传输地址。在因特网中，这些端点被称作端口(port)。 \\186. TSAP (Transport Service Access Point，传输服务访问点)。网络层中类似的端点(即网络层地址)则被称为NSAP。 IP地址就是NSAP的一个例子 \\187. 传输实体建立连接的方法：三次握手(three-way handshake)方法。 \\188. 释放传输连接：三次握手释放连接 \\189. 终止连接的方式：非对称释放和对称释放 \\190. 非对称释放是电话系统的工作方式：当一方挂机时，连接即告中断。 \\191. 对称释放把连接当做两个独立的单向连接处理，要求每一方单独释放连接。 \\192. 流量控制和缓冲：总结来说，对于低带宽流量，在发送方缓存比较好；对于高带宽流量的稳定传输，在接收方缓存比较好 \\193. TCP/IP的传输层有两个不同的协议：用户数据报协议(UDP)；传输控制协议(TCP)。 l 区别 ² UDP在传送数据之前不需要建立连接，即提供无连接的服务。此外，UDP不提供广播或者多播服务。 ² TCP则提供面向连接的服务，在传送数据之前必须先建立连接。TCP也不提供广播或者多播服务。 \\194. 用户数据报协议（UDP）概述：传输层协议需要具备以下功能：一是创建进程到进程的通信；二是在传输层提供控制机制 \\195. ＵＤＰ端口分配方法：客户进程的端口号分配、服务器进程的端口号分配 \\196. 套接字地址：UDP需要两个标识符，IP地址和端口号，它们各用在一端以建立一条连接。一个IP地址与一个端口号合起来就叫做套接字地址或插口地址。 \\197. 要使用UDP的服务，需要一对套接字地址：客户套接字地址和服务器套接字地址。 \\198. TCP是一种面向连接的、可靠的传输层协议。TCP协议向应用层用户进程提供可靠性、全双工的数据流传输 \\199. TCP数据编号与确认：TCP是面向字节的；在连接建立时，双方要商定初始序号；TCP的确认是对接收到的数据的最高序号表示确认 \\200. TCP流量控制：TCP协议是面向字节的。TCP将要传送的报文段看成是字节组成的数据流 \\201. 发送缓存与接收缓存：TCP需要缓存来存储数据。在每一个方向都有两个缓存，即发送缓存与接收缓存 \\202. 糊涂窗口综合征： 发送端产生的症状解决的方法是防止发送端TCP逐个字节地发送数据。必须强迫发送端TCP等待，让它收集数据，以便发送大块数据；接收端产生的症状解决方法。(1)Clark解决方法。(2)延迟的确认 \\203. TCP拥塞控制：加速递减策略、慢启动 \\204. 按照通信过程中，双方的地位是否相等，可以把网络应用模式分为：客户/服务器 (C/S ，Client/Server)模式、对等模式 (P2P，Peer to Peer)模式 \\205. P2P是Peer-to-Peer的缩写，称为对等网，强调系统中节点之间的对等关系， P2P网络强调节点地位的对等性。P2P中对等点之间的位置关系是逻辑意义上的。 \\206. 域名服务：在网络上辨别一台计算机的方式是利用IP，但是一组IP数字很不容易记，且没有什么联想的意义，因此，为网络上的服务器取一个有意义又容易记的名字，这个名字就叫域名(Domain Name)。 \\207. 域名：在TCP/IP中实现的这种层次型命名管理机制称为域名系统 \\208. TCP/IP域名系统包括概念上相互独立的两个层面。其中，一个层面是抽象层面，它规定命名语法以及域名管理特权的分派规则；另一个层面是具体层面，它描述如何具体实现从域名到IP地址的高效率映射。 \\209. 了解DNS服务器两种查询方式：迭代查询和递归查询 \\210. 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的传输服务 \\211. FTP 使用客户机/服务器模式工作 \\212. 一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。 \\213. FTP用户登录的类型：匿名访问、凭用户名和密码 \\214. 简单文件传输协议(Trivial File Transfer Protocol, TFTP)最初是打算用于引导无盘系统(通常是工作站或X终端), 所以它使用的是UDP而不是TCP来进行文件传输，以保证算法简单。 \\215. TFTP报文不提供用户名和口令，这是因为TFTP被设计用于系统引导进程，它不可能提供用户名和口令。 \\216. 端口号：TFTP服务器使用UDP端口69 \\217. 远程登录协议Telnet用途：简单地说，远程登录是指用户使用Telnet命令，使自己的计算机暂时成为远程主机的一个仿真终端这样一个过程。 \\218. Telnet远程登录服务实际上将用户用来登录的计算机当作一个输入终端，而将要登录的远程计算机或者远程主机作为具有快速处理能力的主机 \\219. 电子邮件系统具有三个主要组成部件： 用户代理(user agent)、 邮件服务器、电子邮件使用的协议 \\220. 电子邮件格式：由信封(envelope)和内容(content)两部分组成。 \\221. 电子邮件的相关协议：邮件读取协议 POP 或 IMAP 、邮件传送协议 SMTP \\222. 浏览器/服务器模式（B/S模式）：浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器；客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 \\223. 页面(page)：在一个客户程序主窗口上显示出的万维网文档称为页面 \\224. 超链接 \\225. 超文本文档 \\226. 统一资源定位符 URL（Uniform Resource Locator)：使用统一资源定位符 URL来标志万维网上的各种文档 \\227. 超文本传送协议 HTTP (HyperText Transfer Protocol)：在万维网客户程序与万维网服务器程序之间进行交互所使用的协议 \\228. HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 \\229. 超文本标记语言 HTML \\230. 动态主机配置协议 DHCP含义：动态主机配置协议 (Dynamic Host Configuration Protocol， DHCP ) 提供了即插即用连网(plug-and-play networking)的机制。 \\231. DHCP具有以下特点：安全而可靠的配置、集中管理、节省IP \\232. 作用域：是一个网络中的所有可分配的IP地址的连续范围。主要用来定义网络中单一的物理子网的IP地址范围。 \\233. 超级作用域：是一组作用域的集合，它用来实现同一个物理子网中包含多个逻辑IP子网。 \\234. 排除范围：是不用于分配的IP地址序列。 \\235. 地址池：在用户定义了DHCP作用域及排除范围后，剩余的地址构成了一个地址池，地址池中的地址可以动态地分配给网络中的客户使用。 \\236. 租用期(lease period)：DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 \\237. 保留地址：用户可以利用保留地址创建一个永久的地址租用期。保留地址保证子网中的指定硬件设备使用同一个IP地址。 \\238. DHCP 工作时使用客户/服务器方式","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"蛋疼のNode学习之路(持续更新...)","slug":"蛋疼のNode学习之路","date":"2021-02-01T23:00:00.000Z","updated":"2021-03-14T06:39:40.000Z","comments":true,"path":"2021/02/02/蛋疼のNode学习之路/","link":"","permalink":"/2021/02/02/蛋疼のNode学习之路/","excerpt":"","text":"蛋疼のNode学习之路（持续更新…）Day1Previously on ‘Preface’，对于一个几乎零基础的我来说，搭建博客的过程是十分痛苦的，这现在只是一个简单的修改博客主题和编辑的过程啊（前端知识盲区o(╥﹏╥)o）。所以我决定花上一定时间来学习Node.js。希望学完之后我能更好的运维我的BLog（顺便复【yu】习一下Web相关知识，HTML5，CSS3，JavaScript什么的都快忘光光啦）话不多说，今天开始第一天的学习！ ①那么，Node.js是乜嘢？（what？）解释： 不是一门语言，不是库，不是框架。而是一个js的运行时 ，通俗地说就是能够一个能够运行js的平台环境。 可提供服务器级别的api（需要引入相关的模块，比如文件读写需要’fs’，也就是File-System）：文件读写，网络服务构建，网络通信，http服务器（http模块）……//后面会讲模块系统 特性： 事件驱动 非阻塞IO模型（异步）————————————-啊啥是同步和异步？，又要去恶补了o((⊙﹏⊙))o 轻量和高效 与Node.js相关的东东npm：全称是Node Package Manager。世界上最大的开源生态系统（大多数的js相关的包都在npm里）可在命令行通过下列语法获取相关包 npm install [jquery] ②Node.js能干啥哇？（do what？） web服务器后台（能干类似活的有Java,，PHP，Python，balabala…….） 命令行工具 npm git hexo （这个我熟哈哈） ③参考资源（resource） 《深入浅出Node.js》（偏理论） 《Node.js权威指南》 JavaScript标准参考教程（alpha）作者：阮一峰（惊了，英文名也叫Frank） Node入门（fen） cNode社区 ④安装Node（install）会的都会，不会的戳一戳下面的教程： 参考教程：https://www.runoob.com/nodejs/nodejs-install-setup.html ⑤模块系统（Module system） 在Node中，每一个js文件都是一个模块，另外Node中也没有全局作用域的概念。 在Node中，只能通过require()方法加载js文件。 require()方法只加载其中的代码。既然没有全局作用域，那么各个js文件之间是模块作用域。 模块全封闭。 外部和内部之间是无法互相访问的。 其实每个模块中有都一个exports专属的对象，该对象中可以封装各自模块中的数据和方法，方便其他模块应用 举个例子 var demo =require(&#39;./a&#39;)//调用模板a，并且获得a的exports对象,并且用一个变量demo接收 ——————-分割线，下面进入简单的实操环节——————– 启动一个简单服务器 var http = require(&#39;http&#39;)//创建http对象 var server = http.createServer()//利用http对象创建一个服务器对象server server.listen(4000, function () {//选择端口 console.log(&quot;贪玩蓝月服务器，琦动！&quot;) }) server.on(&#39;request&#39;, function (request, response) {//server监听是否收到客户端发送过来的request，收到后根据回调函数再返回响应 console.log(&quot;收到请求&quot;) response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;})//&lt;-----------解决乱码的方法 var url = request.url if (url == &#39;/&#39;) { response.end(&quot;欢迎来到贪玩蓝月，是兄弟就来砍我&quot;) } else if(url==&#39;/login&#39;){ response.end(&quot;貪玩藍月登錄註冊界面...&quot;) } else if(url==&#39;/register&#39;){ response.end(&quot;快進到貪玩藍月の註冊界面&quot;) } else{ response.end(&quot;404 not found...&quot;) } }) 但是第一次运行的时候出现这种情况……. 不用慌，在回调函数里的第一行加上 response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;}) 运行后的截图 当然一个网站肯定不能只是傻傻地响应同一段内容，服务器必须根据浏览器(客户端)发来的请求信息来对应地响应合适的内容。 实现方法也特别简单，加入一组if-else的判断就可。（详情见上代码line10-21） 实现效果： And: 2.模块系统 解释：在demo中引入模板a—&gt;执行a的代码，在控制台打印starting语句—&gt;引入模板b—&gt;打印模板b的opening和closed—&gt;a中的引用结束，打印a的end—&gt;打印从a模板获取的值foo=200 从中我们发现输出的foo值是模板a中的，而不是b模板中的。这也体现了模块作用域的好处：可以加载执行多个文件，可以完全避免变量命名而产生的冲突（认真脸） ⑥相关知识补充 同步（Synchronous） A程序调用B程序，必须等待B程序完成才能返回到A程序，A程序继续执行……从流程上看是一条”直线“ 异步（Asynchronous） A程序调用B程序，此时A不会等待B程序是否执行完毕，而是继续往后执行自己的代码……从流程上看是出现了一条从主线产生的“支线” 回调函数 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（来自谷歌的解释） 通俗讲就是 ①你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 什么还不懂？行，还有个例子：②约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。~（单身的看例子①就好了） Day2 今天主要围绕模板引擎的概念以及应用方式、渲染这两点展开，并且相对应地结合两个小案例来更进一步的理解感受它们。话不多少，先介绍主要概念。 神么是模板引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。这就好比于我们的写作模板，我们想写什么类型的文章比如说明文，记叙文，抒情文，应用文。它们都有固定的一套模式，我们只要按照这套模式来，往里面添加我们自己的内容即可。 常用模板：art-template（art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。） 安装方法： npm install art-template --save 啥是渲染？在电脑绘图中，渲染是指在指用软件从模型生成图像的过程。而在HTML中则是指如何加工并且显示出最终的HTML页面。我们又根据加工场景位置的不同把HTML渲染分为服务端渲染和客户端渲染。 互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时ajax的兴起，使得业界就开始推崇前后端分离的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的客户端渲染了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。 服务端渲染aka后端渲染（service-side render）の优缺点： 优点 减轻前端压力 不用占用前端的资源，比如在用手机浏览网页时，浏览器的负担减轻，因此能够节省手机的电量 有利于SEO（Search Engine Optimization）搜索引擎优化。爬虫能够爬取到在后端的HTML文档 缺点 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则前端一般就是写一个静态html文件，然后后端再修改为模板，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； 或者是前端直接完成html模板，然后交由后端。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。 占用服务器端资源。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。 客户端渲染aka前端渲染（client-side render）的优缺点： 艾达王替矩（advantages）： 前后端分离，前端能够自定义UI而不用去过度依赖后端 diss艾达王替矩： 前端的响应速度会变慢，这就是为什么我们在浏览一些网页时，经常会“爱的魔力转圈圈”。（后端的渲染速度要比前端的快） 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。因为服务器端可能没有保存完整的html，而是前端通过js进行dom的拼接，那么爬虫无法爬取信息。 除非搜索引擎的seo可以增加对于JavaScript的爬取能力，这才能保证seo。 小案例一：模拟Apacheの目录HTML（服务端渲染）在此之前我们还需要用到fs模块的readFile()和readdir()方法，简单介绍一下这两个方法： readFile()：能够读取指定路径下的文件并保存到data中，data是一个二进制的数据流（里面全是010101），因此要将其转变为我们认识的字符串需要用到toString()方法。 readdir()： 读取指定目录下的所有文件夹名，并返回一个由这些文件夹名构成的字符串数组files。 var fs = require(&#39;fs&#39;); fs.readdir(&#39;readdirtest&#39;, function(err,files){ if(err){ console.log(err); } console.log(files); }) 操作描述： 加载必要的模块fs，http… 设置端口号xxxx 为服务器设置响应信息 读取模板文件template.html（目录显示页），并且将要替换的区域使用特殊符号进行标记，这里我使用了-.-这个标记 读取目录列表的所有文件夹 并将要替换的部分用一个变量content表示 用forEach方法依次取出files里的文件夹名并构建content（见代码20—24） 将第一步读取的data转换为字符串 简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 发送响应 下面是一小段代码： var fs = require(&#39;fs&#39;) var http = require(&#39;http&#39;) var server = http.createServer() var wwwDir = &#39;F:/www&#39; server.on(&#39;request&#39;, function (req, res) { fs.readFile(&#39;./template.html&#39;, function (err, data) {//获得模板template.html if (err) { console.log(&#39;找不到文件......请重试&#39;) } fs.readdir(wwwDir, function (err, files) {//得到wwwDir的目录列表中的文件名和目录名 if (err) { return console.log(&#39;读取目录失败&#39;) } console.log(files)//files是一个字符数组，元素为目录中的文件名 var content = &#39;&#39;//将模板中要替换的部分构建为content files.forEach(function (item) {//利用forEach，取出files数组的每个元素（item），进行渲染${item}替换 content += `&lt;tr&gt;&lt;td data-value=&quot;新建 Microsoft Word 文档.docx&quot;&gt;&lt;a class=&quot;icon file&quot; draggable=&quot;true&quot; href=&quot;/F:/www/%E6%96%B0%E5%BB%BA%20Microsoft%20Word%20%E6%96%87%E6%A1%A3.docx&quot;&gt;${item}&lt;/a&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;0 B&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1612679895&quot;&gt;2021/2/7 下午2:38:15&lt;/td&gt; &lt;/tr&gt;` }) data = data.toString()//将二进制流的data转换为字符串 data=data.replace(&#39;-.-&#39;, content)//简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 res.end(data)//发送响应数据 }) }) }) server.listen(4001, function () { console.log(&#39;服务器，琦动！&#39;) }) 结果截图： 小案例二：art-template需要一个用于储存模板的html和一个js文件 html模板: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;This is Frank&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is {{ name }}.&lt;/p&gt; &lt;p&gt;I am {{ age }} years old.&lt;/p&gt; &lt;p&gt;I am from {{ province }}.&lt;/p&gt; &lt;p&gt;I like {{ each hobbies }} {{ $value }} {{/each}}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果没有art-template，运行结果如下： 加了art-template后： var fs=require(&#39;fs&#39;) var http=require(&#39;http&#39;) var template=require(&#39;art-template&#39;) http .createServer(function(req,res){ var url=req.url if(url===&#39;/&#39;){ fs.readFile(&#39;./Frank.html&#39;,function(err,data){ if(err){ return res.end(&#39;你访问的网址不存在噢&#39;) } data=data.toString() var Frank=template.render(data,{ name:&#39;Frank&#39;, age:20, province:&#39;ChongQing&#39;, hobbies:[&#39;打篮球&#39;,&#39;写博客&#39;,&#39;吹水&#39;] }) res.end(data) }) } }) .listen(3000,function(){ console.log(&#39;琦动！&#39;) 由此可见，art-template只关注中的值，不会去关心html中的格式。因此可以理解为js数据传到html中展示出来 Day3Node中的模块系统模块の定义： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。 使用Node编写应用程序主要就是在使用： Ecmascript 核心模块 文件操作fs http服务的http url路径操作的模块 path路径处理模块 os操作系统模块 第三方模块 art-template 必须通过npm下载 开发者自个儿写的模块（自定义的） 模块化 文件作用域 通信规则 加载require 导出CommonJs模块规范 这就是要谈论的——模 块 系 统 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员 加载require操作： var 自定义变量名称=require(&#39;模块&#39;) 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有成员只在当前文件模块有效 如果我们想要访问其他模块的成员，可以把这些成员加载到exports上去 导出多个成员： exports.demo=foo exports.test=&#39;233&#39; exports.fun=function(){ xxxxxxxxxxxxx } 也可以这样导出多个成员： module.exports={ add: function(){ return xxxxxxx }, foo:&#39;123&#39; } 导出单个成员（指定的）： module.exports=&#39;666&#39; module.exports=function(){ } 注意：在使用module.exports时，后一个的会覆盖前一个的module.exports 原理在底层代码中：exports是module.exports的一个引用—&gt;exports=module.exports console.log(exports===module.exports)//会返回true exports.foo=&#39;666&#39; module.exports.foo=&#39;666&#39;//等价 require方法加载规则 核心模块 模块名 第三方模块 模块名 开发者自己写的 路径 优先从缓存加载 加载过的模块会暂存入缓存中，若下次还有调用，直接从缓存中读取， 能有效提高模块加载效率 package.json每一个项目最好有一个包描述文件（package.json，就像产品的说明书）。可通过npm init生成 。有了该文件，再用npm install就能把文件里的依赖项全部下载回来，就相当于原先有了备份，现在进行备份还原 在每个项目的根目录下应该有一个package.json文件 每次安装第三方包时，应该在后面加上–save`，可以用来保存依赖项信息 npm [npm网站]: npmjs.com 命令行工具 npm install --global npm//更新命令 常用命令 npm init -y//快速生成package.json文件 npm install npm install 包名//下载指定包 npm install --save 包名//下载指定包并保存到package.json的dependencies中 npm uninstall 包名 npm help//查看使用帮助 npm 命令 --help//查看指定命令的使用帮助 如何解决npm被墙的问题 安装淘宝的cnpm： npm install --global cnpm//--global表示安装到全局，不能省略。以后就能用cnpm代替npm了 如果不想安装cnpm但是又想用淘宝的服务器下载，可以通过: npm config set registry https://registry.npm.taobao.org//默认使用淘宝服务器下载 Express一种Web开发框架 npm install express --save//安装express 拿到框架的第一步当然是Hello World！ var express=require(&#39;express&#39;) var app=express()//相当于以前的server对象 app.listen(3000,function(){ console.log(&#39;服务器，琦动&#39;) }) app.get(&#39;/&#39;,function(req,res){//以get方法请求&#39;/&#39;，并执行对应的处理函数 res.send(&#39;Hello World!&#39;) }) 静态服务（静态 资源获取）// 开放静态资源 // 1.当以/public/开头的时候，去./public/目录中找对应资源 // 访问：http://127.0.0.1:3000/public/login.html app.use(&#39;/public/&#39;,express.static(&#39;./public/&#39;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问 // 访问：http://127.0.0.1:3000/login.html // app.use(express.static(&#39;./public/&#39;)); // 3.访问：http://127.0.0.1:3000/a/login.html // a相当于public的别名 // app.use(&#39;/a/&#39;,express.static(&#39;./public/&#39;)); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 // 通过requery方法获取用户输入的数据 // req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） var express = require(&#39;express&#39;) // 引包 var bodyParser = require(&#39;body-parser&#39;) var app = express() // 配置body-parser // 只要加入这个配置，则在req请求对象上会多出来一个属性：body // 也就是说可以直接通过req.body来获取表单post请求数据 // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })) // parse application/json app.use(bodyParser.json()) 使用： app.use(function (req, res) { res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;) res.write(&#39;you posted:\\n&#39;) // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2)) }) 在express中配合和使用art-template安装： npm install --svae art-template npm install --save express-art-template 配置： app.engine(&#39;html&#39;,require(&#39;express-art-template&#39;))//第一个参数表示渲染以art结尾的文件 使用： app.get(&#39;/&#39;,function(req,res){ //express默认会从项目的views目录去寻找index.html res.render(&#39;index.html&#39;,{ title:&#39;hello world&#39; }) }) 如果希望修改视图渲染的目录（原本是views），可： app.set(&#39;views&#39;,目录路径) CRUD(待更…)其他项①修改完代码自动重启以前每次修改完代码都要傻乎乎地去node xxx.js现在有了nodemon这一个第三方命令行工具，就能解决这一问题。 安装方法，懂得都懂 npm install nodemon --global ②封装异步API回调函数：获取异步操作的结果 function fn(callback){ // var callback = funtion(data){ console.log(data); } setTimeout(function(){ var data = &#39;hello&#39;; callback(data); },1000); } // 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取 fn(function(data){ console.log(data); }) ③关于json文件格式の坑json文件格式要求极其严格，比如 致命错误在：id为5的一行末尾的逗号，一定要去掉！！！结尾的一个花括号不能有逗号（就这个错误折磨了我半个小时……） 小项目一个简单的表单提交网站 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: /** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */ var fs = require(&#39;fs&#39;); // Express专门提供了一种更好的方式 // 专门用来提供路由的 var express = require(&#39;express&#39;); // 1 创建一个路由容器 var router = express.Router(); // 2 把路由都挂载到路由容器中 var Students=require(&#39;./student&#39;) router.get(&#39;/students&#39;, function(req, res) { // res.send(&#39;hello world&#39;); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 Students.find(function(err,students){ if (err) { return res.status(500).send(&#39;Server error.&#39;) } res.render(&#39;index.html&#39;,{students:students}) }) }); router.get(&#39;/students/new&#39;,function(req,res){ res.render(&#39;new.html&#39;) }); router.post(&#39;/students/new&#39;,function(req,res){ //获取表单数据 console.log(JSON.stringify(req.body)) //处理数据 //将数据写入json文件 //发送响应 //读取json文件并转换为对象--&gt;在对象中添加数据--&gt;将对象转换为字符串--&gt;将字符串写入json文件 Students.save(req.body,function (err){ if(err){ return res.status(500).send(&#39;Server error.&#39;) } res.redirect(&#39;/&#39;) }) }); router.get(&#39;/students/edit&#39;,function(req,res){ }); router.post(&#39;/students/edit&#39;,function(req,res){ }); router.get(&#39;/students/delete&#39;,function(req,res){ }); // 3 把router导出 module.exports = router; app.js: var router = require(&#39;./router&#39;); // router(app); // 把路由容器挂载到app服务中 // 挂载路由 app.use(router); 数据操作文件模块/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */ var fs = require(&#39;fs&#39;); var dbPath = &#39;./db.json&#39; /** * 获取所有学生列表 * return [] */ exports.find = function (callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } callback(null, JSON.parse(data).students) }) } /** * 获取添加保存学生 */ exports.save = function (student, callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } //将json字符串转换为数组对象 var students = JSON.parse(data).students //将对象保存到数组对象中 if (students.length==0) { student.id =1 } else{ student.id=students[students.length-1].id+1 } students.push(student) //将数组对象转换为json文件（字符串） var newData = JSON.stringify({students: students}) //字符串写入到文件中 fs.writeFile(dbPath, newData, function (err) { if (err) { return callback(err) } callback(null) }) }) } /** * 更新学生 */ exports.update = function () { } /** * 删除学生 */ exports.delete = function () { } 成功插入数据の截图： 点击submit，成功重定向回主页并渲染完成の截图 小结：通过这个小项目的练习，可以体会到当进行异步编程时，要想获取异步函数的数据就要使用回调函数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Preface","slug":"Preface","date":"2021-01-31T16:00:00.000Z","updated":"2021-03-12T09:41:24.000Z","comments":true,"path":"2021/02/01/Preface/","link":"","permalink":"/2021/02/01/Preface/","excerpt":"2021年1月31日半夜","text":"2021年1月31日半夜,躺在床上想着.因为今天下午的一道算法题我死活也写不出来(涉及知识盲区),翻了好多CSDN大佬们的博客终于有了思路.我在想,我是不是也可以搭一个属于自己的博客?就这样我溜到电脑旁,开始在网上寻找搭建博客的教程.相比于教程所演示的步骤以及最后的结果,我的却是漏洞百出. 第不知道第几个の漏洞:) ) 内心OS![] 就这样,我嗯是折腾到了凌晨2点半(2点的那条朋友圈发出来之后,我又发现博客有问题,然后又爬起来改……) And…就这样,2021年2月1日,Franの杂货铺算是“正式”测试营业了.你们可能想问博客都应该写些啥东西,都说了是杂货铺,种类肯定会比较繁多.不过可能还是会以知识技术(计算机)有关. However…以我现在的程度,能学会总结一些学科的知识点就已经很不错了.(我的总结能力有所欠缺,所以我总是一学就懂,一做就错.新知识”复写”(override)旧知识) Finally…我希望自己能坚持下去,不断完善博客的功能(留言板，评论板……),提高自己的总结能力,另外能加强自己语言表达能力就更好了(我的表达能力像稀饭一样).为什么我大一的时候没有想到搭博客……(掌嘴中)","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"待添加......","slug":"hello-world-tech","date":"2021-01-31T08:00:00.000Z","updated":"2021-03-14T06:41:32.000Z","comments":true,"path":"2021/01/31/hello-world-tech/","link":"","permalink":"/2021/01/31/hello-world-tech/","excerpt":"","text":"2 b continued……","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Keep searching......","slug":"hello-world-zy","date":"2021-01-31T08:00:00.000Z","updated":"2021-03-14T06:41:50.000Z","comments":true,"path":"2021/01/31/hello-world-zy/","link":"","permalink":"/2021/01/31/hello-world-zy/","excerpt":"","text":"Fran还在努力寻找资源……","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]}]}