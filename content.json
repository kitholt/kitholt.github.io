{"meta":{"title":"欢迎来到Franの杂货铺","subtitle":null,"description":"Halo, my friend!!!!!!","author":"Kitholt Frank","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-04T05:33:56.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-04T09:10:00.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"散百块，你懂我意思么？(冠希哥.gif)"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-04T07:39:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Fran的小黑屋 到我房间来......&nbsp; 给你看我新买的夜光手表&nbsp; （ ） bot_ui_ini()","keywords":"关于我？"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-04T09:35:18.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-04T05:22:24.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-04T09:06:10.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"环球音乐集团"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-06T15:32:04.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"我的Valine邮箱验证成功啦，欢迎大家来喷我 胡言乱语，乱说一气 :D 获取中... —— :D 获取中... fetch('https://v1.hitokoto.cn/?c=b') .then(response => response.json()) .then(data => { const hitokoto = document.getElementById('hitokoto_text') const from = document.getElementById('from') hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid hitokoto.innerText = data.hitokoto from.innerText = data.from }) .catch(console.error)","keywords":"留言板"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"复习堆排序","slug":"复习堆排序","date":"2021-03-06T07:44:20.528Z","updated":"2021-03-06T07:45:00.720Z","comments":true,"path":"2021/03/06/复习堆排序/","link":"","permalink":"/2021/03/06/复习堆排序/","excerpt":"","text":"复习堆排序堆的定义：堆是一个具有以下性质的二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称之为大顶堆。反之称之为小顶堆。 那么，在代码中如何表示大小顶堆？arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2]//大顶堆 arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2]//小顶堆 堆排序の思想 先把待排序序列构建成一个大（小）顶堆 这时，整个序列的最大值就是堆顶的根节点（也就是数组的第一个元素） 将其与末尾元素进行交换，此时末尾就是最大值 然后将剩余的n-1个元素重新构造成一个新的堆，这样就得到n-1个元素的次小值，如此反复，就能得到一个有序序列——[重复（1），（2），（3）步骤] 代码实现：import java.util.Arrays; public class heapSort { public static void main(String[] args){ int[] arr={25, 30, 11, 7, 22, 16, 18, 33, 40, 55}; int temp=0; for(int i=arr.length/2-1;i&gt;=0;i--){//从左往右，从下往上寻找非叶子节点进行初始的堆排序 adjustHeap(arr,i, arr.length); } for(int j=arr.length-1;j&gt;=0;j--){//初始堆建成后，首尾的元素进行交换，此时大顶堆的结构被破坏 temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j);//因为是首尾交换所以只有最顶部的结点不符合顶堆的定义，中间的非叶子节点均符合堆顶义，所此时的i等于0，也就是只从顶部开始调整 } System.out.println(&quot;排序后的数组为：&quot;+Arrays.toString(arr)); } /** * * @param arr 待排序数组 * @param i 以i为父节点进行堆排序的树（数组） * @param length 数组长度 */ public static void adjustHeap(int[] arr,int i,int length){ int temp=arr[i]; for(int k=2*i+1;k&lt;length;k=2*k+1){//k指向i的较大的一个子结点 if((k+1&lt;length)&amp;&amp;arr[k]&lt;arr[k+1]){//判断i叶子结点的左右结点的大小，如果左边的小于右边的，则k++ k++; } if(arr[k]&gt;temp){//如果该子结点大于它的父结点，则将该子结点赋值给父节点 arr[i]=arr[k]; i=k;//以k为父节点继续和它的子节点比较 } } arr[i]=temp;//将最开始保存的arr[i]放到末尾 } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机网络(持续更新...)","slug":"计算机网络","date":"2021-03-04T06:16:12.896Z","updated":"2021-03-04T06:09:53.296Z","comments":true,"path":"2021/03/04/计算机网络/","link":"","permalink":"/2021/03/04/计算机网络/","excerpt":"","text":"计算机网络注：按照课时进度整理 Part①网络的分类 电信网络：向客户提供电话，电报以及传真等服务 有线电视网络：向用户传送各类电视节目 计算机网络：能允许用户能够在计算机之间传送数据文件 思考：internet和Internet有何区别？ internet指的是互连网，它泛指有多个计算机网络互相连而成的计算机网络（网络的网络）。在这些网络之间的通信协议可以任意选择，不一定非要TCP/IP协议 Internet则是我们经常谈到的互联网（因特网），它是由当前全球最大的、开放的、由众多网络互相连接而成的互连网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。PS：现在的互联网具有三级结构，即主干网、地区网、校园网（企业网） 相关名词：ISP（Internet Service Provider）：互联网服务提供者，也就是提供IP地址，比如我国的三大通信巨头：“移”不动、“联”不通、“信”不过，根据覆盖面积大小和IP数量的不同，ISP又分为：主干ISP、地区ISP、本地ISP 互联网的组成：边缘部分：连接在互联网的所有的端系统（手机端、电脑端、网络摄像头……），通过C/S方式和P2P方式进行通信 核心部分：路由器使用分组交换向边缘部分的端系统提供连通性 啥是分组交换？在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。 分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。 分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。 分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"算法分析与设计(持续更新...)","slug":"算法分析与设计","date":"2021-03-03T16:08:16.956Z","updated":"2021-03-03T03:35:03.240Z","comments":true,"path":"2021/03/04/算法分析与设计/","link":"","permalink":"/2021/03/04/算法分析与设计/","excerpt":"","text":"算法分析与设计 chapter①：算法引论定义：解决某种问题的方法 特征：输入，输出，确定性（指令清晰无歧义），有限性（指令执行次数有限） 算法复杂性の分析 时间复杂性：T=T(N[问题规模],I[算法的输入],A[算法本身]) 空间复杂性 ：S=S(N,I) 渐进时间复杂性＝时间复杂度 大O表示法（算法时间运行时间的上界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≤C(g(n))，则称f(n)=O(g(n))，也称f(n)的阶不高于g(n)的阶 大Ω表示法（算法时间运行时间的下界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≥C(g(n))，则称f(n)=Ω(g(n))，也称f(n)的阶不低于g(n)的阶 θ表示法（算法时间运行时间的准确界） C1(g1(n))≤f(n)≤C2(g2(n))","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"蛋疼のNode学习之路(持续更新...)","slug":"蛋疼のNode学习之路","date":"2021-03-03T15:55:42.180Z","updated":"2021-02-15T16:34:30.000Z","comments":true,"path":"2021/03/03/蛋疼のNode学习之路/","link":"","permalink":"/2021/03/03/蛋疼のNode学习之路/","excerpt":"","text":"蛋疼のNode学习之路（持续更新…）Day1Previously on ‘Preface’，对于一个几乎零基础的我来说，搭建博客的过程是十分痛苦的，这现在只是一个简单的修改博客主题和编辑的过程啊（前端知识盲区o(╥﹏╥)o）。所以我决定花上一定时间来学习Node.js。希望学完之后我能更好的运维我的BLog（顺便复【yu】习一下Web相关知识，HTML5，CSS3，JavaScript什么的都快忘光光啦）话不多说，今天开始第一天的学习！ ①那么，Node.js是乜嘢？（what？）解释： 不是一门语言，不是库，不是框架。而是一个js的运行时 ，通俗地说就是能够一个能够运行js的平台环境。 可提供服务器级别的api（需要引入相关的模块，比如文件读写需要’fs’，也就是File-System）：文件读写，网络服务构建，网络通信，http服务器（http模块）……//后面会讲模块系统 特性： 事件驱动 非阻塞IO模型（异步）————————————-啊啥是同步和异步？，又要去恶补了o((⊙﹏⊙))o 轻量和高效 与Node.js相关的东东npm：全称是Node Package Manager。世界上最大的开源生态系统（大多数的js相关的包都在npm里）可在命令行通过下列语法获取相关包 npm install [jquery] ②Node.js能干啥哇？（do what？） web服务器后台（能干类似活的有Java,，PHP，Python，balabala…….） 命令行工具 npm git hexo （这个我熟哈哈） ③参考资源（resource） 《深入浅出Node.js》（偏理论） 《Node.js权威指南》 JavaScript标准参考教程（alpha）作者：阮一峰（惊了，英文名也叫Frank） Node入门（fen） cNode社区 ④安装Node（install）会的都会，不会的戳一戳下面的教程： 参考教程：https://www.runoob.com/nodejs/nodejs-install-setup.html ⑤模块系统（Module system） 在Node中，每一个js文件都是一个模块，另外Node中也没有全局作用域的概念。 在Node中，只能通过require()方法加载js文件。 require()方法只加载其中的代码。既然没有全局作用域，那么各个js文件之间是模块作用域。 模块全封闭。 外部和内部之间是无法互相访问的。 其实每个模块中有都一个exports专属的对象，该对象中可以封装各自模块中的数据和方法，方便其他模块应用 举个例子 var demo =require(&#39;./a&#39;)//调用模板a，并且获得a的exports对象,并且用一个变量demo接收 ——————-分割线，下面进入简单的实操环节——————– 启动一个简单服务器 var http = require(&#39;http&#39;)//创建http对象 var server = http.createServer()//利用http对象创建一个服务器对象server server.listen(4000, function () {//选择端口 console.log(&quot;贪玩蓝月服务器，琦动！&quot;) }) server.on(&#39;request&#39;, function (request, response) {//server监听是否收到客户端发送过来的request，收到后根据回调函数再返回响应 console.log(&quot;收到请求&quot;) response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;})//&lt;-----------解决乱码的方法 var url = request.url if (url == &#39;/&#39;) { response.end(&quot;欢迎来到贪玩蓝月，是兄弟就来砍我&quot;) } else if(url==&#39;/login&#39;){ response.end(&quot;貪玩藍月登錄註冊界面...&quot;) } else if(url==&#39;/register&#39;){ response.end(&quot;快進到貪玩藍月の註冊界面&quot;) } else{ response.end(&quot;404 not found...&quot;) } }) 但是第一次运行的时候出现这种情况……. 不用慌，在回调函数里的第一行加上 response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;}) 运行后的截图 当然一个网站肯定不能只是傻傻地响应同一段内容，服务器必须根据浏览器(客户端)发来的请求信息来对应地响应合适的内容。 实现方法也特别简单，加入一组if-else的判断就可。（详情见上代码line10-21） 实现效果： And: 2.模块系统 解释：在demo中引入模板a—&gt;执行a的代码，在控制台打印starting语句—&gt;引入模板b—&gt;打印模板b的opening和closed—&gt;a中的引用结束，打印a的end—&gt;打印从a模板获取的值foo=200 从中我们发现输出的foo值是模板a中的，而不是b模板中的。这也体现了模块作用域的好处：可以加载执行多个文件，可以完全避免变量命名而产生的冲突（认真脸） ⑥相关知识补充 同步（Synchronous） A程序调用B程序，必须等待B程序完成才能返回到A程序，A程序继续执行……从流程上看是一条”直线“ 异步（Asynchronous） A程序调用B程序，此时A不会等待B程序是否执行完毕，而是继续往后执行自己的代码……从流程上看是出现了一条从主线产生的“支线” 回调函数 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（来自谷歌的解释） 通俗讲就是 ①你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 什么还不懂？行，还有个例子：②约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。~（单身的看例子①就好了） Day2 今天主要围绕模板引擎的概念以及应用方式、渲染这两点展开，并且相对应地结合两个小案例来更进一步的理解感受它们。话不多少，先介绍主要概念。 神么是模板引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。这就好比于我们的写作模板，我们想写什么类型的文章比如说明文，记叙文，抒情文，应用文。它们都有固定的一套模式，我们只要按照这套模式来，往里面添加我们自己的内容即可。 常用模板：art-template（art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。） 安装方法： npm install art-template --save 啥是渲染？在电脑绘图中，渲染是指在指用软件从模型生成图像的过程。而在HTML中则是指如何加工并且显示出最终的HTML页面。我们又根据加工场景位置的不同把HTML渲染分为服务端渲染和客户端渲染。 互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时ajax的兴起，使得业界就开始推崇前后端分离的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的客户端渲染了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。 服务端渲染aka后端渲染（service-side render）の优缺点： 优点 减轻前端压力 不用占用前端的资源，比如在用手机浏览网页时，浏览器的负担减轻，因此能够节省手机的电量 有利于SEO（Search Engine Optimization）搜索引擎优化。爬虫能够爬取到在后端的HTML文档 缺点 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则前端一般就是写一个静态html文件，然后后端再修改为模板，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； 或者是前端直接完成html模板，然后交由后端。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。 占用服务器端资源。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。 客户端渲染aka前端渲染（client-side render）的优缺点： 艾达王替矩（advantages）： 前后端分离，前端能够自定义UI而不用去过度依赖后端 diss艾达王替矩： 前端的响应速度会变慢，这就是为什么我们在浏览一些网页时，经常会“爱的魔力转圈圈”。（后端的渲染速度要比前端的快） 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。因为服务器端可能没有保存完整的html，而是前端通过js进行dom的拼接，那么爬虫无法爬取信息。 除非搜索引擎的seo可以增加对于JavaScript的爬取能力，这才能保证seo。 小案例一：模拟Apacheの目录HTML（服务端渲染）在此之前我们还需要用到fs模块的readFile()和readdir()方法，简单介绍一下这两个方法： readFile()：能够读取指定路径下的文件并保存到data中，data是一个二进制的数据流（里面全是010101），因此要将其转变为我们认识的字符串需要用到toString()方法。 readdir()： 读取指定目录下的所有文件夹名，并返回一个由这些文件夹名构成的字符串数组files。 var fs = require(&#39;fs&#39;); fs.readdir(&#39;readdirtest&#39;, function(err,files){ if(err){ console.log(err); } console.log(files); }) 操作描述： 加载必要的模块fs，http… 设置端口号xxxx 为服务器设置响应信息 读取模板文件template.html（目录显示页），并且将要替换的区域使用特殊符号进行标记，这里我使用了-.-这个标记 读取目录列表的所有文件夹 并将要替换的部分用一个变量content表示 用forEach方法依次取出files里的文件夹名并构建content（见代码20—24） 将第一步读取的data转换为字符串 简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 发送响应 下面是一小段代码： var fs = require(&#39;fs&#39;) var http = require(&#39;http&#39;) var server = http.createServer() var wwwDir = &#39;F:/www&#39; server.on(&#39;request&#39;, function (req, res) { fs.readFile(&#39;./template.html&#39;, function (err, data) {//获得模板template.html if (err) { console.log(&#39;找不到文件......请重试&#39;) } fs.readdir(wwwDir, function (err, files) {//得到wwwDir的目录列表中的文件名和目录名 if (err) { return console.log(&#39;读取目录失败&#39;) } console.log(files)//files是一个字符数组，元素为目录中的文件名 var content = &#39;&#39;//将模板中要替换的部分构建为content files.forEach(function (item) {//利用forEach，取出files数组的每个元素（item），进行渲染${item}替换 content += `&lt;tr&gt;&lt;td data-value=&quot;新建 Microsoft Word 文档.docx&quot;&gt;&lt;a class=&quot;icon file&quot; draggable=&quot;true&quot; href=&quot;/F:/www/%E6%96%B0%E5%BB%BA%20Microsoft%20Word%20%E6%96%87%E6%A1%A3.docx&quot;&gt;${item}&lt;/a&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;0 B&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1612679895&quot;&gt;2021/2/7 下午2:38:15&lt;/td&gt; &lt;/tr&gt;` }) data = data.toString()//将二进制流的data转换为字符串 data=data.replace(&#39;-.-&#39;, content)//简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 res.end(data)//发送响应数据 }) }) }) server.listen(4001, function () { console.log(&#39;服务器，琦动！&#39;) }) 结果截图： 小案例二：art-template需要一个用于储存模板的html和一个js文件 html模板: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;This is Frank&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is {{ name }}.&lt;/p&gt; &lt;p&gt;I am {{ age }} years old.&lt;/p&gt; &lt;p&gt;I am from {{ province }}.&lt;/p&gt; &lt;p&gt;I like {{ each hobbies }} {{ $value }} {{/each}}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果没有art-template，运行结果如下： 加了art-template后： var fs=require(&#39;fs&#39;) var http=require(&#39;http&#39;) var template=require(&#39;art-template&#39;) http .createServer(function(req,res){ var url=req.url if(url===&#39;/&#39;){ fs.readFile(&#39;./Frank.html&#39;,function(err,data){ if(err){ return res.end(&#39;你访问的网址不存在噢&#39;) } data=data.toString() var Frank=template.render(data,{ name:&#39;Frank&#39;, age:20, province:&#39;ChongQing&#39;, hobbies:[&#39;打篮球&#39;,&#39;写博客&#39;,&#39;吹水&#39;] }) res.end(data) }) } }) .listen(3000,function(){ console.log(&#39;琦动！&#39;) 由此可见，art-template只关注中的值，不会去关心html中的格式。因此可以理解为js数据传到html中展示出来 Day3Node中的模块系统模块の定义： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。 使用Node编写应用程序主要就是在使用： Ecmascript 核心模块 文件操作fs http服务的http url路径操作的模块 path路径处理模块 os操作系统模块 第三方模块 art-template 必须通过npm下载 开发者自个儿写的模块（自定义的） 模块化 文件作用域 通信规则 加载require 导出CommonJs模块规范 这就是要谈论的——模 块 系 统 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员 加载require操作： var 自定义变量名称=require(&#39;模块&#39;) 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有成员只在当前文件模块有效 如果我们想要访问其他模块的成员，可以把这些成员加载到exports上去 导出多个成员： exports.demo=foo exports.test=&#39;233&#39; exports.fun=function(){ xxxxxxxxxxxxx } 也可以这样导出多个成员： module.exports={ add: function(){ return xxxxxxx }, foo:&#39;123&#39; } 导出单个成员（指定的）： module.exports=&#39;666&#39; module.exports=function(){ } 注意：在使用module.exports时，后一个的会覆盖前一个的module.exports 原理在底层代码中：exports是module.exports的一个引用—&gt;exports=module.exports console.log(exports===module.exports)//会返回true exports.foo=&#39;666&#39; module.exports.foo=&#39;666&#39;//等价 require方法加载规则 核心模块 模块名 第三方模块 模块名 开发者自己写的 路径 优先从缓存加载 加载过的模块会暂存入缓存中，若下次还有调用，直接从缓存中读取， 能有效提高模块加载效率 package.json每一个项目最好有一个包描述文件（package.json，就像产品的说明书）。可通过npm init生成 。有了该文件，再用npm install就能把文件里的依赖项全部下载回来，就相当于原先有了备份，现在进行备份还原 在每个项目的根目录下应该有一个package.json文件 每次安装第三方包时，应该在后面加上–save`，可以用来保存依赖项信息 npm [npm网站]: npmjs.com 命令行工具 npm install --global npm//更新命令 常用命令 npm init -y//快速生成package.json文件 npm install npm install 包名//下载指定包 npm install --save 包名//下载指定包并保存到package.json的dependencies中 npm uninstall 包名 npm help//查看使用帮助 npm 命令 --help//查看指定命令的使用帮助 如何解决npm被墙的问题 安装淘宝的cnpm： npm install --global cnpm//--global表示安装到全局，不能省略。以后就能用cnpm代替npm了 如果不想安装cnpm但是又想用淘宝的服务器下载，可以通过: npm config set registry https://registry.npm.taobao.org//默认使用淘宝服务器下载 Express一种Web开发框架 npm install express --save//安装express 拿到框架的第一步当然是Hello World！ var express=require(&#39;express&#39;) var app=express()//相当于以前的server对象 app.listen(3000,function(){ console.log(&#39;服务器，琦动&#39;) }) app.get(&#39;/&#39;,function(req,res){//以get方法请求&#39;/&#39;，并执行对应的处理函数 res.send(&#39;Hello World!&#39;) }) 静态服务（静态 资源获取）// 开放静态资源 // 1.当以/public/开头的时候，去./public/目录中找对应资源 // 访问：http://127.0.0.1:3000/public/login.html app.use(&#39;/public/&#39;,express.static(&#39;./public/&#39;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问 // 访问：http://127.0.0.1:3000/login.html // app.use(express.static(&#39;./public/&#39;)); // 3.访问：http://127.0.0.1:3000/a/login.html // a相当于public的别名 // app.use(&#39;/a/&#39;,express.static(&#39;./public/&#39;)); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 // 通过requery方法获取用户输入的数据 // req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） var express = require(&#39;express&#39;) // 引包 var bodyParser = require(&#39;body-parser&#39;) var app = express() // 配置body-parser // 只要加入这个配置，则在req请求对象上会多出来一个属性：body // 也就是说可以直接通过req.body来获取表单post请求数据 // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })) // parse application/json app.use(bodyParser.json()) 使用： app.use(function (req, res) { res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;) res.write(&#39;you posted:\\n&#39;) // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2)) }) 在express中配合和使用art-template安装： npm install --svae art-template npm install --save express-art-template 配置： app.engine(&#39;html&#39;,require(&#39;express-art-template&#39;))//第一个参数表示渲染以art结尾的文件 使用： app.get(&#39;/&#39;,function(req,res){ //express默认会从项目的views目录去寻找index.html res.render(&#39;index.html&#39;,{ title:&#39;hello world&#39; }) }) 如果希望修改视图渲染的目录（原本是views），可： app.set(&#39;views&#39;,目录路径) CRUD(待更…)其他项①修改完代码自动重启以前每次修改完代码都要傻乎乎地去node xxx.js现在有了nodemon这一个第三方命令行工具，就能解决这一问题。 安装方法，懂得都懂 npm install nodemon --global ②封装异步API回调函数：获取异步操作的结果 function fn(callback){ // var callback = funtion(data){ console.log(data); } setTimeout(function(){ var data = &#39;hello&#39;; callback(data); },1000); } // 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取 fn(function(data){ console.log(data); }) ③关于json文件格式の坑json文件格式要求极其严格，比如 致命错误在：id为5的一行末尾的逗号，一定要去掉！！！结尾的一个花括号不能有逗号（就这个错误折磨了我半个小时……） 小项目一个简单的表单提交网站 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: /** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */ var fs = require(&#39;fs&#39;); // Express专门提供了一种更好的方式 // 专门用来提供路由的 var express = require(&#39;express&#39;); // 1 创建一个路由容器 var router = express.Router(); // 2 把路由都挂载到路由容器中 var Students=require(&#39;./student&#39;) router.get(&#39;/students&#39;, function(req, res) { // res.send(&#39;hello world&#39;); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 Students.find(function(err,students){ if (err) { return res.status(500).send(&#39;Server error.&#39;) } res.render(&#39;index.html&#39;,{students:students}) }) }); router.get(&#39;/students/new&#39;,function(req,res){ res.render(&#39;new.html&#39;) }); router.post(&#39;/students/new&#39;,function(req,res){ //获取表单数据 console.log(JSON.stringify(req.body)) //处理数据 //将数据写入json文件 //发送响应 //读取json文件并转换为对象--&gt;在对象中添加数据--&gt;将对象转换为字符串--&gt;将字符串写入json文件 Students.save(req.body,function (err){ if(err){ return res.status(500).send(&#39;Server error.&#39;) } res.redirect(&#39;/&#39;) }) }); router.get(&#39;/students/edit&#39;,function(req,res){ }); router.post(&#39;/students/edit&#39;,function(req,res){ }); router.get(&#39;/students/delete&#39;,function(req,res){ }); // 3 把router导出 module.exports = router; app.js: var router = require(&#39;./router&#39;); // router(app); // 把路由容器挂载到app服务中 // 挂载路由 app.use(router); 数据操作文件模块/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */ var fs = require(&#39;fs&#39;); var dbPath = &#39;./db.json&#39; /** * 获取所有学生列表 * return [] */ exports.find = function (callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } callback(null, JSON.parse(data).students) }) } /** * 获取添加保存学生 */ exports.save = function (student, callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } //将json字符串转换为数组对象 var students = JSON.parse(data).students //将对象保存到数组对象中 if (students.length==0) { student.id =1 } else{ student.id=students[students.length-1].id+1 } students.push(student) //将数组对象转换为json文件（字符串） var newData = JSON.stringify({students: students}) //字符串写入到文件中 fs.writeFile(dbPath, newData, function (err) { if (err) { return callback(err) } callback(null) }) }) } /** * 更新学生 */ exports.update = function () { } /** * 删除学生 */ exports.delete = function () { } 成功插入数据の截图： 点击submit，成功重定向回主页并渲染完成の截图 小结：通过这个小项目的练习，可以体会到当进行异步编程时，要想获取异步函数的数据就要使用回调函数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Preface","slug":"Preface","date":"2021-03-03T15:55:42.179Z","updated":"2021-02-04T12:31:36.000Z","comments":true,"path":"2021/03/03/Preface/","link":"","permalink":"/2021/03/03/Preface/","excerpt":"2021年1月31日半夜","text":"2021年1月31日半夜,躺在床上想着.因为今天下午的一道算法题我死活也写不出来(涉及知识盲区),翻了好多CSDN大佬们的博客终于有了思路.我在想,我是不是也可以搭一个属于自己的博客?就这样我溜到电脑旁,开始在网上寻找搭建博客的教程.相比于教程所演示的步骤以及最后的结果,我的却是漏洞百出. 第不知道第几个の漏洞:) ) 内心OS![] 就这样,我嗯是折腾到了凌晨2点半(2点的那条朋友圈发出来之后,我又发现博客有问题,然后又爬起来改……) And…就这样,2021年2月1日,Franの杂货铺算是“正式”测试营业了.你们可能想问博客都应该写些啥东西,都说了是杂货铺,种类肯定会比较繁多.不过可能还是会以知识技术(计算机)有关. However…以我现在的程度,能学会总结一些学科的知识点就已经很不错了.(我的总结能力有所欠缺,所以我总是一学就懂,一做就错.新知识”复写”(override)旧知识) Finally…我希望自己能坚持下去,不断完善博客的功能(留言板，评论板……),提高自己的总结能力,另外能加强自己语言表达能力就更好了(我的表达能力像稀饭一样).为什么我大一的时候没有想到搭博客……(掌嘴中)","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Keep searching......","slug":"hello-world-zy","date":"2021-03-03T15:55:42.178Z","updated":"2021-02-04T06:16:34.000Z","comments":true,"path":"2021/03/03/hello-world-zy/","link":"","permalink":"/2021/03/03/hello-world-zy/","excerpt":"","text":"Fran还在努力寻找资源……","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"待添加......","slug":"hello-world-tech","date":"2021-03-03T15:55:42.177Z","updated":"2021-02-04T06:14:22.000Z","comments":true,"path":"2021/03/03/hello-world-tech/","link":"","permalink":"/2021/03/03/hello-world-tech/","excerpt":"","text":"2 b continued……","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}