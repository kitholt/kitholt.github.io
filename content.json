{"meta":{"title":"欢迎来到Franの杂货铺","subtitle":null,"description":"Halo, my friend!!!!!!","author":"Kitholt Frank","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-07-14T13:20:22.376Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Fran的小黑屋 到我房间来......&nbsp; 给你看我新买的夜光手表&nbsp; （ ） bot_ui_ini()","keywords":"关于我？"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-06T15:32:04.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"我的Valine邮箱验证成功啦，欢迎大家来喷我 胡言乱语，乱说一气 :D 获取中... —— :D 获取中... fetch('https://v1.hitokoto.cn/?c=b') .then(response => response.json()) .then(data => { const hitokoto = document.getElementById('hitokoto_text') const from = document.getElementById('from') hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid hitokoto.innerText = data.hitokoto from.innerText = data.from }) .catch(console.error)","keywords":"留言板"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-09-24T09:04:34.689Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-04T05:33:56.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-04T09:10:00.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"散百块，你懂我意思么？(冠希哥.gif)"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-04T05:22:24.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-09-24T09:11:07.424Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"环球音乐集团"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-04T00:46:16.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-04T00:46:16.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2020-03-09T05:50:05.000Z","updated":"2022-06-14T12:50:59.378Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"学一学神经网络","slug":"学一学神经网络","date":"2022-05-22T15:45:00.000Z","updated":"2022-06-14T11:23:47.645Z","comments":true,"path":"undefined/学一学神经网络/","link":"","permalink":"/undefined/学一学神经网络/","excerpt":"","text":"简单学一学神经网络（基于鱼书）感知机 正如图上所示，若干个输入变量通过加权求和，并通过一个跃阶函数的映射，输出结果。在生物学里就是，神经元接收一些信号，然后这些信号会在神经细胞核内进行一系列综合处理，最后当这个处理后的信号达到一定的阈值，该细胞就会被激活，产生一个刺激的输出。这就是所谓的感知。感知机就是对人脑神经元的一次感知模拟。 利用感知机实现简单的逻辑电路比如实现与门 import numpy as np def AND(x1, x2): w1, w2= 0.5, 0.5 temp = x1 * w1 + x2 * w2 if temp &gt;= 1: return 1 elif temp &lt; 1: return 0 #测试一下 print(AND(1, 0)) #0 与非门 def NAND(x1, x2): x = np.array([x1, x2]) w = np.array([-0.5, -0.5]) b = 0.7 temp = np.sum(x * w) + b if temp &gt; 0: return 1 else: return 0 print(NAND(0, 0))#1 或门 def OR(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.2 temp = np.sum(x * w) + b if temp &gt; 0: return 1 else: return 0 print(OR(1, 1))#1 可以发现这三种门的实现都是通过一个线性函数来判断的，也就是三种门的解是能被一条直线给划分开的。由一条直线所划分产生的空间称为线性空间。如由曲线划分的则称为非线性空间。 异或门 def XOR(x1, x2): s1 = OR(x1, x2) s2 = NAND(x1, x2) return AND(s1, s2) XOR(1, 0)#1 XOR(0, 0)#0 经过实验，发现，异或门的实现不能像与门那样，仅仅通过一个线性函数来判断，它的解空间是由一条曲线划分出来的。按照常规的思路，求出这条曲线的表达式就解决了这个问题。通过阅读鱼书可以知道，通过对原有的三种门的叠加（如上代码所示）可以实现异或门。单层感知机解决不了的问题，多层感知机就可以解决。这也间接说明了多层感知机能够去拟合一条曲线！ 人工神经网络（ANN）AKA 激活函数为非跃阶函数的多层感知机长啥样以及它的组成成分 激活函数import matplotlib.pyplot as plt import numpy as np # 跃阶函数 def step_func(x): y = x &gt; 0 return y.astype(np.int) #绘制跃阶函数图像 x = np.arange(-5.0, 5.0, 0.1) y = step_func(x) plt.plot(x, y, label = &#39;step function&#39;) plt.legend() plt.grid() #sigmoid函数 def sigmoid(x): return 1 / (1 + np.exp(-x)) #修正线性单元ReLu def ReLu(x): return np.maximum(0, x) #softmax函数(用于多元分类) def softmax(x): max_x = np.max(x) exp = np.exp(max_x - x) sum_exp = np.sum(exp) return exp / sum_exp 对于softmax函数，在分子分母都乘上C这个任意常数，然后将C移动到指数函数里面（此时里面变成x加上或者减去一个C’），并不会改变运算的结果。为什么要这样子做呢，这是因为指数函数的运算的自变量x如果特别大，会需要特别大的计算量。（指数爆炸嘛） 损失函数用于衡量神经网络的性能的一项重要指标。所谓损失就是实际结果与理想结果的偏差。比如预测，我们当然希望一次预测成功的几率是100%，现实情况可能是90%，那这个10%就是损失。有n次预测就有n次损失，用一个函数将这些损失表示出来，很明显只要求出这个函数的最小值，就能将损失值降到最低。这也是神经网络优化的目标。那么问题来了，哪些函数可以用来作损失函数？下面给出两个常用的损失函数。 import numpy as np #均方误差函数 def mse(y, t): return 0.5 * np.sum((y - t) ** 2) import numpy as np #交叉熵函数 def cross_entropy_error(y, t): delta = 1e-7 return -np.sum(t * np.log(y + delta)) 在定义的交叉熵函数中使用了delta这一变量，是为了防止出现真数为0的情况。（结果为负无穷大） batch一批一批地训练样本。比如样本总量500，分成10批，也就是10 batch。 iteration迭代。1次batch称为1次iteration，可以理解为每10次iteration后权重参数都要进行1次更新。 epoch时代，纪元。训练集中所有样本全部训练1次称为1个epoch 数值微分(给我狠狠地导！)利用微小差分求解导数的过程称为数值微分 def numerical_diff(f, x): h = 1e-4 return (f(x + h) - f(x - h)) / (2 * h) def fun_1(x): return np.sum(x ** 2) numerical_diff(fun_1, np.array([0, 0]))#0.0 梯度gradient（梯度下降法）是由一个函数的所有偏导数构成的一个向量，其方向指向函数变化（上升）最快的方向。 #for循环用于求解x每个元素的数值积分，也就是方向导数 def numerical_grad(f, x): h = 1e-4 grad = np.zeros_like(x) for index in range(x.size): temp = x[index]#保存初值 x[index] = temp + h fxh1 = f(x) x[index] = temp - h fxh2 = f(x) grad[index] = (fxh1 - fxh2) / (2 * h) x[index] = temp #将初值恢复 return grad 但是以上求解梯度的代码只适用于参数x是一维数组的情况，下面给出改进后的方法 #首先将W数组和梯度数组全部“碾平”---&gt;1*n的np数组，然后记录W数组一开始的shape，作为最后grad返回的条件判断 #比如W_shape = （2， 3），那么就需要将现在shape是（1， n）的grad数组的shape重新转为（2， 3） ##参数说明：f为损失函数，W为权重数组，W_shape记录W数组一开始的shape，W_flatten表示“碾平”后的数组... #fxh1、fxh2为作【中心差分】的两个前后值 def numerical_grad(f, W): print(&#39;before&#39;, W) h = 1e-4 grad = np.zeros_like(W) ######################################## grad = grad.reshape(1, W.size) ######################################## W_shape = W.shape ######################################## W_flatten = W.reshape(1, W.size) ######################################## for index in range(W_flatten.size): temp = W_flatten[0][index]#保存初值 print(&#39;temp&#39;, temp) W_flatten[0][index] = temp + h if len(W_shape) !=1: W_flatten = W_flatten.reshape(W_shape[0], W_shape[1]) fxh1 = f(W_flatten) print(&#39;fxh1&#39;, fxh1) ######################################## W_flatten = W_flatten.reshape(1, W.size) ######################################## W_flatten[0][index] = temp - h if len(W_shape) !=1: W_flatten = W_flatten.reshape(W_shape[0], W_shape[1]) fxh2 = f(W_flatten) print(&#39;fxh2&#39;, fxh2) grad[0][index] = (fxh1 - fxh2) / (2 * h)#求某个方向的方向导数 ######################################## W_flatten = W_flatten.reshape(1, W.size) ######################################## W_flatten[0][index] = temp #将初值恢复 if W.ndim != 1:#如果不是一维的，则需要将grad的shape转换成和W数组一致 print(&#39;after&#39;, W) return grad.reshape(W_shape[0], W_shape[1]) else:#一维的情况... print(&#39;after&#39;, W) return grad 梯度下降法：随机梯度下降法，批量梯度下降法，小批量梯度下降法 写一个简单的simpleNet类来求梯度，再实现梯度下降法class simpleNet: def __init__(self): #self.W = np.random.randn(2, 3)#权重初始化 self.W = np.array([[0.47355232, 0.9977393, 0.84668094], [0.85557411, 0.03563661, 0.69422093]]) def predict(self, x):#预测方法 return np.dot(x, self.W) def loss(self, x, t):#定于计算损失值的损失函数 z = self.predict(x) y = softmax(z) loss = cross_entropy_error(y, t) return loss def accuary(self, x, t): y = self.predict(x) y = np.argmax(y, axis = 1) t = np.argmax(t, axis = 1) accuary = np.sum(y == t) / float(x.shape[0]) return accuary notes: cross_entropy_error是上文定义好的… sn = simpleNet() sn.W x = np.array([0.6, 0.9]) p = sn.predict(x) p #设置正确解标签 t = np.array([0, 0, 1]) def f(W): return sn.loss(x, t) numerical_grad(f, sn.W) 反向传播有反向传播就有正向传播，正向传播指的是神经网络从输入层到输出层的计算过程。我们都知道这一过程不是百分百完美的，会产生损失。如何修正损失，上文也讲到了—梯度下降法。反向传播其实就是更新迭代权重的过程，它从损失函数的结果出发，求解损失函数关于权重的偏导数，而将这些偏导数组合在一起就是梯度！而实现反向传播的 数学前提则是—链式法则。+ 以层为单位实现神经网络的处理（搭建乐高积木）—代码实现ReLu层class ReLu: def __init__(self): self.mask = None def forward(self, x): self.mask = (x &lt;= 0) out = x.copy() out[self.mask] = 0 return out def backfard(self, dout): dout[self.mask] = 0 dx = dout return dx Sigmoid层class Sigmoid: def __init__(self): self.out = None def forward(self, x): out = 1 / (1 + np.exp(-x)) return out def backward(self, dout): dx = dout * (1.0 - self.out) * self.out return dx softmaxWithLoss层（一般放在输出层）Affine层（仿射变换层）正向传播中进行的矩阵乘积运算被称为“仿射变换层”，因为在几何学中，仿射变换包括一次线性变换和一个平移，分别对应神经网络的加权和运算与加偏置运算。 class Affine: def __init__(self, W, B): self.x = None self.W = W self.B = B self.dW = None self.dB = None def forward(self, x): self.x = x out = np.dot(x, self.W) + self.B return out def backward(self, dout): dx = np.dot(dout, self.W.T) self.dW = np.dot(self.W.T, dout) self.dB = np.sum(dout, axis = 0) return dx 神经网络的目标—学习！人的学习是一个无限试错的过程…神经网络的亦是如此。神经网络各个参数（权重，偏置）的初始值取到多少才合适是一个值得研究的问题。如何选取初值？选取了初值后怎么对它们进行迭代更新（梯度更新的方式）。以及超参数的取值和更新问题（比如学习率衰减方法） 权重初始值的设置如果权重初始值全部设置为0，神经网络将无法进行正常的学习。因为这样子的话，正向传播的结果始终相等，这意味着反向传播的权重更新也是一样的。下面有两种方法来设置权重的初始值… Xavier初始值假设当前需要初始化权重的层为A，它与前一层有n个节点连接时，初始值使用标准差1/根号下n的分布 He 初始值假设当前需要初始化权重的层为A，它与前一层有n个节点连接时，初始值使用标准差根号下n分之2的分布 权重的初始值设置很重要。如果设置不当，会出现“梯度消失”的情况。 权重的迭代更新也就是要求梯度如何下降？“如何”强调的是方法。下面学习四种方法，它们各有优缺点。 SGD Momentum v对应物理上的速度，第二条公式表示物体在梯度方向上受力，物体的速度在增加。 AdaGrad 第一个公式表示某参数的梯度的平方。如果在一次更新中，梯度变化较大，那么h的值也会越大，那在下一次更新中，其学习率会被降低（看第二个公式） Adam（Momentum + AdaGrad） 标准（正规）化！强制调整激活值的分布范围，使每一层的值具有更好的分布广度，如果总是集中在0,1附近，那么在反向传播时会出现梯度消失的情况。 使增加学习率（加快学习速度） 不再那么依赖初始值（消除量纲影响、较大或较小的数值会对最后加权和结果的影响） 抑制过拟合（降低Dropout等的必要性） 正则化！主要用于避免过拟合的产生和减少网络误差。 权值衰减给损失函数加上λ*（L2范数），其中lambda表示惩罚系数（权值衰减系数），它的值越大，对权重的惩罚就越大。（通俗理解就是，让权重不敢继续增加） Dropout 在前向传播过程中，让神经元以一定的概率p停止工作，这样在反向传播的过程中，停止工作的神经元的参数权重就不会被更新。这样就可以使模型泛化性能更强。 关于Dropout的类比（转载自https://blog.csdn.net/stdcoutzyx/article/details/49022443） 虽然直观上看dropout是ensemble在分类性能上的一个近似，然而实际中，dropout毕竟还是在一个神经网络上进行的，只训练出了一套模型参数。那么他到底是因何而有效呢？这就要从动机上进行分析了。论文中作者对dropout的动机做了一个十分精彩的类比： 在自然界中，在中大型动物中，一般是有性繁殖，有性繁殖是指后代的基因从父母两方各继承一半。但是从直观上看，似乎无性繁殖更加合理，因为无性繁殖可以保留大段大段的优秀基因。而有性繁殖则将基因随机拆了又拆，破坏了大段基因的联合适应性。 但是自然选择中毕竟没有选择无性繁殖，而选择了有性繁殖，须知物竞天择，适者生存。我们先做一个假设，那就是基因的力量在于混合的能力而非单个基因的能力。不管是有性繁殖还是无性繁殖都得遵循这个假设。为了证明有性繁殖的强大，我们先看一个概率学小知识。 比如要搞一次恐怖袭击，两种方式： 集中50人，让这50个人密切精准分工，搞一次大爆破。将50人分成10组，每组5人，分头行事，去随便什么地方搞点动作，成功一次就算。哪一个成功的概率比较大？ 显然是后者。因为将一个大团队作战变成了游击战。 那么，类比过来，有性繁殖的方式不仅仅可以将优秀的基因传下来，还可以降低基因之间的联合适应性，使得复杂的大段大段基因联合适应性变成比较小的一个一个小段基因的联合适应性。 dropout也能达到同样的效果，它强迫一个神经单元，和随机挑选出来的其他神经单元共同工作，达到好的效果。消除减弱了神经元节点间的联合适应性，增强了泛化能力。 随想录噢，我学了学dropout的相关概念，dropout（层）会舍弃指定比例的神经元，将它们“断电”（不输出），从而提高模型的鲁棒性。（要学习的参数越多，越容易出现过拟合） 哦还有关于中间特征提取的理解，除了第1层的神经元负责接收n维的数据和最后1层的结果层，中间层的每1层的每1个神经元都可以看作是1个学习到的特征，比如中间 某1层 有100个神经元（100个特征），它的下1层有50神经元。（50个特征） 卷积神经网络卷积层填充 可以理解为扩充输入数据的大小，比如一个大小为（3， 3）的输入数据，经过填充可变为（4， 4），填充的值可以为任意整数。 卷积运算 对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用（乘积累加运算）。我愿称之为“滑动计算”。 滤波器里面的每个元素就是权重参数。 步幅 也就是上面提到的“一定间隔”，可以理解为步长。 注意：填充的值越大会使输出数据大小越大，而步幅增大则会使输出数据变小。 输入数据为三维数组的书写形式 —&gt; （C， H，W ），对应的维度的滤波器的书写形式 —&gt; （FC， FH，FW ） 如果涉及多个滤波器时，则写成（FN，FC， FH，FW ）其中FN表示滤波器的数量 池化层池化是缩小高、长方向上的空间的运算。池化运算也是以一定间隔平滑移动窗口。只不过这个窗口仅仅是一个窗口（没有参数元素，可以理解为一个框框，只是在框框限定的目标区域内进行取最大值【Max池化】或者平均值【Average池化】操作），比如下图给出的则是Max池化。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"/tags/机器学习/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"漫长的从零到一的JS调试之路","slug":"漫长的从零到一的JS调试之路","date":"2021-11-21T04:52:30.000Z","updated":"2022-06-14T11:48:43.168Z","comments":true,"path":"undefined/漫长的从零到一的JS调试之路/","link":"","permalink":"/undefined/漫长的从零到一的JS调试之路/","excerpt":"","text":"漫长的从零到一的JS调试之路集合引用类型Array创建数组 &lt;script&gt; //普通创建方式,使用构造函数 let colors = new Array(20) console.log(colors) //使用数组字面量 let color = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;] console.log(color) /* 创建数组的静态方法（两种）from(),of()，其中from()用于将类数组结构转换为数组，类数组是指有length属性和可索引元素的结构(字符串，集合，映射等)。of()用于将一组参数转换为数组 */ const strArr = Array.from(&#39;kitholt&#39;) console.log(strArr) const m = new Map().set(1,2).set(3,4) console.log(Array.from(m)) const s = new Set().add(1).add(2).add(3) console.log(Array.from(s)) //from()方法还能对数组进行 浅复制 const a1 = [1,[6,66],3,4] const a2 = Array.from(a1) a1[1][0] = 99 console.log(a2 === a1);//false console.log(a2[1][0]) &lt;/script&gt; 数组复制和填充 &lt;script&gt; /* copyWithin()用于批量复制数组。fill()用于向一个数组插入全部或者部分的值，通常需要指定范围，包含开始索引，不包含结束索引 */ const zeros = [0,0,0,0,0] zeros.fill(1,1,4)//用1，填充索引大于等于1且小于4的元素，预期结果[0, 1, 1, 1, 0] console.log(zeros) //值得一提的是，对于超出数组边界或者0长度再或者是索引方向相反的情况，fill()都不会报错，而是忽略 const ints = [0,1,2,3,4,5,6,7,8,9] ints.copyWithin(4,0,3)//结果为[0,1,2,3,0,1,2,7,8,9] console.log(ints) &lt;/script&gt; 数组排序方法 &lt;script&gt; /* 这里有两种方法，分别是reverse()和 sort()，其中reverse()能够接受一个比较函数，我们能够自定义这个 比较函数来决定是升序还是降序 */ const val = [1,4,2,5,41,32,7,6] val.sort((a, b) =&gt; a &gt; b ? 1 : a &lt; b ? -1 : 0)//升序排列 console.log(val) console.log(val.reverse()) //需要注意的是，这两种方法都返回调用它们数组的引用（会改变原数组） &lt;/script&gt; 数组的操作方法 &lt;script&gt; /* 关于数组操作的方法，有concat()，它能创建一个数组的副本，然后将参数添加到这个副本的末尾。 slice()用于切割数组，需要注意的是这个方法不会影响原来的数组。 强大的splice()，说它强大是因为这一个方法，能够实现删除，插入，替换的操作。 */ const arr = [&#39;fran&#39;,&#39;伟鸿&#39;,&#39;陈部&#39;,&#39;志坚&#39;] const arrConcat = arr.concat(&#39;胖子&#39;,&#39;仕豪&#39;,[&#39;浩彬&#39;,&#39;陈尹&#39;]) console.log(arrConcat)//[&#39;fran&#39;, &#39;伟鸿&#39;, &#39;陈部&#39;, &#39;志坚&#39;, &#39;胖子&#39;, &#39;仕豪&#39;, &#39;浩彬&#39;, &#39;陈尹&#39;] const arrSlice = arrConcat.slice(2)//从第二个位置开始拆分数组,还有一种方式dddd console.log(arrSlice) arr.splice(0,2) console.log(&#39;***&#39;,arr)//[&#39;陈部&#39;, &#39;志坚&#39;] arr.splice(1,0,&#39;胖子&#39;,&#39;仕豪&#39;) console.log(arr)//[&#39;陈部&#39;, &#39;胖子&#39;, &#39;仕豪&#39;, &#39;志坚&#39;] &lt;/script&gt; 数组的迭代器方法 &lt;script&gt; /* 对于一个数组，它有对应的索引，值，以及索引/值对。我们可以用下面三种方法来分别获取... */ const colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;] const colorsIndex = Array.from(colors.keys()) console.log(colorsIndex) for(let i of colors.values()){ console.log(i) } const colorVal = Array.from(colors.values()) console.log(colorVal) const colorEntries = Array.from(colors.entries()) console.log(colorEntries) &lt;/script&gt; 数组索引 &lt;script&gt; /* 对于数组的length属性，它不仅只读还可修改，通过修改length的属性，可以从数组末尾删除或者添加元素 */ const colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;] console.log(&#39;原数组&#39;,colors) //添加一个black colors[colors.length] = &#39;black&#39; console.log(&#39;插入black&#39;,colors) //将数组长度变为2 colors.length = 2 console.log(&#39;将数组长度变为2&#39;,colors) &lt;/script&gt; Map基本API &lt;script&gt; //创建一个map const myMap = new Map() myMap.set(&#39;k1&#39;,&#39;v1&#39;) .set(&#39;k2&#39;,&#39;v2&#39;) .set(&#39;k3&#39;,&#39;v3&#39;) /* get(),has(),delete()以及keys(),values(),entries()三个返回迭代器的方法 */ console.log(myMap) console.log(myMap.get(&#39;k1&#39;))//根据键获取对应的值 console.log(myMap.has(&#39;k2&#39;)) myMap.delete(&#39;k2&#39;) console.log(myMap) &lt;/script&gt; 注意点 &lt;script&gt; /* 键和值在迭代器中是可以修改的，但是映射内部的引用无法修改 */ const m1 = new Map([[&#39;k1&#39;,&#39;v1&#39;]]) for(let key of m1.keys()){ key = &#39;newKey&#39; console.log(key)//newKey console.log(m1.get(&#39;k1&#39;))//结果为v1 } /* 选择map还是obj？ 插入操作看map 查询操作用obj */ &lt;/script&gt; Set基本API &lt;script&gt; //set的方法包括add(),delete(),has(),size() const mySet = new Set(); mySet.add(&#39;v1&#39;).add(&#39;v2&#39;).add(&#39;v3&#39;).add(&#39;v3&#39;) console.log(mySet)//{&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;} const result = mySet.has(&#39;v1&#39;) console.log(result) &lt;/script&gt; 对象，类与面向对象编程对象合并对象 &lt;script&gt; /* 合并对象，顾名思义就是将两个对象进行合并。有时候也叫作“混入”，对象A（源对象）混入对象B（目标对象），注意该操作执行的【浅复制】9 */ let src, dest, result //定义目标对象 dest = {} //定义源对象 src = {id: &#39;src&#39;} //增强后的对象,与此同时dest对象也会被修改 result = Object.assign(dest, src) console.log(&quot;目标对象dest和增强后的对象result是否相等(同一个指针指向)？&quot;,result === dest) result.id = &quot;null&quot; console.log(result.id) console.log(dest.id) &lt;/script&gt; 增强的对象语法 &lt;script&gt; /* 什么是语法糖，就是能让程序猴写代码写起来更舒服的语法结构 1.属性值简写（属性名和变量名一样时，即可触发对象属性的简写形式） 2.简写方法名 3.可计算属性 （可以在对象字面量中动态完成属性赋值，中括号包围的对象属性键表示这个属性会随着中括号里面的变量值的改变而改变 具体操作如下） */ const name = &#39;fran_name&#39; const age = &#39;fran_age&#39; const major = &#39;fran_major&#39; const say = &#39;fran_say&#39; let person = { [name]: &#39;fran&#39;, [age]: 21, [major]: &#39;Software engineer&#39;, [say](){ console.log(`my name is ${this.fran_name}`) } } console.log(person)//{fran_name: &#39;fran&#39;, fran_age: 21, fran_major: &#39;Software engineer&#39;} /* 这种操作有点像，先挖一个萝卜坑（中括号），给每个坑一个编号（变量名）然后再种萝卜（变量的值） */ /* 另外可计算属性和简写方法名能够“联动”产生一些“节目”效果,方法名也是对象的一个属性，它也是可以计算的,在方法名外面也可以加[] */ person.fran_say()//my name is fran &lt;/script&gt; 对象属性的类型 &lt;script&gt; /* 属性分为： 数据属性(就是我们平时定义的属性，包含一个保存数据值的位置。值会从这个位置读取，同时修改后也会写入到这个位置) 另外需要注意的是：我们可以对数据属性进行进一步地“约束”，这种“约束”叫作属性的特性。有四个特性configurable【属性是否能够删除】，enumerable【属性是否可以循环】，writable【属性的值是否能够修改】，value 利用Object.defineProperty()时，这四个特性默认都是false，当然可以人为设置 访问器属性(不含数据值，包含一个setter和getter函数)-----------------&gt;响应式数据的底层实现!!!!!!! get函数(当访问访问器属性时，会被调用，用于返回一个有效值) set函数(当写入 访问器属性时，会被调用，接收传入的新值，对数据进行修改) */ let person = {} person.name = &#39;jack&#39; console.log(person.name) Object.defineProperty(person,&#39;age&#39;,{ writable: false, configurable: false, value: 18 }) console.log(person.age) person.age = 21 console.log(person.age)//结果仍为18，因为writable设置了false，也就是说属性的值无法修改 delete person.age//删除属性无效 //下面演示一下“响应式数据”---摘（改）（抄）自js高级程序设计 let book = { year_: 2021, edition: 1, } Object.defineProperty(book,&#39;year&#39;,{ get(){ return this.year_ }, set(newVal){ if(newVal &gt; 2021){ this.year_ = newVal this.edition = newVal - 2021 } } }) book.year = 2025 console.log(book.edition)// 4 //现在想想，vue里的data配置项中的数据（每一个vc的属性）都会为每个数据匹配一个专有的访问器属性，当数据被修改的时候，会调用其对应的setter方法 &lt;/script&gt; 对象解构 &lt;script&gt; /* 对象解构？官方说法就是 使用与 对象匹配的结构 来实现 对象属性赋值 大白话就是，如果你像得到某个对象的一些属性的值并用一些变量保存起来，最常规的做法就是 变量 = 对象.属性 */ let person = { name: &#39;fran&#39;, age: 21, shoes:{ nike: &#39;nike&#39;, anta: &#39;anta&#39;, } } //常规赋值 let name = person.name let age = person.age console.log(&#39;常规赋值&#39;) console.log(name,age) //使用解构赋值 let {name: myName, age: myAge} = person console.log(&#39;解构赋值&#39;) console.log(myName, myAge) //值得注意的是，如果有对象以参数传入某个函数，我们也能对这个对象参数进行解构赋值，比如下面这个例子 let showShoes = function({shoes:{nike, anta}}){ console.log(nike, anta) } //传入的是一个person对象，但是会将该对象的shoes属性结构出来 showShoes(person) &lt;/script&gt; 构造函数构造函数 &lt;script&gt; /* 在js里，函数和构造函数也是属于Object这个祖先类，引入构造函数是为了更进一步确定对象类型 比如obj1 = {}，这是Object的实例，而person = new Person()，它既是Object的实例，也是Person的实例 如何区分普通函数和构造函数？ 使用new操作符调用的函数就是构造函数 一般构造函数的函数名第一个字母是大写，普通函数的则是小写 */ //开始定义构造函数， ？？应该能理解为创建一个类？？ function Person(name, age) { this.name = name this.age = age this.sayName = function(){ console.log(`halo, my name is ${this.name}. I am ${this.age}.`) } } let fran = new Person(&#39;fran&#39;,21)//halo, my name is fran. I am 21. fran.sayName() &lt;/script&gt; 继承（原型）原型 &lt;script&gt; /* 原型是构造函数的一个属性，这个属性是一个对象，上面有特定引用类型对象的共享方法和属性，从而实现所有属性和方法在所有实例之间是共享的 */ function Person(name, age) { this.name = name this.age = age //定义一个原型上的方法. Person.prototype.sayName = function(){ console.log(`halo, my name is ${this.name}. I am ${this.age}.`) } } let jack = new Person(&#39;jack&#39;,19) let fran = new Person(&#39;fran&#39;,21) jack.sayName() fran.sayName() &lt;/script&gt; 组合继承 &lt;script&gt; /* 组合继承，综合了原型链和盗用构造函数，将两者的优点结合了。在原型链的原型上继承属性和方法，而子类实例的属性则通过盗用构造函数（调用父类的构造方法）来进行赋值 */ function Person(name){ this.name = name this.nationality = [] } Person.prototype.sayName = function(){ console.log(`my name is ${this.name}`) } function YellowGuy(name, age){ Person.call(this,name) this.age = age } YellowGuy.prototype = new Person() YellowGuy.prototype.sayAge = function(){ console.log(`i am ${this.age}`) } let fran = new YellowGuy(&#39;fran&#39;,21) fran.sayName() fran.sayAge() fran.nationality.push(&#39;China&#39;) console.log(fran.nationality[0]) &lt;/script&gt; 原型式继承 &lt;script&gt; /* 使用背景： 你有一个对象，想在它的基础上再创建一个新的对象。你可以采取前面讲到的组合继承，但是组合继承有的时候是需要事先“约定”好的，不能很好的做到随时使用。我们可以封装一个函数Object(),传入要在此基础上修改的对象，返回一个新的对象，这个新的对象的原型指向传入的这个对象 但是需要注意的是：属性中包含引用值始终会在相关对象之间共享 该方式最大的有点就是减少了构造函数的创建。想在那个对象基础上创建一个新的对象，只需要将这个对象传入Object函数 */ function object(o){ function NewObj() {} NewObj.prototype = o return new NewObj() } let person = { name: &#39;&#39; } let fran = object(person) fran.name = &#39;fran&#39; console.log(fran.name) /* 寄生式继承和它类似，只不过多了个增强对象环节（增加新的方法），然后再将这个新对象返回... */ &lt;/script&gt; 寄生式组合继承 &lt;script&gt; /* 听名字就是组合继承的改进版，它是为了解决组合继承的效率问题，最主要的效率问题是父类构造函数会被调用两次，一次是在子类原型创建时调用，另外一次是在子类的构造函数中调用。 其实子类原型只要包含父类对象的实例属性即可，子类构造函数只要再执行的时候重写自己的原型即可 具体实现步骤就是：①利用寄生式继承来继承父类原型②执行完①会得到一个新对象，再将这个对象赋值给子类原型 仔细想想，组合继承的子类原型是父类构造函数的一个实例，而寄生式组合继承的则是一个“过渡对象”（这个对象的原型就是父类原型） */ function object(o){ function NewObj() {} NewObj.prototype = o return new NewObj() } let Person = function(name){ this.name = name } let ChinesePerson = function(name, age){ Person.call(this, name)//重点！！！！！！！！！！！！！！这里调用父类的构造方法 this.age = age } //核心方法，这一步代替了 ChinesePerson.prototype = new Person()，减少一次调用父类构造方法的次数 function inheritPrototype(subType, superType){ //利用寄生式继承里面的object方法来得到“过渡对象” let prototype = object(superType.prototype) //执行完①会得到一个新对象，再将这个对象赋值给子类原型 subType.prototype = prototype } inheritPrototype(ChinesePerson, Person) let fran = new ChinesePerson(&#39;fran&#39;,21) console.log(fran) &lt;/script&gt; 类类构造函数 &lt;script&gt; /* 什么是类构造函数？简单说就是在 类创建实例的时候 要调用的函数，此外要调用类构造函数一定要用new操作符！！! */ class Person{ //下面这就是Person的类构造函数- -，构造函数用于对实例进行相关属性方法的赋值操作 constructor(name){ this.name = name this.sayName = function(){ console.log(`my name is ${this.name}`) } } } let p1 = new Person(&#39;fran&#39;) p1.sayName() //let p2 = Person() //报错 Uncaught TypeError: Class constructor Person cannot be invoked without &#39;new&#39; let p3 = new Person.constructor() console.log(p3 instanceof Person.constructor) &lt;/script&gt; 抽象基类 &lt;script&gt; /* 抽象基类？？？不就是抽象类嘛，在java中定义抽象类一个abstract关键字就好了，但是在js中要在需要定义成抽象类的constructor中使用new.target来检测，new.target会保存 通过new关键字调用的类或函数，通过比较可以阻止对抽象基类的实例化 想想，因为js里没有abstract这个关键字，所以默认 所有的类都是可以实例化的。现在又引入了抽象基类这个概念，只好将识别 抽象基类的环节 推迟到constructor中执行，new.target作为一个检查点，如果new的是一个 抽象基类 就会抛出错误 */ class Vehicle{ constructor(price){ this.price = price //设置“检查点，如果发现new的是Vehicle就抛出错误” if(new.target === Vehicle){ throw new Error(&#39;不好意思，Vehicle是一个抽象基类，无法被实例化- -，请实例化它的子类，不用谢&#39;) } /* if(!this.foo){ throw new Error(&#39;这个子类必须实现foo方法&#39;) } console.log(&#39;创建Vehicle的子类实例成功&#39;) */ } showPrice(){ console.log(`这辆车的价格是${this.price}w`) } /* foo(){ console.log(&#39;foo&#39;) } */ } Vehicle.prototype.foo = function(){ console.log(&#39;foo&#39;) } class Car extends Vehicle{ constructor(brand,price){ //注意子类的类构造函数内一定要先执行父类的类构造方法！！！不然会报错 super(price) this.brand = brand this.showBrand = function(){ console.log(`这辆车是${this.brand}`) } } /* foo(){ console.log(&#39;foo&#39;) } */ } //下面尝试new一下这个抽象基类（必抛错） //let car = new Vehicle()//Uncaught Error: 不好意思，Vehicle是一个抽象基类，无法被实例化- -，请实例化它的子类，不用谢 at new Vehicle (抽象基类.html:19) let toyota = new Car(&#39;丰田&#39;,20) let auto = new Car(&#39;大众&#39;,10) toyota.showBrand() toyota.foo() console.log(toyota.brand === auto.brand) &lt;/script&gt; 原型方法与访问器 &lt;script&gt; /* 为了能在实例之间能够共享方法，类定义语法把在 类块定义的方法作为 原型方法 另外，类定义也支持设置访问器 */ class Person{ //添加到this的所有内容都会存在于不同的实例上 constructor(name,age){ this.name = name /* 这是我之前犯的错误 this.age = age */ this.age_ = age this.locate = () =&gt; { console.log(&#39;instance&#39;) } /* this.sayAge = function(){ console.log(this.age) } */ } set age(age){ console.log(&#39;修改age&#39;) /* 同上 this.age = age */ this.age_ = age } get age(){ console.log(&#39;读取age&#39;) return this.age_ } //这个就是定义在类的原型的方法，从这里可以看出，该方法位于类块里，constructor之外 locate(){ console.log(&#39;prototype&#39;) } } let p1 = new Person(&#39;fran&#39;,21) console.log(p1.name) p1.locate()//instance Person.prototype.locate()//prototype p1.age p1.age = 22 /* 在设置访问器的时候遇到了栈溢出的问题：产生这个问题的原因很简单但是我一开始并没有发现：我把访问器的属性和实例属性写成一样的了。访问器属性的工作原理是：当访问到该属性，该属性本身是不会存放数据的，而是会调用set或者get函数，里面才是要处理的数据 就拿上面的age来说，实例属性和访问器属性都是age，乍一看合情合理：我访问age属性，自然就会调用相关函数改变age的值。大错特错，来看看set的内部有条this.age语句，这条语句相当于又访问了age这个访问属性，然后由调用set，然后.........就死循环最后就栈溢出了 解决方法很简单：属性命名不一样即可，一般真正用来存放数据的属性我们都会把它们“隐藏起来”（这样命名xxx_)，而访问器属性则直接命名xxx，有点代理的味道了 */ &lt;/script&gt; 不是小结的小结 顶不住了，别人画的是思维导图，我画的是些什么玩意er，可能我的思维比较混乱吧- -至少它在我脑海是这个布局 DOOOOOM节点关系&lt;script&gt; /* 什么是节点，简单讲就是html标签（有点不严谨，确实不严谨），每个文档（document）是一个网页的根节点，这个根节点有一个唯一的子节点---&lt;html&gt;，也叫文档元素，所有的文档元素都在这个元素之内 节点之间两种关系：父子关系、同胞关系 每个节点都有一个childNodes和parentNodes属性，其中childNodes属性的值是一个NodeList类数组对象，存放的是一个有序节点（按照html标签的出现顺序），因为是一个类数组，我们可以用中括号或者item()的方法访问里面的元素 另外在childNodes里，每个childNode还有一个nextSibling和previousSibling属性，分别指向自己的后一个、前一个同胞元素 还有一点需要补充的是，父节点还有firstchild和lastChild两个属性，专门来访问第一个节点和最后一个节点 下面是简单的调试环节 */ //获取文档元素html let html = document.documentElement let htmlChildren = html.childNodes console.log(htmlChildren)//NodeList(3) [head, text, body] let head = html.firstChild console.log(head) let body = html.lastChild console.log(body) let headChildren = htmlChildren[0].childNodes console.log(headChildren) &lt;/script&gt; 操作节点/* 操纵节点的一些方法 appendChild(), insertBefore(), replaceChild(), removeChild()，其中appendChild()是将元素插入到末尾，insertBefore()可以指定插入节点的位置, 剩下俩个不用过多解释- - 此外还有cloneNode()方法，通过传一个布尔参数来决定是否开启深复制，若为true则复制该节点以及其整个子DOM树，反之只复制该节点 normalize()方法，后续会进行补充... */ let ul = document.documentElement.lastChild.childNodes[1] console.log(ul) let li = document.createElement(&#39;li&#39;) li.innerHTML = 5 ul.appendChild(li) ul.removeChild(li) //偷懒，就不演示了 &lt;/script&gt; 定位元素/* getElementById(), getElementByTagName()等返回的都是一个HTMLCollection对象，它和前面的NodeList很像，唯一的区别就是前者有一个额外的方法namedItem(),通过标签的name属性取得某一项的引用 通过查阅相关资料，NodeList包含的是一个节点的所有节点（包括了元素节点），而HTMLCollection只包含其元素节点，通过下面的一个小例子就能看出它们之间的差别 */ let htmlNodeList = document.documentElement.childNodes console.log(htmlNodeList)//NodeList(3) [head, text, body] let htmlHTMLCollection = document.documentElement.children console.log(htmlHTMLCollection)//HTMLCollection(2) [head, body] /* 我们能看到多出了个TEXT_NODE */ &lt;/script&gt; MutationObserver&lt;script&gt; /* 这个强大的接口能够在DOM被修改时异步执行回调，使用这个接口能够观察文档，DOM树的一部分或者某个元素，或者元素属性、子节点、文本的变化 基本用法： 1.创建实例，并传入一个回调处理函数 2.使用observe()为该实例绑定观察对象，传两个参数，一个参数是指定要观察的DOM节点，第二个参数是一个配置对象，用于指定观察哪些方面的变化 每个回调都会收到一个MutationRecord实例的数组，这个数组记录了发生变化的相关信息 想想，貌似vue的$nextTick函数的实现原理好像就是这个... */ let observer = new MutationObserver(() =&gt; console.log(&#39;&lt;body&gt; 标签的属性被改变了！！！&#39;)) observer.observe(document.body, {attributes: true}) document.body.className = &#39;foo&#39; console.log(&#39;改变body的css类名&#39;) /* 我们来观察一下回调执行的时机 结果： 改变body的css类名 &lt;body&gt; 标签的属性被改变了！！！ */ &lt;/script&gt; Selectors_API&lt;script&gt; /* 可以替代之前的getElementById()和getElementByTagName() querySelector()：接收CSS选择符参数，返回匹配的节点 querySelectorAll()：接收CSS选择符参数，返回所有匹配的节点，所有实例包装在NodeList中 matches(): 接收CSS选择符参数，如果元素匹配则该选择符返回true，反之返回false */ console.log(document.body.querySelectorAll(&#39;p&#39;))//NodeList(6) [p, p, p, p, p, p], 需要注意的是，这个返回的NodeList是一个“静态”的，并非“实时”的 console.log(document.body.matches(&#39;body.p&#39;)) &lt;/script&gt; CSS类扩展&lt;script&gt; /* classList属性，要操作类名，可通过此属性实现，HTML5提供了一下方法： add(),contains(),remove(),toggle() */ let div = document.querySelector(&#39;.red&#39;) div.classList.remove(&#39;red&#39;) div.classList.add(&#39;green&#39;) console.log(div.style) &lt;/script&gt; 插入标记&lt;script&gt; /* 两个属性： innerHTML:dddd outerHTML:调用它的元素会被传入的HTML字符串解析生成的HTML DOM子树给取代 两个方法，都接收两个参数（插入标记的位置，要插入的HTML或者文本）： 插入标记位置的可选参数： 1. beforebegin：元素之前，相当于在前面插入一个同胞节点 2. afterbegin：元素开头内部，相当于插入一个子节点 3. beforeend： 元素末尾内部，相当于插入一个子节点（末尾） 4. afterend： 元素之后，相当于在后面插入一个同胞节点 insertAdjacentHTML()，insertAdjacentText() */ &lt;/script&gt; 遍历&lt;script&gt; /* 所谓遍历就是遍历DOM结构，有两种类型来遍历 1. NodeIterator 使用document.createNodeIterator()创建，该方法需要接收四个参数（[要遍历根节点的节点]，[要访问哪些节点]，[过滤对象 || 过滤函数]，[扩展实体引用]） （whatToShow）要访问哪些节点，这个参数对应的常量是在NodeFilter中定义的 关于过滤对象的使用： 过滤对象NodeFilter只有一个acceptNode()方法，具体实现下面会有 节点迭代器有两个主要的方法：nextNode()，previousNode() 2. TreeWalker,这可以说是前者的升级版，额外添加了不同方向遍历的方法： parentNode() firstChild() lastChild() nextSibling() previousSibling() */ //定义一个过滤对象NodeFilter，该过滤对象表示只接收&lt;p&gt;元素的节点 let filter = { acceptNode(node){ return node.tagName.toLowerCase() == &#39;p&#39; ? NodeFilter.FILTER_ACCEPT: NodeFilter.FILTER_REJECT } } let div = document.querySelector(&#39;.div1&#39;) let iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false); let node = iterator.nextNode() while(node != null){ console.log(node.tagName) node = iterator.nextNode() } &lt;/script&gt; 待续…函数没有重载、有默认参数值 &lt;script&gt; /* js函数并不能像传统编程那样重载，因为没有签名（接收参数的类型和数量），因此如果定义了两个同名方法，则后面定义的会覆盖掉先定义的 在es6之后，能够支持显式定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋值 值得一提的是，默认参数值不限于原始值和对象类型，也可以使用调用函数返回的值 */ function addNum(num){ return num + 100 } function addNum(num){ return num + 200 } let result = addNum(30) console.log(result)//230 function giveName(name = &#39;foo&#39;){ return `halo, my name is ${name}` } let sentence = giveName() let sentence2 = giveName(&#39;kitholt&#39;) console.log(sentence)//halo, my name is foo console.log(sentence2)//halo, my name is kitholt //参数也存在于自己的作用域，它们不能引用函数体的作用域，下面这种操作如果不传第二个参数的话会报错 function makeKing(name = &#39;jack&#39;, numerals = defaultNumeral){ let defaultNumeral = &#39;2&#39; return `King ${name} ${numerals}` } console.log(makeKing(undefined,2))//King jack 2 console.log(makeKing())//报错 &lt;/script&gt; 函数声明与函数表达式 &lt;script&gt; /* 在前面我们知道，函数声明和函数表达式都可以定义一个函数，但是他们有个很重要的区别。 这个区别就是js引擎在执行任何代码之前，会先读取函数声明，然后再生成函数定义，而对于以函数表达式定义的函数只能等到代码执行到它那一行才会生成函数定义 */ //使用函数声明定义函数 console.log(sayName()) function sayName(){ return &#39;my name is kitholt&#39; } //使用函数表达式声明函数 console.log(sayAge())//Uncaught ReferenceError: Cannot access &#39;sayAge&#39; before initialization at 函数声明与函数表达式.html:22 let sayAge = function(){ return &#39;21&#39; } &lt;/script&gt; 扩展运算符 &lt;script&gt; /* 扩展运算符 1. 扩展参数：对可迭代对象应用扩展运算符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入 2. 收集参数（我愿称之为“捡漏”）,【...】收集参数的结果是一个Array实例，它只能作为最后一个参数传入，因为收集参数的结果是可变的，假如作为第一个参数传入， 那么所有的传入的参数都会被“打包”成Array实例，反之如果放在最后一个，它会“打包”剩余的参数 */ function getSum(){ let num = 0; for(let i = 0; i &lt; arguments.length; i++){ num += arguments[i] } return num } let values = [1, 2, 3, 4] console.log(getSum(...values))//对参数进行扩展运算 function ignoreFirst(firstValue, ...values){ console.log(values) } ignoreFirst()//[] ignoreFirst(233)//[] ignoreFirst(1,2,3)//[2, 3] &lt;/script&gt; 函数的this对象 &lt;script&gt; /* 在标准函数中，this引用的是把函数当成方法调用的上下文对象 关于this的指向问题，简单说就是谁是调用者，这个this就指向它 getId这个方法返回的是一个匿名函数，在匿名函数中的this是不会绑定到某个对象的，也就是说this会指向window */ window.id = &#39;Window&#39; let obj = { id: &#39;obj&#39;, getId(){ return function(){ return this.id } } } console.log(obj.getId()())//Window /* 那如果得到obj的id呢？在内部函数的外面 将指向obj的this保存起来再在内部函数里引用就好了 */ let obj1 = { id: &#39;obj1&#39;, getId(){ let that = this return function(){ return that.id } } } console.log(obj1.getId()())//obj1 &lt;/script&gt; 私有变量 &lt;script&gt; /* 任何定义在函数或者块中的变量，都可以认为是私有的 可以利用闭包实现私有变量的定义 */ function MyObj(){ let privateVal = 10 function privateFun(){ return false } this.publicMethod = function(){ privateVal++ return privateFun() } } let myObj = new MyObj() console.log(myObj.privateVal)//undefined myObj.privateFun()//私有变量.html:28 Uncaught TypeError: myObj.privateFun is not a function /* 静态的私有变量，需要用匿名函数表达式 创建一个包含 构造函数 及其方法 的私有作用域 公有方法需要定义在原型上 */ &lt;/script&gt; 模块模式 &lt;script&gt; /* 模块模式使用一个匿名函数返回一个对象，在匿名函数内部，先定义私有变量和私有函数，之后，创建一个匿名函数要返回的对象字面量，这个对象只包含公开访问的属性和方法 比如在web开发中，经常要使用单例对象管理应用程序级的消息 */ function Component(id){ this.id = id } //单例模式创建app let app = function(){ let components = new Array() //返回一个对象字面量 return { getComponentCount(){ return components.length }, registerComponent(component){ if(typeof component == &#39;object&#39;){ components.push(component) } } } }() console.log(app) let c1 = new Component(&#39;1&#39;) let c2 = new Component(&#39;2&#39;) let c3 = new Component(&#39;3&#39;) app.registerComponent(c1) app.registerComponent(c2) app.registerComponent(c3) console.log(app) console.log(app.getComponentCount()) &lt;/script&gt; 结？（不完整） 事件 &lt;script&gt; /* js函数并不能像传统编程那样重载，因为没有签名（接收参数的类型和数量），因此如果定义了两个同名方法，则后面定义的会覆盖掉先定义的 在es6之后，能够支持显式定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋值 值得一提的是，默认参数值不限于原始值和对象类型，也可以使用调用函数返回的值 */ function addNum(num){ return num + 100 } function addNum(num){ return num + 200 } let result = addNum(30) console.log(result)//230 function giveName(name = &#39;foo&#39;){ return `halo, my name is ${name}` } let sentence = giveName() let sentence2 = giveName(&#39;kitholt&#39;) console.log(sentence)//halo, my name is foo console.log(sentence2)//halo, my name is kitholt //参数也存在于自己的作用域，它们不能引用函数体的作用域，下面这种操作如果不传第二个参数的话会报错 function makeKing(name = &#39;jack&#39;, numerals = defaultNumeral){ let defaultNumeral = &#39;2&#39; return `King ${name} ${numerals}` } console.log(makeKing(undefined,2))//King jack 2 console.log(makeKing())//报错 &lt;/script&gt; 函数声明与函数表达式 &lt;script&gt; /* 在前面我们知道，函数声明和函数表达式都可以定义一个函数，但是他们有个很重要的区别。 这个区别就是js引擎在执行任何代码之前，会先读取函数声明，然后再生成函数定义，而对于以函数表达式定义的函数只能等到代码执行到它那一行才会生成函数定义 */ //使用函数声明定义函数 console.log(sayName()) function sayName(){ return &#39;my name is kitholt&#39; } //使用函数表达式声明函数 console.log(sayAge())//Uncaught ReferenceError: Cannot access &#39;sayAge&#39; before initialization at 函数声明与函数表达式.html:22 let sayAge = function(){ return &#39;21&#39; } &lt;/script&gt; ### 动画与Canvas图形requestAnimationFrame（下面介绍摘自阮一峰老师的博客） 设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。 requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。 &lt;script&gt; /* requestAnimationFrame，瞎翻译：请求动画帧函数 该方法接收一个参数：是要在重绘屏幕前调用的函数 值得注意的是这个参数函数还能接收一个参数，该参数表示下次重绘的时间（待补充...） 额外注意：dom元素的style对象和dom元素的css样式表两者是独立的,没有任何关系，JS只能操作或修改行内样式！！！ */ var a = 0; function step(){ a++; console.log(a) var g = requestAnimationFrame(step) if(a&gt;=100){ cancelAnimationFrame(g) } } step() &lt;/script&gt; 该方法也会返回一个请求ID，可以用于通过另外一个方法cancelAnimationFrame()来取消任务，这有点像setTimeout() 补充要点：什么是回流和重绘？ 回流：页面中元素尺寸、布局或者隐藏而需要重新构建页面 以下操作会引起回流 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 重绘：元素的外观发生改变，但是布局没有发生改变 在页面设计中药尽量减少回流和重绘的次数，这就是所谓的性能优化（高阶操作） 改变样式尽量集中改变，可以使用class属性给多个元素同时添加 position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响 优化动画- - … 绘制矩形 &lt;canvas class=&quot;drawing&quot; width=&quot;800&quot; height=&quot;300&quot; style=&quot;background-color: honeydew;&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /* 创建画布：&lt;canvas&gt;&lt;/canvas&gt; 获取画布的上下文：getContext()，根据接收的参数来决定获取的是什么类型的画布上下文对象，比如传入&#39;2d&#39;---一定要传参，不然会报错 两个基本属性：填充（fillStyle）和描边（strokeStyle） 矩形是唯一一个可以直接在2D画布中直接绘制的形状 相关方法（都接受四个参数：x坐标，y坐标，矩形宽度，矩形高度）： 1. fillRect() 2. strokeRect() 3. clearRect() 清除画布某个区域，可以用于“打孔” 注意： 1. lineWidth：描边宽度 2. lineCap控制线条端点[&#39;butt&#39;, &#39;round&#39;, &#39;square&#39;] 3. lineJoin控制线条交点的形状[&#39;round&#39;, &#39;bevel(取平？)&#39;, &#39;miter(出尖)&#39;] */ let drawing = document.querySelector(&#39;.drawing&#39;) let context = drawing.getContext(&#39;2d&#39;) //画一个红色矩形 context.fillStyle = &#39;red&#39; context.fillRect(10, 10, 50, 50) //给这个红色的矩形描一下边 context.strokeStyle = &#39;black&#39; //设置描边宽度 context.lineWidth = 10 context.strokeRect(10, 10, 50, 50) //再画一个透明的蓝色矩形 context.fillStyle = &#39;rgba(0, 0, 255, 0.5)&#39; context.fillRect(30, 30, 50, 50) //在这两个矩形重叠的地方打个“孔” context.clearRect(40, 40, 10, 10) &lt;/script&gt; 绘制路径&lt;script&gt; /* Path路径，通过路径可以创建复杂的形状和线条。绘制路径的一般流程是 1. 创建路径beginPath() 2. 开始操作arc(), arc(), lineTo(), moveTo()... 3. 结束路径closePath() 4. 描画路径 绘制文本(接收参数：要绘制的字符串，x坐标，y坐标，可选的最大像素宽度)： 1. fillText() 2. strokeText() */ let drawing = document.querySelector(&#39;.drawing&#39;) let context = drawing.getContext(&#39;2d&#39;) //现在来尝试画一个不带数字的表盘 //先将“画笔”移到画布中央,此时原点（0,0）被移动此处 context.beginPath() context.translate(400, 400) //半径为400px，画一个圆 context.arc(0, 0, 400, 0, 2 * Math.PI, false) //半径为390px，画一个内圆 context.arc(0, 0, 390, 0, 2 * Math.PI, false) context.rotate(1) //画一个时针 context.moveTo(0, 0) context.lineTo(0, -360) //画一个分针 context.moveTo(0, 0) context.lineTo(-330, 0) //结束路径 context.closePath() //描画路径 context.stroke() //给表盘顶部添加数字12 context.font = &#39;bold 14px Arial&#39; context.textAlign = &#39;center&#39; context.textBaseline = &#39;middle&#39; context.fillText(&#39;12&#39;, 0, -375) &lt;/script&gt; 阴影&lt;script&gt; /* context这个笔可以根据以下属性自动为已有形状或路径生成阴影 shadowColor，shadowOffsetX，shadowOffsetY，shadowBlur 如何使用：只要在绘制图形或者路径前设置好适当的值即可 */ let drawing = document.querySelector(&#39;.drawing&#39;) let context = drawing.getContext(&#39;2d&#39;) context.shadowOffsetX = 5 context.shadowOffsetY = 5 context.shadowColor = &#39;green&#39; //画一个红色矩形 context.fillStyle = &#39;red&#39; context.fillRect(10, 10, 50, 50) &lt;/script&gt; 渐变&lt;script&gt; /* 标准画布的兄弟---线性渐变画布 let gradient = context.createLinearGradient(x1, y1, x2, y2) 四个参数：起始xy坐标和终点xy坐标 调用addColorStop()为渐变指定颜色，接收两个参数，第一个表示色标位置，范围是0-1，第二个是css颜色字符串 之后将这个对象赋值给fillStyle或者strokeStyle 忘了说了，有线性渐变就自然有径向渐变createRadialGradient()，接收六个参数，前三个指定起点圆形的xy坐标和半径，后三个指定终点圆形的... */ let drawing = document.querySelector(&#39;.drawing&#39;) let context = drawing.getContext(&#39;2d&#39;) //创建渐变画布 let gradient = context.createLinearGradient(0, 0, 800, 300) gradient.addColorStop(0,&#39;red&#39;) gradient.addColorStop(0.5,&#39;yellow&#39;) gradient.addColorStop(0.6,&#39;pink&#39;) gradient.addColorStop(1,&#39;blue&#39;) //线性渐变填充，这里会占画布的1/2 context.fillStyle = gradient context.fillRect(0, 0, 400, 300) //创建径向渐变 let radialGradient = context.createRadialGradient(600, 150, 90, 490, 150, 200) radialGradient.addColorStop(0,&#39;white&#39;) radialGradient.addColorStop(0.5,&#39;purple&#39;) radialGradient.addColorStop(1,&#39;black&#39;) //径向渐变填充 context.fillStyle = radialGradient context.fillRect(400, 0, 400, 300) &lt;/script&gt; 图案 &lt;script&gt; /* 如何使用： 1. createPattern(),接收两个参数：一个HTML&lt;img&gt;元素和如何重复图像的字符串 2. 将填充样式设置为图案，context.fillStyle = pattern 3. 调用fillRect方法 */ &lt;/script&gt; 图像数据 &lt;canvas class=&quot;drawing&quot; width=&quot;2000&quot; height=&quot;2000&quot;&gt;&lt;/canvas&gt; &lt;img src=&quot;img/img1.jpg&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;300&quot; id=&quot;img1&quot;&gt; &lt;script&gt; /* 使用getImageData()获取画布上原始图像数据，该方法返回一个ImageData实例，有三个属性：width，height和data，data是一个包含图像所有的原始像素信息的数组 每个像素在数组中都有4个值表示分别表示红绿蓝透明，比如说第一个像素的信息是在数组第0到第3个值中，后面的以此类推 一个小应用：灰阶过滤器 */ let drawing = document.querySelector(&#39;.drawing&#39;) let ctx = drawing.getContext(&#39;2d&#39;) let image, imageData, red, green, blue, len, average //console.log(ctx) image = document.getElementById(&#39;img1&#39;) //在画布上绘制图像 window.onload = function(){ ctx.drawImage(image, 0, 0, 500, 300) //取得图像数据 imageData = ctx.getImageData(0, 0, image.width, image.height) data = imageData.data len = data.length for(let i = 0; i &lt; len; i += 4){ red = data[i] green = data[i+1] blue = data[i+2] //三颜色求平均值 average = Math.floor((red + green + blue) / 3) //相当于过滤掉了颜色信息，只留下灰度信息（我不太知道这是啥原理...） data[i] = average data[i+1] = average data[i+2] = average } //将修改的数据写回，并在画布上重新显示 imageData.data = data ctx.putImageData(imageData, 0, 0) } /* 在完成这个应用的过程中遇到一些小坑 一般图片的获取都是需要一定时间的，而drawImage()这个方法是同步执行的，如果图片还没加载完毕，画布就显示不出来图片 解决方法： 1. 对图片的操作全都放在window.onload里面 2. 使用promise异步完成，当图片加载完毕时在调用drawImage()--------------------------------------出错了，暂时找不到- - 下面使用promise来尝试解决 */ /* let promise = new Promise((resolve, reject) =&gt;{ if(image){ resolve() }else{ console.log(&#39;图片还未加载完成...&#39;) } }) promise.then(() =&gt; { //绘制图像 ctx.drawImage(image, 0, 0, 500, 300) console.log(image.width) //取得图像数据 imageData = ctx.getImageData(0, 0, image.width, image.height) data = imageData.data console.log(&quot;23333&quot;,data) len = data.length for(let i = 0; i &lt; len; i += 4){ red = data[i] green = data[i+1] blue = data[i+2] //三颜色求平均值 average = Math.floor((red + green + blue) / 3) //相当于过滤掉了颜色信息，只留下灰度信息（我不太知道这是啥原理...） data[i] = average data[i+1] = average data[i+2] = average } //将修改的数据写回，并在画布上重新显示 imageData.data = data ctx.putImageData(imageData, 0, 0) }) */ &lt;/script&gt; 合成&lt;script&gt; /* globalAlpha：设置所有绘制内容的透明度，取值0-1 globalCompositeOperation：表示新绘制的形状如何与画布中已有的形状融合 */ let drawing = document.querySelector(&#39;.drawing&#39;) let ctx = drawing.getContext(&#39;2d&#39;) //globalAlpha的例子 ctx.fillStyle = &#39;red&#39; ctx.fillRect(0, 0, 80, 80) //改变全局透明度 ctx.globalAlpha = 0.5 ctx.fillStyle = &#39;blue&#39; ctx.fillRect(60, 60, 60, 60) //恢复全局透明度 ctx.globalAlpha = 1 ctx.fillStyle = &#39;red&#39; ctx.fillRect(500, 500, 80, 80) //红色矩形会出现在蓝色矩形上面 ctx.globalCompositeOperation = &#39;destination-over&#39; ctx.fillStyle = &#39;blue&#39; ctx.fillRect(560, 560, 60, 60) &lt;/script&gt; 小demo&lt;script&gt; /* 实现动画的三个基本步骤：清除画布---更新状态（位置）---渲染 目的：实现一个鼠标移动特效，鼠标在移动的过程中周围会有许多彩色小球在鼠标周围 */ //获取画布，对画布进行初始化操作,比如将画布的宽高设为和浏览器窗口的一样 let drawing = document.querySelector(&#39;.drawing&#39;) let ctx = drawing.getContext(&#39;2d&#39;) drawing.width = window.innerWidth drawing.height = window.innerHeight /* 需要用到的全局变量 1. 用于存放小球的数组ballArr 2. 圆周率π */ let ballArr = [] let P = Math.PI /* 创建小球： 小球有自己的圆心（xy坐标），以及用于模拟小球随机偏移的偏移量（dxdy），半径（radius），颜色（color），其中颜色属性使用一个随机函数getRandomColor()获取 更新自身位置的函数updatePosition()，以及一个用于显示小球的渲染显示函数renderBall() */ function Ball(x, y, r){ this.positionX = x this.positionY = y this.dx = parseInt(Math.random()*8 -4) this.dy = parseInt(Math.random()*8 -4) this.radius = r this.color = this.getRandomColor() //每创建一个小球，都将其加入小球数组，便于管理 ballArr.push(this) } //赋予每个小球不同的颜色，颜色字符串的六个数字通过随机数生成然后进行拼串操作得到的 Ball.prototype.getRandomColor = function(){ let color = &#39;#&#39; for(let i = 0; i &lt; 6; i++){ let randomColorNum = Math.floor(Math.random() * 9) color += randomColorNum } return color } /* 更新每个小球的位置状态, 每次移动小球都会逐渐变小，直至“消失”，小球消失的依据就是它的半径是否为负数 如果为负数就将其从小球数组中删除, 需要一个removeBall()函数 */ Ball.prototype.updatePosition = function(){ this.positionX += this.dx this.positionY += this.dy this.radius -= 0.3 if(this.radius &lt; 0){ this.removeBall() } } Ball.prototype.removeBall = function(){ for(let i = 0; i &lt; ballArr.length; i++){ if(ballArr[i] === this){ ballArr.splice(i,1) } } } //渲染显示函数renderBall(), 开始使用ctx对象 Ball.prototype.renderBall = function(){ ctx.beginPath() ctx.fillStyle = this.color ctx.arc(this.positionX, this.positionY, this.radius, 0, 2 * P, false) ctx.fillRect(this.positionX + 10, this.positionY + 10, this.radius, this.radius) ctx.fill() } /* 给鼠标绑定相关事件，以及执行动画操作 在这里需要注意的是，在更新每个小球的位置时，小球有可能会因为半径缩减为负数而从数组中被移除，因此在renderBall之前需要判断当前小球是否还在数组中 我之前就是直接updatePosition()后就调用renderBall()，结果就是动画效果只能执行一次 */ drawing.addEventListener(&#39;mousemove&#39;, function(event){ new Ball(event.offsetX, event.offsetY, 15) }) drawing.addEventListener(&#39;click&#39;, function(event){ for(let i = 0; i &lt; 15; i++){ new Ball(event.offsetX, event.offsetY, 15) } }) function animation(){ ctx.clearRect(0, 0, drawing.width, drawing.height) for(let i = 0; i &lt; ballArr.length; i++){ ballArr[i].updatePosition() if(ballArr[i]){ ballArr[i].renderBall() } } requestAnimationFrame(animation) } animation() &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于一个折磨了我快两天的不是bug的bug（低血压人士误入）","slug":"关于一个折磨了我快两天的不是bug的bug","date":"2021-11-12T17:33:00.000Z","updated":"2022-06-14T11:21:30.450Z","comments":true,"path":"undefined/关于一个折磨了我快两天的不是bug的bug/","link":"","permalink":"/undefined/关于一个折磨了我快两天的不是bug的bug/","excerpt":"","text":"关于一个折磨了我快两天的不是bug的bug（低血压人士误入）这是我在做一个todolist的时候遇到的…话不多说，上图 上面的代码的逻辑很简单，在输入框输入待办的任务task，由于双向绑定，将获得的task封装成一个taskObj对象（一条待办事项），然后通过触发自定义事件addTodo将这个taskObj对象传给父组件 之后由父组件向store提交commit… 以此来执行mutation里的ADDTODO方法，将新的待办事项插入到todolist中 嗯！一切看着都十分顺利，但是… 明明插入俩个不一样的待办事项并且他们的id是通过nanoid随机生成的，新的数据会覆盖掉之前插入的数据…对没错，女士们先生们就这个错误折磨我快两天（再次点题），我这两天心情极度低落，这只是一个简单的小demo却给我写成了这样。我一度怀疑我是不是白学了，我是不是应该注意进厂时机（说真的，我没有开玩笑）傅杰豪，你连这样一个错误都找不出来，你学伱抹的js、vue我把代码从头到尾看了不下十遍，一遍又一遍地调试，也是一点效果也没有…在床上无数次躺下，又坐起。当时我真的很想跳过这个demo，但是这个demo太重要了，它虽然小却“五脏俱全”，它涉及了vue的许多使用技巧，比如路由router、vuex、父子组件之间的数据传递等等。如果我跳过了，我后面怎么办？不是项目的demo就开始逃避不去攻克…光凭视频看的和那点自欺欺人的笔记就认为自己已经学了很多了？ 就在刚刚这个问题被解决了。我一开始总以为是vue的问题（版本问题？新版本bug？store的问题？）。我从未考虑关于js那些最基本的问题，仔细看看第一张截图，我在蓝色方框里定义了一个封装task的对象taskObj，是定义在commit方法之外的。这就意味着每次调用commit方法，我都会使用这一个对象，而且是反复使用（相当于一个全局变量）。因此… //插入第一条task，它的唯一id taskObj.id = nanoid() //插入第二条task，它的唯一id taskObj.id = nanoid() 第二次的id会覆盖掉第一次的id，甚至其他属性… 解决方法就是将这个第一张截图中的蓝色区域框的代码移到绿色框里，另外taskObj只是单纯用来封装task，因此不需要设置成响应式数据（我刚刚发现我这样写也不对…），直接改成普通对象就好了… 唉，基础不牢，地动山摇。说我书币吧，这个错误我又解决了，说我聪明吧，我还能被这个问题折磨两天…不管怎么说，能睡个好觉了…反面教材就是我，fran就是反面教材…","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"乱七八糟的css笔记以及踩坑经历","slug":"乱七八糟的css笔记以及踩坑经历","date":"2021-11-08T16:38:00.000Z","updated":"2022-06-14T11:47:32.247Z","comments":true,"path":"undefined/乱七八糟的css笔记以及踩坑经历/","link":"","permalink":"/undefined/乱七八糟的css笔记以及踩坑经历/","excerpt":"","text":"乱七八糟的css笔记以及踩坑经历animation应用之模拟雨滴下落&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body,html{ height: 100%; } .container{ position: relative; height: 100%; overflow: hidden; } .rain-drop{ position: absolute; width: 2px; height: 10px; background-color: black; animation: drops 1s ease-in infinite; clip-path: ellipse(50% 50% at 50% 50%); overflow: hidden; opacity: 0; } @keyframes drops { 0%{ opacity: 0; } 10%{ opacity: 1; } 90%{ opacity: 1; } 100%{ opacity: 0; transform: translate3d(100px,100vh,-100px); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;rain-drop&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;../js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 使用jquery获取画布容器以及雨滴div initPos表示每个雨滴的水平分布，top表示雨滴的垂直分布 delay表示雨滴下落的时机 循环30次，在每一次循环中 给每个雨滴添加写好的雨滴样式，并且设置好它们的初始位置 最后将每个雨滴逐个加入到画布容器container中 */ var $container = $(&#39;.container&#39;) var initPos = 0; for(let i = 0; i &lt; 30; i++){ let top = Math.floor(Math.random()*5+2) let delay = Math.floor(Math.random()*5+2) initPos += top let $div = $(&#39;&lt;div&gt;&lt;/div&#39;).addClass(&#39;rain-drop&#39;).css({ &quot;left&quot;: `${initPos}%`, &quot;top&quot;: `${top}%`, &quot;animation-delay&quot;: `${delay/5}s` }) $container.append($div) } &lt;/script&gt; &lt;/html&gt; 本次demo学习并了解到了下面这个属性： clip-path：这是一个区域裁剪属性，可以对一个图层进行任意形状的裁剪，比如本次demo中的ellipse，就是裁剪出一个椭圆，除此之外，还能裁剪出其他形状，比如圆形、矩形或者自定义的多边形 什么是BFCBFC全称block formatting context，也就是块级格式上下文，有点函数执行上下文的味道了，查阅资料后明白了，它是页面中的一块渲染区域，在此区域里，其子元素的摆放方式（垂直摆放）不会受到外部的影响。 计算BFC的高度时，浮动元素的高度也参与计算。因此可以将 把浮动元素包裹着的父元素转换成BFC，这样就能解决子元素浮动导致父元素高度塌陷的问题了！！！ 如何生成BFC（查阅资料） 1、float的值不是none。 2、position的值不是static或者relative。 3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex 4、overflow的值不是visible 关于流体布局 一边固定一边自适应 改变DOM位置的流体布局写法 不改变DOM位置的流体布局写法【左右栏都左浮动】，通过margin来调整之间的距离 流体布局进阶—智能自适应尺寸一边float一边display: table-cell 关于absolute属性的更多理解使用无依赖的绝对定位，也就是不使用“子绝父相”（能更好地实现自适应定位） absolute具有跟随性！！！所谓跟随性是指，元素开启无依赖的绝对定位前后的位置不会发生变化。举个栗子，一个span标签后面紧跟着一个div标签，div标签开启无依赖绝对定位后的位置不会发生变化 应用：可以将需要定位的元素的display属性设置为inline-block，让其紧紧跟随在目标元素后面，再利用margin属性去调整具体位置 动画尽量作用在绝对定位的元素上 关于margin属性的更多理解利用margin可以实现一端固定一段自适应布局（评论区=头像区+评论） 利用margin改变其占据尺寸 普通元素的百分比margin都是相对于容器的宽度计算的！！！ 绝对定位元素的百分比margin是相对于第一个祖先定位元素的宽度计算的！！！ 父子margin重叠的条件 margin-top重叠 父元素非bfc 父元素没有border-top设置 没有padding-top 父子元素之间没有inline元素分割 margin-bottom 与上述的类 空元素margin重叠 没有border设置 没有padding 没有inline元素 没有height或者min-height 设置绝对定位元素的top、left、right、bottom为0实现自动拉伸，在设置元素的宽高，最后使用margin即可实现居中显示 margin负值下的等高布局：一开始利用margin-bottom将元素高度变小（甚至消失），然后再利用padding-bottom来填充缺失的高度 margin负值下的两栏自适应布局：两栏使用浮动，通过调整margin-left和margin-right来进行调整两栏的间距","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"学个P的Vue","slug":"学个P的Vue","date":"2021-09-10T02:00:00.000Z","updated":"2022-06-14T11:37:24.275Z","comments":true,"path":"undefined/学个P的Vue/","link":"","permalink":"/undefined/学个P的Vue/","excerpt":"","text":"错了错了，是学个P(erfect)&gt;的VueVue的特点 组件化模式，提高代码复用率 声明式编码（无需直接操作DOM） hello Vue&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello, {{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; const x = new Vue({ el: &#39;#root&#39;,//用于指定vue为哪个容器服务 data: {//用于存储数据，数据供el所指定的容器去使用 name: &#39;Vue23333&#39; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注：一个vue实例对应一个容器（一夫一妻制） 模板语法 v-bind：用于对标签体的属性内容进行绑定，该语法也可简写为一个冒号 : 数据绑定 单向数据绑定（v-bind） 通过vue实例中（data）设置的值将其绑定在页面 双向数据绑定（v-model） 顾名思义 注意：双向绑定一般应用于表单类别元素（如input，select）v-model: value 可简写成v-model el和data的两种写法 关于el 常规写法，写在data里 使用Vue的直接原型上的$mount()方法 vue实例.$mount(#容器) 关于data 对象式 函数式（后期使用组件时，必须使用函数式） MVVM M（Model）：对应data里面的数据 V（View）：模板（页面） VM（ViewModel）：vue实例 数据代理 通过一个对象代理另外一个对象中属性的操作 运用方法：Object.defineProperty() 栗子： let obj1 = {x:1}; let obj2 = {y:10}; Object.defineProperty(obj2, &#39;x&#39;, { get(){ return obj1.x; }, set(value){ obj1.x = value; } }); 以上代码表示，可以通过obj2代理obj1进行属性的访问和修改 事件的使用 使用v-on: xxx或@xxx绑定事件 事件的回调需要配置在methods对象中 配置methods中的函数，尽量不要使用箭头函数，因为此时this的指向不再是vm对象而是window @click=”fun”和@click=”fun($event)”效果一致，只不过后者能够传参 事件修饰符 prevent：阻止默认行为 stop：阻止事件冒泡 once：事件只触发一次 capture：使用事件的捕获模式 self：只有event.target是当前操作的元素才触发事件 passive：事件的默认行为立即执行，元素无需等到事件回调执行完毕 计算属性（computed ） 定义：要用的属性不存在，要通过已有属性计算得来 原理：底层借助了Object.defineProperty方法提供的getter和setter get函数什么时候执行？（面试可能会问） 初次读取的时候会执行一次 当依赖的数据发生改变的时候会被再次调用 优势：与methods实现相比，内部有缓存，提高复用率，调试更加方便 备注： 计算属性会出现在vm上，可以直接使用 如果计算属性要被修改，那必须写set函数去响应修改，且要引起计算时依赖的数据发生改变 语法 const vm = new Vue({ el: &#39;.demo&#39;, data:{ firstname: &#39;张&#39;, lastname: &#39;三&#39; }, methods:{ fun(){ return this.firstname + &#39;-&#39; + this.lastname; } }, computed: { fullname:{//计算属性fullname，需要通过firstname和lastname get(){ return this.firstname + &#39;-&#39; + this.lastname; } } } }); 监视属性（watch）const vm = new Vue({ el: &#39;#root&#39;, data: { msg: &#39;111&#39; }, watch: { //第一种写法 msg: { immediate: true//初始化时让handler调用一下， handler(newValue, oldValue){//handler在msg发生改变时便会调用,newValue表示修改后的新值 //code } } } }); //第二种写法 vm.$watch(&#39;msg&#39;,[配置对象]); 深度监视 在watch里配置deep: true Vue中的watch默认不检测对象内部值的改变 配置deep: true 可以监测对象内部值改变 值得注意的是： Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以 深度监视的简写方式使用条件： 不配置immediate和deep时即可使用 watch: { msg(){ //code } } computed和watch的区别 computed能完成的，watch也能完成，反之则不一定（因为watch能够完成异步操作 需要注意的是：Vue所管理的函数，最好写成普通函数，this的指向才是vm或者组件实例对象 所有不被Vue管理的函数（定时器的回调函数、ajax等），最好写成箭头函数，这样this的指向才是vm或组件实例对象 绑定class样式/style样式需求：有些时候，我们会对class进行动态调整。比如用户点击一个按钮就能切换样式，或者取消一个样式，再或者是实现样式的叠加呈现效果 传统方式 开发者亲自调用DOM进行样式切换（命令式） Vue方式 使用单项绑定来实现，由Vue来做 条件渲染条件条件，顾名思义就会有if，else，在Vue里面提供了这个一系列语法 v-if = “表达式” v-else-if = “表达式” v-else = “表达式” 适用于切换频率较低的场景 特点：不展示的DOM元素直接被移除 注意：v-if和v-else-if和v-else一起使用，但要求结构不能被”打断” v-show 写法：v-show=”表达式” 适用于：切换频率较高的场景 特点：不展示的DOM元素不会被移除，仅仅是样式被隐藏 列表渲染（很重要）基本介绍： v-for 用于展示列表数据 语法：v-for = “(item, index) in xxx” :key=” yyy” 可遍历：数组，对象，字符串，指定次数 key的作用和原理（面试可能会问）key是标签的唯一标识（相当于身份证） 跳过p35-p37以及p39收集表单数据 内置指令 v-text v-html 向指定节点中渲染包含html结构的内容 与插值语法的区别： v-html会替换掉节点中所有内容，则不会 v-html可以识别html结构 另外，v-html会有安全性问题，容易导致xss（跨站点攻击）攻击 例子：盗取别人的cookie v-cloak 本质是一个特殊属性，Vue实例创建完毕后并接管容器，会删掉v-cloak属性 配合css使用可以解决网速慢时页面展示出的问题（解决方法：将带有cloak属性的标签的设置为display：none） v-once v-once所在节点在初次动态渲染后，就视为静态内容 以后数据的改变不会引起v-once所在结构的更新，可用于性能优化 v-pre 跳过所在节点的编译过程 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 自定义指令 生命周期分为四个阶段 create阶段 mount阶段 update阶段 destroy阶段 每个阶段都有一个beforeXXX和XXXed的钩子函数 总结 组件化编程 关于VueComponent 单文件组件脚手架结构render函数main.js里的代码 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; Vue.config.productionTip = false new Vue({ render: h =&gt; h(App), }).$mount(&#39;#app&#39;) 为什么在脚手架环境下，Vue实例里面只能使用render函数而不能使用template: (配置项) ref属性 props属性 mixin plugin 案例演示 webStorage 组件自定义事件 全局事件总线 消息订阅与发布 脚手架配置代理 插槽 Vuex原理图 搭建环境创建文件：src/store/index.js //创建vuex的store //引入Vue import Vue from &#39;vue&#39; //引入Vuex import Vuex from &#39;vuex&#39; Vue.use(Vuex) //准备action--用于响应组件的动作 const actions = {}; //准备mutation--用于操作数据（state） const mutations = {}; //准备state---用于存储数据 const state = {}; //创建并导出store export default new Vuex.Store({ actions, mutations, state, }); 在main.js中创建vm传入store配置项 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import Vuex from &#39;vuex&#39; import store from &#39;./store&#39; Vue.config.productionTip = false Vue.use(Vuex); new Vue({ render: h =&gt; h(App), store, }).$mount(&#39;#app&#39;) 注意事项 多个组件需要共享的数据是放在state对象里面的 对于数据的加工处理（逻辑代码）一般在actions里面进行 对数据最后的操作一般在mutation进行 四种map方法的使用 mapActions和mapMutation同理 模块化 路由自个儿写一个配置路由的js文件 多级路由 路由传参（query） 命名路由可以在每个路由配置项中添加name属性，因为如果遇到多级路由（一般四级五级以上或更多）在router-link标签内的to属性的路径长度会变得非常的长，有了name属性后只需要利用to的对象写法，加入name属性即可 路由的params参数 使用该参数时，路由配置项里面必须配置name属性 路由携带params参数时，若使用to的对象写法，则不能使用path配置项（query则可以） 需要在path里面使用【:xxx】进行属性占位 路由的props配置 router-link的replace属性 编程式路由 路由组件特有的钩子函数 actived()：切换到当前路由时激活并执行 deactived()：离开当前路由时失活并执行 路由守卫（权限问题） 路由器的两种工作模式 再来一次todolist","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ES67891011","slug":"ES67891011","date":"2021-09-01T02:00:00.000Z","updated":"2022-06-14T11:45:36.892Z","comments":true,"path":"undefined/ES67891011/","link":"","permalink":"/undefined/ES67891011/","excerpt":"","text":"ES67891011解构赋值允许按照一定模式从数组和对象中提取值，对变量进行赋值 const group = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;,‘赵六]; let [zhang, li, wang, zhao] = group const pepople = { name: &#39;Lee&#39;, age: 18; say: function(){ console.log(&#39;hello, my name is Lee&#39;); } }; let {say} = people; 模板字符串（`）反引号 可直接出现换行符 在模板字符串里，变量使用${变量名}进行拼接 简化对象写法允许在大括号里面直接写入变量和函数，作为对象的属性和方法 箭头函数let add = n =&gt; n+n 箭头函数的this是静态的，始终指向函数声明所在的作用域下的this的值，并不会随着调用者的不用而不同 不能作为构造函数实例化对象 不能使用argument 当只有一个形参时，可以省略小括号 此外，当代码只有一句时，可以省略return 扩展运算符（…）能将数组转换为逗号分隔的参数序列 数组合并 数组克隆 将伪数组转为真数组 Symbol（符号）符号实例是唯一的，用于标识对象的唯一属性 Symbol不能new，只能使用Symbol()初始化 Symbol没有字面量语法 注意区分let a = Symbol()和let a = Symbol.for(); 全局注册表中定义的符号和使用Symbol()定义的符号并不相同 迭代器(Iterator)通俗说就是遍历，可迭代对象通过实现iterable接口，而且可以通过迭代器Iterator来消费 工作原理：每个可迭代对象都有一个Symbol.Iterator的属性，这个属性是一个方法 它会创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针会后移指向数据结构的第一个成员 不断调用next，指针不断后移，直到到头 每调用next方法返回一个包含value和done的属性对象 生成器(generator)function* generatorFn(){ //code1 yield param1； //code2 yield param2 } function*表示这是一个生成器函数 值得一提的是，调用这个函数并不会立即执行，它会返回一个生成器对象 function* generatorFn(){ //code1 yield param1； //code2 yield param2 } //得到生成器函数 let gen = generatorFn(); yield的作用yield有产出、产量、返回的意思，因此不难理解yield就相当于生成器里的return关键字。也就是说生成器函数能够返回多次（执行多次） next()它实现了iterator接口，因此也有next()方法，调用该方法能执行每个yield之前的代码，并且next()也可传入参数，该参数会覆盖上一个yield返回的值 promise（一个对象）用于封装异步操作 promise的出现是为了解决回调地狱 Promise是一个构造函数，通过new关键字实例化对象 语法 new Promise((resolve, reject) =&gt; {}); Promise接受一个函数作为参数（参数函数） 在参数函数中接受两个参数： resolve reject promise实例 state：状态 pending（准备） fulfilled（成功） rejected（失败） 通过调用resolve()和reject()来改变promise对象的状态（分别对应fulfilled和rejected） result：结果 promise状态的改变是一次性的 promise的结果//创建promise对象 const p = new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(&#39;用户数据&#39;); }, 1000); }); p.then((value) =&gt;{ console.log(value+&#39;访问成功&#39;); }).catch(()=&gt;{ console.log(&#39;访问失败&#39;); }); promise的方法 then方法 参数是两个函数 它的返回值是一个新的promise对象（且状态为pending） &lt;script&gt; const p = new Promise((resolve,reject) =&gt; { resolve(&#39;yes&#39;); // reject(); }); //当p的状态是fulfilled时，执行第一个参数函数，打印‘成功调用’ p.then(() =&gt; {console.log(&#39;成功调用&#39;)}, () =&gt; {console.log(&#39;调用失败...&#39;)}); console.log(p); &lt;/script&gt; 注意：如果promise的状态不改变，then里的方法不会执行 解决：使用return可以将实例的状态改成fulfilled const p = new Promise((resolve,reject) =&gt; { resolve(); }); const t = p.then(() =&gt;{ console.log(&#39;success&#39;); return 233; }); //值得一提的是，return不仅能够将新的promise的状态改变成fulfilled，而且还能够将return后面的值传递出去，作为链式调用的下一个then方法的参数 t.then((value) =&gt; {//此时的value为上面的233 //code }); catch方法 const p = new Promise((resolve,reject) =&gt; { rejected(); }); const t = p.catch((reason) =&gt;{ console.log(&#39;reason：&#39;+reason); }); 当promise的状态改为rejected时，会执行 当promise的执行体中出现代码错误，会执行 数值扩展Number.EPSILON是js表示的最小精度（其值为2.2204460……）【小数点后十六位】 在两个数比较大小时，如果这两个数的绝对值小于Number.EPSILON，则认为这两个数是相等的（有点像高数里的极限） function equal(a, b){ if(Math.abs(a-b) &lt; Number.EPSILON){ return true; } else{ return false; } } Number.isFinite 用于判断一个数值是否为有限数 Number.isNaN 检测一个数值是否为NaN Number.parseInt Number.parseFloat 将字符串转为整型或者浮点数 Number.isInteger Math.trunc 将数字的小数部分去掉 值得一提的是trunc是truncate（截断）的缩写 Math.sign 判断一个数是正数 负数 还是零 正数返回1，负数返回-1，零返回0 对象扩展 Object.assign(target, source) 两个对象target，source，source会覆盖target的对象属性 Object.setPrototypeOf() 设置对象的原型 模块化模块化是指将一个大的文件拆分成许多小文件，然后将小文件结合起来 优点： 防止命名冲突 代码复用 高维护性 模块化语法export：向外暴露接口 import：引入其他模块提供的功能 多种暴露的方式 分别暴露 export let param = 0； export function fun(){}; 统一暴露 let param = 0； function fun(){}; export {param， fun} 默认暴露 export default{ //你要暴露的数据,一般为对象 } 多种导入方式 通用导入方式 &lt;script type=&quot;module&quot;&gt; import * as m1 from &quot;js文件路径&quot;; &lt;/script&gt; 解构赋值形式 //第一种解构赋值 import {想要从模块获取的变量或方法} from &#39;js路径&#39; //第二种解构赋值，如果出现了导入的变量重名的情况，可以想数据库的select操作一样，用as给变量重命名 import {a} from &#39;js路径&#39; import {a as bb} from &#39;js路径&#39; //第三种，当暴露方式为默认暴露时，default必须起别名，因为default是一个关键字 import {default as m} from ‘./m.js’ 简便形式（只针对默认暴露） import mm from ‘./mm.js’ ES8async &amp;&amp; await async函数 async函数的返回值为promise对象 promise对象的结果有async函数执行的返回值决定 await表达式 await必须写在async函数中 其右侧的表达式一般为promise对象 await返回的是promise成功的值 await的promise失败了，就会抛出异常，需要通过try-catch捕获处理 对象方法扩展 Object.values() 返回一个给定对象的所有可枚举属性值的数组 Object.entries() 返回一个给定对象自身可遍历属性[key, value]的数组 Object.getOwnPropertyDescriptor() 返回指定对象所有自身属性的描述对象 手撕Promise源码/** * 手写一个promise（前端面试可能会要求手撕promise） * 关于自定义一个promise，首先promise有两个属性一个是PromiseState，PromiseResult * resolve，reject方法 * 以及十分重要的then方法 * ① * 并且为了保证每一个promise的状态只能改变一次，需要在调用resolve和reject方法时进行判断，如果不为pending则改变状态 * ② * 在异步任务执行回调的过程中，会出现then的方法执行不了的问题，这是因为同步代码会按照代码的书写顺序执行，而异步代码还没执行，此时的PromiseSate的状态还未改变（pending），因此在执行then方法的时候无法判断 * 此时需要在then方法中增加判断是否为pending的语句，并且将成功或者失败才调用的回调函数绑定在Promise对象上 * * 通过对Promise源码的复盘，我明白了回调函数执行真正的位置是在resolve和reject中，而then方法的作用仅仅是接受并且绑定回调函数 * （未完） */ function Promise(executor){ //设置两个属性 this.PromiseState = &#39;pending&#39;; this.PromiseResult = null; //保存成功或者失败的回调函数 this.callback = {}; //保存Promise的this const _self = this; //设置resolve函数 function resolve(data){ if(_self.PromiseState != &#39;pending&#39;) return; _self.PromiseState = &#39;fulfilled&#39;; _self.PromiseResult = data; if(_self.callback.onResolved){//如果已经绑定了 成功状态后才执行的回调函数 _self.callback.onResolved(data); } } //设置reject函数 function reject(data){ if(_self.PromiseState != &#39;pending&#39;) return; _self.PromiseState = &#39;rejected&#39;; _self.PromiseResult = data; if(_self.callback.onRejected){//如果绑定了 失败状态后才执行的回调函数 _self.callback.onRejected(data); } } //设置并调用执行器函数 executor(resolve, reject); //定义then函数,将它绑定在promise的原型上 Promise.prototype.then = function(onResolved, onRejected){ if(this.PromiseState === &#39;fulfilled&#39;){//如果同步事件，且状态为成功，对应的回调函数会立刻在then里执行 onResolved(this.PromiseResult); } if(this.PromiseState === &#39;rejected&#39;){//如果同步事件，且状态为失败，对应的回调函数会立刻在then里执行 onRejected(this.PromiseResult); } if(this.PromiseState === &#39;pending&#39;){//如果为异步事件，在执行then方法时的状态必为pending，因此需要将回调函数保存起来，并在resolve或者reject中执行 this.callback = { onRejected,onResolved } } } } 改进一但是，我们发现使用上述代码时，如果调用多个then方法，会出现只执行最后一个then方法的结果，这是因为上述代码保存callback是以对象的形式保存的，每执行一次then，后一个then保存的callback会覆盖掉前一个保存的。因此代码可以进一步改进，就是将callback保存的形式改为数组，在调用时直接遍历，下面放上改进代码 //将callback改为数组 this.callbacks = []; //在resolve最后一行改为 _self.callbacks.forEach((item) =&gt; {item.onResolved(data)}); //在reject最后一行改为 _self.callbacks.forEach((item) =&gt; {item.onRejected(data)}); //then方法的判断pending状态的代码改为 this.callbacks.push({ onRejected,onResolved }) 改进二同步修改状态then方法结果返回 Promise.prototype.then = function(onResolved, onRejected){ return new Promise((resolve, reject) =&gt;{ if(this.PromiseState === &#39;fulfilled&#39;){//如果同步事件，且状态为成功，对应的回调函数会立刻在then里执行 let result = onResolved(this.PromiseResult); if(result instanceof Promise){ result.then(v =&gt;{ resolve(v); },r =&gt;{ reject(r); }); } else{ resolve(result); } } if(this.PromiseState === &#39;rejected&#39;){//如果同步事件，且状态为失败，对应的回调函数会立刻在then里执行 onRejected(this.PromiseResult); } if(this.PromiseState === &#39;pending&#39;){//如果为异步事件，在执行then方法时的状态必为pending，因此需要将回调函数保存起来，并在resolve或者reject中执行 this.callbacks.push({ onRejected,onResolved }) } }) } then方法返回的结果是一个promise对象，而这个promise对象的结果是由其指定的回调函数决定的 如果抛出异常，返回的promise变为rejected，reason为抛出的异常 如果返回的是非promise的任意值，返回的promise的值变为resolved，value为返回的值 如果返回的是另一个新的promise，则这个的promise的结果会变成返回的promise的结果 异步修改状态then方法结果返回 Promise.prototype.then = function(onResolved, onRejected){ const self = this; return new Promise((resolve, reject) =&gt;{ if(this.PromiseState === &#39;fulfilled&#39;){//如果同步事件，且状态为成功，对应的回调函数会立刻在then里执行 let result = onResolved(this.PromiseResult); if(result instanceof Promise){ result.then(v =&gt;{ resolve(v); },r =&gt;{ reject(r); }); } else{ resolve(result); } } if(this.PromiseState === &#39;rejected&#39;){//如果同步事件，且状态为失败，对应的回调函数会立刻在then里执行 let result = onRejected(this.PromiseResult); if(result instanceof Promise){ result.then(v =&gt;{ resolve(v); },r =&gt;{ reject(r); }); } else{ reject(result); } } if(this.PromiseState === &#39;pending&#39;){//如果为异步事件，在执行then方法时的状态必为pending，因此需要将回调函数保存起来，并在resolve或者reject中执行 this.callbacks.push({ onResolved: function(){ let result = onResolved(self.PromiseResult); if(result instanceof Promise){ result.then(v =&gt;{ resolve(v); },r =&gt;{ reject(r); }); } else{ resolve(result); } }, onRejected: function(){ let result = onRejected(self.PromiseResult); if(result instanceof Promise){ result.then(v =&gt;{ resolve(v); },r =&gt;{ reject(r); }); } else{ resolve(result); } } }) } }) } 注：未完待续，回头再研究其他方法的源码axios定义：Promise based HTTP client for the browser and node.js 用于发送ajax请求（browser） 用于发送http请求（node.js） 可以使用 函数axios()发送ajax请求//为按钮绑定发送get请求的事件 btns[0].onclick = function(){ axios({//该函数接收一个对象作为参数 method: &#39;GET&#39;, url: &#39;http://localhost:3000/comments/1&#39; }).then(repsonse =&gt; { console.log(repsonse); }) }; 除了发送get请求，还可发送post，put，delete请求 另外，除了使用上述的方法发送请求，还可以使用axios对象发送请求 axios.request(config) axios.post(url, data, config) … 需要注意的是config指的是一个配置对象，我们可以设置一些属性，比如：请求方式，baseURL，设置超时等 创建实例对象发送请求我们可以使用axios的create()方法，该方法接收一个配置对象config，并返回一个与axios相近的对象 Q：为什么要创建实例对象发送请求呢？ A：在实际项目中，页面一般会从不同的服务器发送请求，axios的配置对象就会随着服务器的不同而变化。因此创建不同的实例对象，每个实例对象负责一个服务器，各司其职 axios拦截器axios取消请求let cancel = null; btns[4].onclick = function(){ if(cancel != null){//检测上一次的请求是否已经完成 cancel();//取消上一次的请求 }; axios({ method: &#39;GET&#39;, url: &#39;http://localhost:3000/comments/1&#39;, //给配置对象添加属性，该属性用于取消请求 cancelToken: new axios.CancelToken(function(c){//通过该回调函数能拿到一个cancel对象 cancel = c; }) }).then(repsonse =&gt; { console.log(repsonse); console.log(cancel); cancel = null;//cancel的值初始化 }); };","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"寄·算机英格力士","slug":"寄算机英语","date":"2021-09-01T00:20:00.000Z","updated":"2022-06-14T11:37:43.142Z","comments":true,"path":"undefined/寄算机英语/","link":"","permalink":"/undefined/寄算机英语/","excerpt":"","text":"寄·算机英格力士the Second classthe base raised to a power基的若干次幂 memory： main memory（主存） auxiliary ~（辅助存储） peripheral device外围设备 utilities使用软件 electronic spread sheet电子表格 heuristic启发式 statement 语句（在计算机领域的翻译） called…after 因…而被称为 bring to bear 运用（盲猜），施加 the third class imprint 刻录 compression technology 压缩技术 transmission media 传输介质 logical request 逻辑请求 system planning 系统规划 electronic pulses 电子脉冲 P2P 对等 public security 公共安全 interactivity 交互性 usability 可用性 in [the] light of 由于、鉴于 mainframes 大型机 分句法 综（缝）合法 the forth class Internet security 网络安全 加字减字的问题 被动态（英语科技文章）和主动态的问题 被动语态直译只得1分 名词和动词的转换 To user a computer needs some understanding of computer concepts understandings名词翻译成动词 extrapolate…from 从…推断 the fifth（6th）classtests： functional testing 功能测试 numerical analysis 数值分析 microprocessor 微处理器 feasibility study 可行性研究 multiprogramming 多道程序设计 transmission media 传输介质 logical request 逻辑请求 chip dealer 芯片制造商 近义词区分 capacity能力，容量，产能 excess capacity产能过剩 capability能力（指做某件事情所需的各项条件【技术，设备，人员】） ability能力（强调人的能力） ⑦ robust 健壮性 interfacing 接口技术 chalk up 获得（相当于achieve） tactical 策略性的 devious 欺诈的，不诚实的 ramifications 结果（一般形容复杂难以预料的结果） crack problem（攻克难题） ⑧近义词区分 quite 相当、使用语境：父母鼓励孩子，上级鼓励下属 extremely 相当，非常 使用语境：带有感情色彩 very 使用语境：用于客观评价 quite, fairly, rather后面接形容词可互换。 quite+冠词+形容词+名词 冠词+fairly+形容词 section Asophistication 复杂性 portable 手提的，便携的，可移植的 versatility 多用性 ⑨下列单词均有 监控 监视之意 monitor snoop spy pry about/into 下列单词均有 激增 剧增之意 proliferate break through surge skyrocket leap 下列单词均有 巨头 巨人之意 giant titan behemoth 庞然大物 ⑩近义词区分与解析，下列单词均有重要的、主要的之意 significant important major 其中important的程度要强于significant，major侧重形容“贬义的”主要，比如主犯（major criminal） circumvent 绕过、规避v cater 满足需要，迎合，考虑v unit testing 单元测试 program unit 程序单元 17 33","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"大学所学","slug":"大学所学","permalink":"/tags/大学所学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"阿·贾克斯（Ajax）","slug":"阿·贾克斯（Ajax）","date":"2021-08-30T05:00:00.000Z","updated":"2022-06-14T11:44:57.749Z","comments":true,"path":"undefined/阿·贾克斯（Ajax）/","link":"","permalink":"/undefined/阿·贾克斯（Ajax）/","excerpt":"","text":"阿·贾克斯（Ajax）重要对象XMLHttpRequest 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 发送相关请求GET、POST…… 设置相关参数setRequestHeader(); 服务端响应JSON数据XMLHttpRequest.responseType = &#39;json&#39;;//将响应体的信息指定为json 请求超时与网络异常处理 设置它请求超时的时间 XMLHttpRequest.timeout = [时间：毫秒] 绑定事件句柄ontimeout xhr.ontimeout = function(){}; 取消请求要使用到它的一个方法：abort() 请求重复发送核心：需要一个标识变量（isSending）来标记请求是否正在发送 部分代码： let isSending = false; if(isSending){xhr.abort()}; xhr.onreadystatechange = function(){ if (xhr.readyState == 4) { document.getElementById(&quot;result&quot;).innerHTML = xhr.responseText; } } 利用jQuery发送Ajax请求$.get(url,[待发送的参数],[载入成功的回调函数],[设置响应体的类型]); 同源策略（same-origin-policy）是浏览器的安全策略 同源：协议、域名、端口号必须完全相同 JSONPJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 值得注意的是标签是一个跨域标签，这就意味着，它的属性src可以指定任意的页面（请求），从那些获得数据（传输过程中会被转换为JSON字符串）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"试试jQuery","slug":"jQuery","date":"2021-08-23T01:00:00.000Z","updated":"2022-06-14T11:47:41.189Z","comments":true,"path":"undefined/jQuery/","link":"","permalink":"/undefined/jQuery/","excerpt":"","text":"试试jQuery使用jQuery 引入文件（官网下载） 使用jQuery核心函数：$(function(){}) 使用jQuery对象：$(“#xxx”)，用此方法得到的是一个jQuery伪数组对象 参考文档https://jquery.cuishifeng.cn/ 面试可能会问到的问题区别mouseover和mouseenter mouseover：在移入子元素时也会触发，对应mouseout mouseenter：只在移入当前元素时才触发，对应mouseleave 另外需要注意的是，hover（）内部使用的就是mouseenter和mouseleave 区别on(‘click’，fun)和click(fun) on支持动态绑定 click支持静态绑定不支持动态绑定 事件委派 将多个子元素的事件监听委托给父元素处理 监听回调加在父元素 当操作任何一个子元素，事件会冒泡到父元素 父元素不会直接处理，而是根据event.target（事件源）得到发生事件的子元素，通过这个子元素调用事件回调函数 $(‘父元素’).delegate(‘子元素’, ‘事件类型’, 事件回调函数) 筛选模块 过滤 在jQuery对象内部的元素中找出部分匹配的元素，并封装成新的jQuery对象返回 查找 查找jQuery对象内部的元素的子孙、兄弟、父母元素，并封装成新的jQuery对象返回 关于坑爹的setInterval一定要及时关掉，不然定时器的数量可能会叠加，比如轮播图的快速点击…就会出事 可以在定时器执行前设置一个flag来标记 我的轮播图&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;fa/css/all.css&quot;/&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .clearfix::after { content: &quot;&quot;; display: block; clear: both; } #wrapper{ width: 1024px; height: 768px; background-color: #BBFFAA; margin: 0 auto; overflow: hiddn; position: relative; } #banner{ list-style-type: none; width: 6144px; height: 768px; position: absolute; left: 0; } #banner li{ float: left; } #toLeft{ position: absolute; top: 384px; } #toRight{ position: absolute; top: 384px; left: 1010px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ var $wrapper = $(&#39;#wrapper&#39;); var $banner = $(&#39;#banner&#39;);//获取轮播图 var $left = $(&#39;#toLeft&#39;);//翻页的左指针 var $right = $(&#39;#toRight&#39;);//翻页的右指针 var moving = false;//当前是否在翻页 var timer = 0; var auto = setInterval(function(){//每隔三秒自动翻页 nextPage(false); },3000); $wrapper.hover(function(){//鼠标悬停在轮播图上时停止轮播，移除则继续自动轮播 clearInterval(auto); },function(){ auto = setInterval(function(){ nextPage(false); },3000); }); $left.click(function(){//向前翻页 nextPage(true); }); $right.click(function(){//向后翻页 console.log(&#39;向后翻页&#39;); nextPage(false); }); function nextPage (next) {//执行翻页的 if(moving){ return; }; moving = true; var curLeft = $banner.position().left;//当前left var offset = next ? 1024 : -1024;//向前或者向后的翻页距离 var targetOffset = (curLeft+offset)%6144;//目标翻页距离 var itemOffset = -20;//每次interval移动的距离20px if(offset &lt; 0){ timer = setInterval(function(){ curLeft += itemOffset; if(curLeft &lt; targetOffset){ curLeft = targetOffset; if(targetOffset === -5120){//如果向后翻页到最后一张图片 $banner.css(&#39;left&#39;,-1024);//重新定位到第一张图片（其实是第二张，因为前面一张是最后一张图片） moving = false; clearInterval(timer);//关闭定时器 return; } $banner.css(&#39;left&#39;,(curLeft)%5120); clearInterval(timer);//关闭定时器 moving = false; return; } $banner.css(&#39;left&#39;,((curLeft%5120))); },1000/144); } else{ timer = setInterval(function(){ curLeft += (-itemOffset); if(curLeft &gt; targetOffset){ curLeft = targetOffset; if(targetOffset === 0){ $banner.css(&#39;left&#39;,-4096); moving = false; clearInterval(timer);//关闭定时器 return; } $banner.css(&#39;left&#39;,(curLeft)%5120); clearInterval(timer);//关闭定时器 moving = false; return; } $banner.css(&#39;left&#39;,((curLeft%5120))); },1000/144); } } }); &lt;/script&gt; &lt;div id=&quot;wrapper&quot; class=&quot;clearfix&quot;&gt; &lt;ul id=&quot;banner&quot; style=&quot;left:-1024px&quot;&gt; &lt;li&gt;&lt;img src=&quot;pic/4.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;pic/1.jpeg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;pic/2.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;pic/3.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;pic/4.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;pic/1.jpeg&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;pointDiv&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;toLeft&quot;class=&quot;arrow&quot;&gt;&lt;i class=&quot; fas fa-angle-double-left&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; id=&quot;toRight&quot; class=&quot;arrow&quot;&gt;&lt;i class=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 自定义动画（略）多库共存解决两个库都要使用$的问题 jQuery库可以释放$的使用权，让另外一个库可以正常使用，此时jQuery库只能使用jQuery 方法：jQuery.noConflict() 区别onload和ready的区别window.onload = function(){}; $(function(){});//与下面的写法是等价的 $(document).ready(function(){}) onload只能添加一个监听回调，而ready可添加多个 如果页面有图片，onload会在文档里所有图片加载完再执行 而ready是只要文档（图片还未加载）加载完毕就执行，因此可能会出现无法获取图片的情况","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"琢磨JS（不是笔记的笔记）","slug":"琢磨JS","date":"2021-08-15T05:00:00.000Z","updated":"2022-06-14T11:39:41.302Z","comments":true,"path":"undefined/琢磨JS/","link":"","permalink":"/undefined/琢磨JS/","excerpt":"","text":"琢磨JS（不是笔记的笔记）关于变量var声明的作用域是函数作用域 使用var定义的变量会成为包含它的函数的局部变量 使用var定义的变量会自动提升到函数作用域顶部（声明提升） letlet声明的是块作用域，需要注意的是块作用域是函数作用域的子集 let定义的变量不会进行声明提升，这称为“暂时性死区” const可以理解为java中的声明一个常量 关于数据类型Undefined（定义了但未赋予初始值）它的值就是undefined，使用var或let声明变量没赋初值，就相当于赋予了undefined Null它的值为null，逻辑上它的值表示一个空对象指针 BooleanNumber有个特殊的值：NaN（不是数值“Not a Number”），用来表示本来要返回数值的操作失败了 String可以用单（‘’）、双引号（“”）或者反引号（`）标示 Symbol确保对象属性使用唯一标识符，防止属性冲突的危险 Object关于正则表达式用于定义一些字符串的规则 语法： var 变量 = new RegExp(“正则表达式”,”匹配模式”); 完成上述new后得到一个正则表达式对象，随后我们就能用这个对象去检查其他字符串是否符合该正则表达式的规范 此外还能使用字面量来创建正则表达式： var 变量 = /正则表达式/匹配模式 正则表达式规则： /[abc]/：表示含有a或b或c的字符串 /[ ^ abc]/：表示匹配除了[abc]的所有字符 /a{n}/：花括号的n表示对它前面一个内容起作用，{n}表示正好出现n次 扩展：/（abcd）{n}/：表示abcd这一个整体正好出现n次 另外也可以这样写，/a{x，y}/，这表示a可以出现x到y次（出现次数”区间化“） 具体规则还有好多，可参考官方文档… 关于DOM 全称Document Object Model js通过DOM来对html文档进行操作。 Document：指的是整个html页面 Object：将网页的每一部分都转换为一个对象（每一个标签） Model：使用模型表示对象之间的关系，方便我们获取对象 onload事件会在整个页面加载完成之后才触发 为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样就可以确保我们的代码执行时所有的DOM对象已经加载完毕 关于BOM 全称浏览器对象模型 可以使我们通过js来操作对象 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表整个浏览器的窗口，同时window也是网页的全局对象 Navigator 代表当前浏览器的信息，通过该对象可以识别不同的浏览器 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操纵浏览器向前或者向后翻页，且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 事件句柄 onclick… 高级部分关于typeof、instanceof、===（这个不算高级吧） typeof 可以判断undefined、数值、字符串、布尔值、function（且判断显示的数据类型以字符串的形式返回） 但无法判断（null和object）、（object和array） instanceof 判断一个对象是否是一个类的实例 === 可以判断null和undefined 关于区分数据类型和变量类型 数据类型 基本类型 对象类型 变量类型 基本类型 引用类型 乍一看很像，说简单点，变量类型就是一个装数据类型的容器，比如变量类型中的基本类型保存的就是基本类型的数据，例子有var a = 3 关于IIFE（Immediately Invoked Function Expression）立刻执行函数 类似于函数声明，但由于包含在括号内，所以会被解释成函数式表达式，紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式，具体如下所示： (function(){ //块级作用域 })(); 关于函数高级（这应该才是真正的高级） 原型！！！（prototype） 首先原型是一个对象，这个对象是一个构造函数（这里暂时称为fun）的属性，这个属性叫做prototype，也就是说fun.prototype表示fun的原型对象。同时所有用这个构造函数实例化的对象都有个原型对象。这样解释有点绕，再简单点就有点像java里面的类的静态成员，所有由这个类创建的对象都有着同样的静态成员，再往大点的地方说就是共享一片静态区 此外，原型对象中又有一个constructor的属性，这个属性也是一个对象，而这个对象由正好指向构造函数（fun），这就是“你中有我，我中有你”啊 实例化的对象们都有一个 proto 属性，这个属性指向的也是一个对象，它指向构造函数的原型，这个属性称为隐式原型，而构造函数的原型则称为显示原型 还有啊，实例对象在调用方法的时候，若自身没有该方法，它去隐式原型中去找 总计： 构造函数的prototype属性，在定义函数的时候自动添加的，默认是一个空obj对象 实例对象的 proto 属性：创建对象时自动添加的，默认值为构造函数的prototype的属性值 原型链（隐式原型链）：访问一个对象的属性。现在自身属性中查找，找到就返回，如果没有就沿着 proto 这条链向上找，找到返回，如果最后没找到就返回undefined 执行上下文（基于对象）简单说就是this 全局上下文、函数执行上下文 作用域（基于变量）变量之间的”界限“ 全局作用域、局部函数作用域 闭包 引用了另外一个函数作用域中变量的函数，通常是在嵌套函数中实现 闭包中的变量不会被销毁，这样会造成内存泄漏，内存泄漏的堆积最终会导致内存溢出 关于面向对象高级 原型链的继承 要想子类实现的父类的方法，只需要子类型的原型为父类型的实例对象即可 Sub.prototype = new Super() 组合继承 综合了原型链（prototype）和盗用构造函数（call方法） 关于线程机制与事件机制 进程（process）&gt;线程（thread） 一个程序可以开启一个或多个进程，一个进程里面至少有一个线程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于盒子模型的不是笔记的笔记","slug":"关于盒子模型的不是笔记的笔记","date":"2021-08-01T06:00:00.000Z","updated":"2022-06-14T11:48:07.197Z","comments":true,"path":"undefined/关于盒子模型的不是笔记的笔记/","link":"","permalink":"/undefined/关于盒子模型的不是笔记的笔记/","excerpt":"","text":"关于盒子模型的不是笔记的笔记盒子模型，css将页面所有的元素设置成一个矩形的盒子，对页面的布局就变成将不同的盒子摆放到不同的位置 盒子的组成 内容区（content） 内边距（padding） 边框（border） 外边距（margin） 前三者决定了一个盒子的大小，最后一个决定了盒子与盒子之间的位置距离 盒子的水平布局元素的水平方向的布局： 元素在其父元素中水平方向的位置由以下几个属性共同决定 margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须满足（若不满足则称为过度约束）：（上述七个属性之和=父元素内容区的宽度） 如果不满足，浏览器会自动调整margin-right的值使等式成立 若七个属性中有设置auto值，浏览器会自动调整auto的值使等式成立 盒子的垂直布局相邻的盒子的垂直外边距会发生折叠（块内元素） 兄弟元素 两者外边距都是正值会取较大值 一正一负，取两者和 都是负值，取绝对值大的 父子元素 父子元素相邻外边距，子元素的会传递给父元素 父元素的外边距的折叠会影响到页面的布局 行内元素： 行内元素不支持设置宽度和高度 行内元素可以设置padding、border、margin，但是在垂直方向上都不会影响布局 盒子大小默认情况下，盒子可见框的大小由内容区，内边距和边框共同决定 box-sizing用来设置盒子尺寸的计算方式（设置width和height的作用） 可选值： content-box：这是默认值，此时的width和height设置的是内容区的大小 border-box：此时的width和height设置的整个盒子的可见大小 盒子的阴影效果box-shadow：10px 10px 50px rgba(0,0,0,0.3); 表示该阴影向左向下偏移10px，模糊半径为50px，需要注意的是rgba里面最后一个之表示的是阴影的透明度 盒子浮动通过浮动可以使一个元素向其父元素的左侧或者右侧移动 使用float属性来设置 浮动特点： 浮动元素会脱离文档流，不再占据文档流的位置 浮动元素不会从父元素中移出 浮动元素向左或向右移动，不会超出它前边的其他浮动元素 如果浮动元素的上边是一个没有浮动的元素，则浮动元素无法上移 浮动元素不会超过它上边的兄弟元素，最多和它一样高 其他特点： 文字环绕 脱离文档流 块元素 不再独占页面一行 宽度和高度默认都按内容撑开 行内元素 会变成块元素 盒子盖度塌陷发生原因：当父元素宽高未被写死，内部元素设置为float后无法撑起父元素的高度 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #box1{ border: red 10px solid; } #box2{ width: 600px; height: 300px; background-color: #008000; float: left; } #box3{ clear: both; } #box1::after{ clear: both; display: block; content: &quot;&quot;; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt; &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; &lt;!-- &lt;div id=&quot;box3&quot;&gt;&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ***解决方法 .clearfix::after { content: &quot;&quot;; display: block; clear: both; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"学习设计me式（Design Pattern）","slug":"学习设计me式","date":"2021-07-19T07:00:00.000Z","updated":"2022-06-14T11:36:27.233Z","comments":true,"path":"undefined/学习设计me式/","link":"","permalink":"/undefined/学习设计me式/","excerpt":"","text":"设计模式?（Design Pattern）软件设计中普遍存在的各种问题，所提出的解决方案 目的： 代码重用性 可读性（代码具有规范性） 可扩展性（增加新功能，比较方便） 可靠性（增加新功能，对原先的功能没有影响） 低耦合、高内聚 七大原则（设计模式设计的依据）单一职责（singleResponsibility）对类来说，一个类只负责一类职责（比如userDao）如果A类负责两个职责，则需要将A类的粒度分解为A1、A2 效果： 降低类的复杂度 提高类的可读性 降低变更引起的风险 接口隔离原则（Interface Segregation Principle）客户端不应该依赖它不需要的接口，也就是说一个类对另一个类的依赖应该建立在最小的接口上 思考：接口隔离其实是对一个接口的分解的过程（接口A拆分成A1、A2…） 依赖倒转原则（Dependency Inversion Principle）/【面向接口编程】what： 抽象不依赖细节，细节应该依赖抽象 高层模块不依赖底层模块，二者都依赖于抽象 使用接口或者抽象类去指定规范，具体实现则交给他们的实现类去完成 里氏替换原则（Liskov Substitution Principle）/【LSP原则】子类可以扩展父类的功能，但不能改变父类原有的功能 How： 原来的父类和子类都继承一个基类，去掉原有的继承关系，采用依赖、聚合、组合的关系来替代 开闭原则（Open Closed Principle）何为开闭？ 开：一个软件实体（类、模块、函数）对其扩展是开放的 闭：对其修改是关闭的 思考：大白话讲就是，如果我们想要给软件新增一些功能，我们应该在不影响（改动）源代码的情况下去增加功能 迪米特法则（最少知道原则）（Demeter Principle） 一个对象应该对其他对象保持最少的了解（A对象在使用B对象时只关心调用，不关心B对象的实现的细节） 类之间的关系越密切，耦合度越高 一个栗子： 若A、B两个类有耦合关系，那么B类就不要以局部变量的形式出现在A类中。如果出现，A、B的关系就是非直接朋友关系。反之，若B类作为A的成员变量或者方法的参数再或是方法的返回值，则称A、B的关系是直接朋友关系 合成复用原则（Composite Reuse Principle）尽量用合成/聚合的方式，而不是使用继承 （后续可补充） 总结 针对接口编程，而不是针对实现编程 解决对象之间的松耦合设计 将不用变化的代码独立出来，在以后的编程过程中尽量扩展而不是修改（个人理解） 正餐创建型模式：单独对对象的创建进行研究，从而能够高效地创建对象 单例模式 抽象工厂模式 原型模式 建造者模式 工厂模式 结构型模式：设计对象的结构、继承和依赖关系 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式 行为型模式：设计对象的行为，使对象的工作效率提高 模板方法模式 命令模式 访问者模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 责任链模式 ①单例模式（Singleton）下定义：采取一定方法在整个软件系统中，对某个类只能存在一个对象实例 它の几种创建方式： 饿汉式 package singleton.type1; public class demo { public static void main(String[] args) { singleton s1=singleton.getSingleton(); singleton s2=singleton.getSingleton(); System.out.println(s1==s2); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); } } //所谓饿汉，就是不管三七二十一，在类加载的时候就已经创建好单例对象了 class singleton{ private static final singleton singleton=new singleton();//使用静态变量去创建单例对象 private singleton(){//构造方法私有化，防止外部new对象 } public static singleton getSingleton(){//向外提供一个方法获取单例对象 return singleton; } } package singleton.type2; public class demo { public static void main(String[] args) { singleton s1= singleton.getSingleton(); singleton s2= singleton.getSingleton(); System.out.println(s1==s2); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); } } class singleton{ private static singleton singleton; private singleton(){//构造方法私有化，防止外部new对象 } static{ singleton=new singleton();//使用静态代码块创建单例对象 } public static singleton getSingleton(){//向外提供一个方法获取单例对象 return singleton; } } 注意：对于饿汉式，因为在类加载时就已经创建，若不使用单例对象，可能造成内存的浪费 懒汉式（单线程且不安全） package singleton.type3; public class demo { public static void main(String[] args) { singleton s1=singleton.getSingleton(); singleton s2=singleton.getSingleton(); System.out.println(s1==s2); } } class singleton{ private static singleton singleton; private singleton(){ } public static singleton getSingleton(){//所谓懒汉就是，只有要用到单例对象时才创建，不用就不创建。就像青蛙一样，你戳它一下 它就往前跳一下 if(singleton==null){ singleton=new singleton(); } return singleton; } } 注意：如果遇到这一种情况：线程 1 运行到instance = new Singleton()处的时候，线程 2 抢到的 CPU 的执行权，进入 getInstance() 方法，也运行了instance = new Singleton()，但线程 2 创建了对象这件事情，线程 1 压根儿不晓得，等到线程 1 重新获得 CPU 执行权的时候，从原先的地方 处继续执行，又运行了 instance = new Singleton(); 这行代码，这样就会存在多个对象，得到singleton就不再唯一，这样就失去了原本的意义 最完美的创建方式来啦！使用枚举！ package singleton.typeEnum; public class demo { public static void main(String[] args) { singleton s1=singleton.SINGLETON; singleton s2=singleton.SINGLETON; System.out.println(s1==s2); s1.test(); } } enum singleton{ SINGLETON; public void test(){ System.out.println(&quot;is singleton...&quot;); } } 使用枚举的方式实现单例模式是《Effective Java》作者力推的方式，在很多优秀的开源代码中经常可以看到使用枚举方式实现单例模式的（身影），枚举类型不允许被继承，同样是线程安全的且只能被实例化一次 除此之外，还能使用静态内部类的方式来实现单例模式 package singleton.type4; public class demo { public static void main(String[] args) { singleton s1=singleton.getInstance(); singleton s2=singleton.getInstance(); System.out.println(s1==s2); } } class singleton { private singleton(){} private static class getSingleton{//创建内部类 private static final singleton instance=new singleton();//将单例对象设置为内部类成员变量 } public static singleton getInstance(){//对外开放一个获取单例对象 return getSingleton.instance; } } 工厂模式简单工厂模式（（））下定义：是由一个工厂对象决定创建出哪一种产品类的实例。定义一个创建对象的类，由这个类去封装实例化对象的行为 典型案例：订购pizza业务 pizza工厂： package factory.simpleFactory.pizzaStore.simplePizzaFactory; import factory.simpleFactory.pizzaStore.pizza.pizza; import factory.simpleFactory.pizzaStore.pizza.spicyPizza; import java.util.Scanner; public class pizzaFactory { public pizza createPizza(){ System.out.println(&quot;******使用简单工厂模式...******&quot;); System.out.println(&quot;请选择要制作的pizza...&quot;); pizza pizza=null; String type=getType(); if(type.equals(&quot;spicy&quot;)){ pizza=new spicyPizza(); pizza.setName(type); System.out.println(type+&quot;Pizza制作完成...&quot;); } else if(type.equals(&quot;NewOrleans&quot;)){ pizza=new spicyPizza(); pizza.setName(type); System.out.println(type+&quot;Pizza制作完成...&quot;); } else { System.out.println(&quot;制作失败，暂无此种类...&quot;); } return pizza; } private String getType(){//获取要制造的pizza的种类 String type; Scanner sc=new Scanner(System.in); type=sc.next(); return type; } } 订购pizza业务： package factory.simpleFactory.pizzaStore; import factory.simpleFactory.pizzaStore.pizza.pizza; import factory.simpleFactory.pizzaStore.simplePizzaFactory.pizzaFactory; public class orderPizza { pizzaFactory pizzaFactory; orderPizza(pizzaFactory pizzaFactory){ this.pizzaFactory=pizzaFactory; } public pizza order(){ return pizzaFactory.createPizza(); } public static void main(String[] args) { orderPizza orderPizza=new orderPizza(new pizzaFactory()); pizza pizza=orderPizza.order(); while(pizza!=null){ pizza=orderPizza.order(); } } } 这里没有放出pizza类… 结果如下图所示： ②工厂方法模式（简单工厂的进阶）下定义：定义一个创建子类的抽象方法，由子类决定要实例化的类。简单工厂模式是在工厂内部就实例化需要的类，而工厂方法则是将对象的实例化的权限交给了子类，一般来说，这一个子类对应一类产品 ③抽象工厂模式（工厂方法的进阶）下定义：定义一个接口用于创建相关的对象簇,而无需指定具体的类 Hold on，什么是簇？簇的意思就是聚集的一团东西，就比如华为产品簇（包含手机，电脑，智能穿戴设备等），在这里就是指多个产品（类）上图中的各个pizza。OrderPizza就是抽象工厂，它旗下又有BJOrderPizza和LDOrderPizza这两个具体生产Pizza的子类。其实严格来说抽象工厂的具体工厂所实现的类都是不同类别的。上面的例子最终都是和pizza有关的。这个例子不能很好的区别抽象工厂和工厂方法的区别。 关于工厂模式的思考与理解学完了工厂设计模式，我明白了此类设计模式的思想就是来源于现实生活 。我看看我显示屏旁的机箱里的电脑配件… 配一台电脑不就要经过工厂模式的一系列操作么。 下面开始讲故事： 张三（三迟但到）是个计算机天才aka装B猿，呸，装机猿。刚开始装机数量不是特别多，他一个人也应付得过来且口碑也不错。但是随着客户的数量的增加，他一个人有点吃不消了。因此他想，”为什么开一个工厂来专门装电脑呢？“。很快他找银行贷了一笔款用于新建工厂（这就是简单工厂设计模式）。工厂内部负责生产。效率相比以前大大提升（利用工厂生成需要的对象）。 但是过了一阵子，张三发现每个用户的装机要求不尽相同，有人想要一台配置不高的办公电脑，而有人是臭打游戏的（比如我），他们想要一台配置高的发烧电脑。因此他们对配件的要求也不一样。可是工厂只有一个，所有配件的生产都在这里进行，同时工厂场地有限（类の大小），虽然能扩建但是较为麻烦（在一个工厂类不断地添加新的代码）。很快张三想到了解决方案：再开设几个工厂生产不同的整机（具体实现类），这几个工厂都要听总工厂的指示（实现总工厂的抽象方法），生产符合不同配置需求的整机（产品对象）张三很快就做强做大，总工厂也变成了大公司。 当然大公司也有大公司的麻烦，随着计算机硬件的高速发展，人们不再满足于购买整机，他们更加偏向于DIY：自己买配件来组装电脑。张三注意到了这个现象，所以他联系许多硬件的生产厂商，拿到他们的销售权。最后原先的工厂不再组装整机，而是组装加工配件。比如GPU工厂、CPU工厂、主板工厂…（具体工厂），如果在后续还有新的电脑硬件需求，只要再开设一间新的代工厂（新的具体工厂）就好了 上面的三种发展历程对应的是工厂模式的演变过程。从一个人全干到交给工厂再到交给多个工厂完成。可以看出，生产一个简单产品，我们可以用简单工厂模式，但是如果产品需要扩展，我们就需要工厂方法模式。如果一个产品不够还需要多种类别的产品，也就是产品簇，我们就要采取抽象工厂模式。 最后我想说，设计模式源于生活！生活中的例子能够加深我对不同设计模式的理解 ④原型模式（Prototype）对象.clone()下定义：用原型实例执行创建对象的种类，而且通过拷贝这些原型，创建新的对象 优点： 创建新的对象比较复杂时，可以利用原型模式来简化对象的创建过程，同时也能提高效率 不同重复新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化，比如增加属性或者删除属性，其他克隆对象也能发生相应的变化，无需修改代码 缺点： 需要为每一个类配备一个克隆方法，对旧的类需要修改其源代码，这违背了OCP原则 ⑤建造者模式（Builder）下定义：生成器模式，是一种对象构建模式，他可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造不同表现的对象 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口或抽象类 ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件 Director（指挥者）：构建一个是使用Builder接口的对象，它主要用于创建一个复杂对象，它主要有两个作用，隔离客户和对象的生产过程，负责控制对象的生产过程 ————————————-人工分界线————————————- ⑥适配器模式（Adapter）下定义：将某个类的接口转换成客户端期望的另一个接口表示，主要是为了兼容性，让原本接口不匹配的两个类能够协同工作，适配器又名为包装器（Wrapper） 一般来说适配器的作用就是使src类和target类发生联系：target——adapter——src 适配器有三种类型： 类适配器模式【适配器继承src类】 对象适配器模式（最常用）【适配器持有src类】 接口适配器模式 ⑦桥接模式（Bridge）下定义：将实现与抽象放在两个不同的层次，是这两个层次能够独立改变 作用：替代多层继承方案，有效地避免了类爆炸问题，可以减少子类的数量，降低维护系统的维护成本 但是，该模式的引入会增加对系统的理解和设计难度，再者该模式还需要正确识别出系统中两个独立变化的维度（抽象和实现） ⑧装饰者模式（晕…）下定义：动态的将新功能附加到对象上。在功能拓展上，比继承更有弹性，装饰者模式也体现了OCP原则 现实情景：快递包装、咖啡加料… ⑨组合模式（Composite）/部分整体下定义：它创建了对象组的树形结构，将对象组合成树形结构以表示“整体-部分”的层次关系 使用情景：当我们要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子节点进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子 具体场景：学校院系展示 注意：如果节点和叶子具有较大的差异性，比如方法和属性很多都不一样，则不适合组合模式 ⑩外观模式（Facade）/最简单的设计模式，原来以前使用过下定义：也称过程模式，为子系统中的一组接口提供一个一致的界面。此模式定义了一个高层接口，这个接口使得这一子系统容易使用 ⑪享元模式（Flyweight）下定义：又称蝇量模式，使用共享技术有效支持大量细粒度的对象，常用于系统的底层开发，比如数据库连接池、String常量池等 享元模式能够有效解决重读对象的内存的浪费问题，比如数据库连接池的connection 其中，Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态（外部状态及内部状态相关内容见后方）的接口或实现；ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中；FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。 ⑫代理模式注意区别于装饰模式 下定义：为一个对象提供一个替身，控制这个对象的访问，即通过代理对象访问目标对象，这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，进而做到扩展目标对象的功能 代理分类： 静态代理最简单的代理，有手就行（雀氏雀氏） proxy代理对象和target目标对象共同实现一个interface接口，然后将代理对象内部聚合目标对象，然后即可在调用目标对象的目标方法前后进行各种操作。 但是，不要高兴得太早，因为代理对象和目标对象要实现一样的接口，所以会有很多的代理类，并且一旦接口增加了方法，目标对象和代理对象都要进行维护…（维护？狗都不干） 动态代理（JDK代理）代理对象不需要实现接口，但是目标对象要实现接口 cglib代理（可在内存中动态创建对象，不需要实现接口） ————————————-人工分界线（以下是行为型设计模式）————————————- ⑬模板方法模式（Template Method）注意区别于外观模式 下定义：在一个抽象类公开定义了执行它的方法的模板，它的子类按需要重写方法实现，但调用将以抽象类中定义的方式进行 现实生活中的例子：小时候没少背一些作文模板吧！不同文体是什么样的模板我不用解释了吧（反正现在也忘得差不多了- -） ⑭命令模式（Command）下定义：在命令模式中存在着这样一条关系链： 传统的调用方式： 调用者——被调用者 在命令模式下： 调用者（Invoker）——命令（Command）——被调用者（Receiver） 很显然我们能够看出，命令模式能够很好的消除调用者与被调用者之间的耦合（实现解耦） 现实情景：打仗的时候，将军发布进攻命令，众将士发起冲锋 主要实现方式（类图）： （待补充…） ⑮访问者模式/（看不懂了….）下定义：null ⑯迭代者模式（Iterator）下定义：如果我们的集合元素是用不同的方式实现的，比如数组，集合类等，当客户端要遍历这些元素就会使用到不同的遍历方式，而且会暴露元素的内部结构，可以考虑使用迭代器模式解决 提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示 主要目的：将管理对象集合和遍历对象集合的责任分开 Iterator：迭代器接口，是系统提供，含义hasNext，next，remove ConcreteIterator：具体的迭代器类 Aggregate：统一的聚合接口，将客户端和具体聚合解耦 ConcreteAggregate：具体的聚合，持有对象集合 ⑰观察者模式（Observer）/太简单了下定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。比如社交账号上的订阅或者关注按钮，多个用户关注同一个up主，up主发布新动态时便会通知所有关注他的用户 优点：使用该模式后，会以集合的方式来管理用户（Observer），包括注册，移除和通知 ⑱中介者模式（Mediator）/减少子系统之间的相互调用注意和外观模式进行区分 下定义：用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 ⑲备忘录模式（Memento）下定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将这个对象恢复到原先保存的状态（游戏的存档机制？？？） ⑳解释器模式（Interpreter）/看到文法我就蚌埠煮了下定义：给一个语言表达式，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式） Context：环境角色（上下文），含有解释器之外的全局信息 AbstractExpression：抽象表达式，声明一个抽象的解释操作，这个方法为抽象语法树中所有节点共享 TerminalExpression：终结符表达式，实现文法中的终结符相关的解释操作 NonTerminalExpression：非终结符表达式，实现文法中的非终结符相关的解释操作 ②①状态模式（State）下定义：它主要解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。当一个对象的状态发生变化时，允许改变其行为，这个对象看起来像是改变了其类 Context：维护state实例，这个实例定义当前实例 state：定义一个接口封装与Context的一个特点接口相关行为 concreteState：每个子类实现一个与context的一个状态的相关行为 ②②策略模式（Strategy）下定义：定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的用户 该算法题体现了几个设计原则，第一，把变化的代码从不变的代码分离开来；第二，针对接口编程而不是具体类；第三，多用组合/聚合，少用继承 注意和桥接模式进行区分 ②③职责链模式（Chain Of Responsibility）下定义：责任链模式，为请求创建一个接受者对象的链，这种模式对请求的发送者和接受者进行解耦 该模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传送给下一个接收者，以此类推… 最佳应用场景：多个对象处理同一个请求，比如多级请求、请假/加薪、易班请假等审批流程。再比如javaWeb的拦截器 未完待续…现在只是简单理解了这些设计模式的基本思想，自身的思考还是不够。当然也有些模式还是一知半解。希望在后续的学习中能够有一些新的见解…嗯，先这样吧…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"学习春天の云（springCloud）","slug":"学习春天の云","date":"2021-07-12T10:20:00.000Z","updated":"2022-06-14T11:37:17.582Z","comments":true,"path":"undefined/学习春天の云/","link":"","permalink":"/undefined/学习春天の云/","excerpt":"","text":"学习春天の云①微服务？灵魂提问：什么是微服务？微服务是一种架构风格，是一种架构设计方式，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。 威神么（为什么）要微服务，它的好处都有啥？ 传统开发模式下，绝大多数的web应用都是单体架构的风格来进行构建，这就使得所有的接口，业务逻辑层，数据持久层全部都被打包在一个web应用中，并且布置在一台服务器上，使得不同的模块之前也高耦合在一起，这种开发模式使得多团队协作开发的开发成本极高。因此不难看出，如果在后期，项目的某个部分需要调整，就会导致“牵一发而动全身”的结果。 它的优点： 1.各个服务的开发、测试、部署都是相互独立的。可以针对某一个特定的服务进行更多的操作，比如负载均衡等。 当有一个新的需求加入时，传统项目需要结合各方面考虑影响等，微服务就不存在这样的问题，省事省力又省心。 3.使用微服务将项目拆分后，只需要保证对外接口的正常运行，大大降低了各个模块之间的耦合性，极大的提高开发效率。 缺点： 1.微服务的拆分基于业务，不能随心所欲的拆分，所以如何拆分，对于项目架构来说是非常重要且极具挑战的任务。 2.涉及到服务之间的调用时，常常需要和另外一个服务的提供方进行沟通，若是两个完全不同的公司或者部门，沟通成本比较大；某服务的对外接口要进行修改，也需要与其他服务调用方进行沟通。 3.由于各个服务相互独立，数据也是独立，当多个服务的接口进行操作时，如何保证数据的一致性是一个难点。数据统一性是微服务里面的一个难题。 利用微服务框架实现分布式系统（Spring Cloud） 1.Spring Cloud是完全基于Spring Boot，服务调用是基于REST API ，整合了各种成熟的产品和架构，同时基于Spring Boot也使得整体的开发、配置、部署都非常的方便。 2.Spring系列的产品具备功能齐全、简单好用、性能优美、文档规范等优点。 SC的架构图 SC的核心组件 服务治理Eureka=（Eureka Client）+（Eureka Server）（三大核心、两大步骤） 服务治理的核心由三部分组成： 服务提供者 服务消费者 注册中心 服务注册：在分布式系统架构中，每个微服务在启动时，会将自己的信息存储在注册中心。 服务发现：服务消费者从注册中心获取服务提供者的信息，通过这些信息调用服务提供者的服务。 ②注册中心 如何启动注册中心？创建一个父工程（配置springBoot） &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 创建一个子项目，用于配置Eureka &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在子项目中的yml配置文件中配置Eureka的相关属性 server.port：（一般默认8761） eureka.client.register-with-eureka：是否将当前的Eureka Server服务作为客户端进行注册 eureka.client.fetch-registry：是否获取其他Eureka Server服务的数据 eureka.client.service-url.defaultZone：注册中心的访问地址 最后一步，在子项目中启动springBoot服务 另外，需要注意的是。为了解决jdk9以上没有jaxb API 的问题（不然启动会失败哦），还需要在父项目增加以下依赖 &lt;!--解决jdk9以上没有jaxb Api的问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 还有！springBoot和springCloud版本一定要兼容！我就是因为使用了低版本的springCloud（因为视频是19年的，而sprinBoot又是最新的），被折磨了一个上午… ③服务提供者与上面的类似 创建子项目provider &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; spring.application.name ： 当前服务注册在 Eureka Server 上的名称。 eureka.client.service-url.defaultZone ： 注册中⼼的访问地址。 eureka.instance.prefer-ip-address ： 是否将当前服务的 IP 注册到 Eureka Server。 ④RestTemplate RestTemplate 是 Spring 框架提供的基于 REST 的服务组件，底层是对 HTTP 请求及响应进⾏了封装， 提供了很多访问 RETS 服务的⽅法，可以简化代码开发。 使用步骤 创建子项目 配置application.yml 创建和服务提供者相同的实体类 创建controller，调用服务提供者的接口 创建启动类（@SpringBootApplication），并将RestTemplate的实例（@Bean）进行注入 ⑤服务网关Zuul（祖鲁？）Zuul 是 Netflix 提供的⼀个开源的 API ⽹关服务器，是客户端和⽹站后端所有请求的中间层，对外开放 ⼀个 API，将所有请求导⼊统⼀的⼊⼝，屏蔽了服务端的具体实现逻辑，Zuul 可以实现反向代理的功 能，在⽹关内部实现动态路由、身份认证、IP 过滤、数据监控等。Zuul也是Spring Cloud集成的组件，通过它来实现服务网关。 Zuulの功能 身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符合的请求。 审查与监控：在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。 动态路由：动态的将请求路由到不同的后端集群。 压力测试：逐渐增加指向集群的流量，以了解性能。 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求。 静态响应处理：在边缘位置直接建立部分响应，从而避免其转发到内部集群。 多区域弹性：跨越AWS Region进行请求路由，旨在实现ELB（Elastic Load Balancing）使用的多样化，以及让系统的便越更贴近系统的使用者。 Zuul的配置文件（模板）server: port: 8030 spring: application: name: gateway eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ zuul: routes: provider: /p/** Zuul的启动类package com.gateway; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.cloud.netflix.zuul.EnableZuulProxy; @EnableZuulProxy// 包含了 @EnableZuulServer ，设置该类是⽹关的启动类。 @EnableAutoConfiguration public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } 备注：在配置zuul的routes的属性时，可能是因为版本的不兼容会出现ErrorController的异常…（还未解决…） ⑥负载均衡 Ribbon是Sping Cloud的一个组件，Spring Cloud Ribbon是一个负载均衡的解决方案，Ribbon是Netflix发布的负载均衡器，Spring对其进行了集成，Spring Cloud Ribbon是基于Netflix Ribbon实现的，是一个用于对HTTP请求进行控制的负载均衡客户端。Spring Cloud Ribbon也是要结合Eureka Server来使用的，因为也要在注册中心进行注册。在注册中心对Ribbon进行注册之后，Ribbon就可以基于某种负载均衡算法，如轮询、随机、加权轮询、加权随机等自动帮助服务消费者调用接口，开发者也可以根据具体需求自定义Ribbon负载均衡算法。实际开发中，Spring Cloud Eureka来使用，Eureka Server提供所有可以调用的服务提供者列表，Ribbon基于特定的负载均衡算法从这些服务提供者中选择要调用的具体实例。 yml配置文件（略） 创建启动类 package com.ribbon; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication public class RibbonApplication { public static void main(String[] args) throws Exception { SpringApplication.run(RibbonApplication.class, args); } @Bean @LoadBalanced//!!! public RestTemplate restTemplate() { return new RestTemplate(); } } @LoadBalanced：声明一个基于Ribbon的负载均衡。标注此注解后，RestTemplate就具有了客户端负载均衡的能力。 Controller层代码 package com.ribbon.controller; import java.util.Collection; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import com.ribbon.bean.user; @RestController @RequestMapping(&quot;/ribbon&quot;) public class RibbonHandler { @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/findAll&quot;) public Collection&lt;Student&gt; findAll(){ return restTemplate.getForObject(&quot;http://provider/user/findAll&quot;, Collection.class); } @GetMapping(&quot;/index&quot;) public String index() { return restTemplate.getForObject(&quot;http://provider/user/index&quot;, String.class); } } ⑦Feign声明式接口调用（代替ribbon？） 什么是Feign？ 与Ribbon一样，Feign也是有网飞提供的，Feign是一个声明式、模块化的Web Service的客户端，它简化了开发者编写Web服务客户端的操作，开发者可以通过简单的接口和注解来调用HTTP API，使得开发变得更加简化、快捷。Spring Cloud Feign也是基于Netflix Feign的二次开发，它整合了Ribbon和Hystrix，具有可插拔、基于注解、负载均衡、服务熔断等一系列的便捷功能，也就是说我们在实际开发中可以用Feign来取代Ribbon。（好家伙，又“白雪”一节课） 相比较于Ribbon+RestTemplate的方式，Feign大大简化了代码的开发，Feign支持多种注解，包括Feign注解、JAX-RS注解、Spring MVC注解等，Spring Cloud对Feign进行了优化，整合了Ribbon和Eureka，从而让Feign使用更加方便。 需要的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 注意：上面的版本较老 创建启动类 package com.feign; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients//!!!!!!!!!!!!!!! public class FeignApplication { public static void main(String[] args) throws Exception { SpringApplication.run(FeignApplication.class, args); } } @EnableFeignClients：声明其为Feign客户端 创建声明式接口 package com.feign; import java.util.Collection; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import com.feign.bean.user; @FeignClient(value = &quot;provider&quot;) public interface IFeignService { @GetMapping(&quot;/user/findAll&quot;) public Collection&lt;user&gt; findAll(); @GetMapping(&quot;/user/index&quot;) public String index(); } controller代码 package com.feign.controller; import java.util.Collection; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.feign.bean.user; import com.feign.IFeignService; @RestController @RequestMapping(&quot;/feign&quot;) public class FeignHandler { @Autowired private IFeignService feignservice; @GetMapping(&quot;/findAll&quot;) public Collection&lt;user&gt; findAll(){ return feignservice.findAll(); } @GetMapping(&quot;/index&quot;) public String index() { return feignservice.index(); } } 服务熔断机制什么是服务熔断？ 服务熔断就好比于保险丝的熔断。一般一个功能有多个微服务完成，假设其中一个微服务出现了问题，为了不造成连锁反应，引发更大损失。此时会在出问题的微服务处“切断”服务。就像保险丝熔断一样，防止火灾。feign提供了这一熔断机制，该机制可在配置文件中开启。 feign.hystrix.enable：是否开启熔断机制，默认false 创建IFeignService的实现类FeignServiceImpl，在里面定义容错处理机制，通过@Component注解将FeignServiceImpl实例注入到IOC容器 package com.feign.impl; import java.util.Collection; import org.springframework.stereotype.Component; import com.feign.bean.user; import com.feign.IFeignService; @Component public class FeignServiceImpl implements IFeignService{ @Override public Collection&lt;user&gt; findAll() { return null; } @Override public String index() { return &quot;服务器维护中。。。&quot;; } } 在IFeignService接口定义处定义@FeignClient的fallback属性来做降级处理，设置映射，映射到FeignServiceImpl中去。修改IFeignService后代码如下： package com.feign; import java.util.Collection; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import com.feign.bean.user; import com.feign.impl.FeignServiceImpl; @FeignClient(value = &quot;provider&quot;,fallback = FeignServiceImpl.class) public interface IFeignService { @GetMapping(&quot;/user/findAll&quot;) public Collection&lt;user&gt; findAll(); @GetMapping(&quot;/user/index&quot;) public String index(); } ⑧Hystrix容错机制再不改变各个微服务调用关系的前提下，针对错误情况进行预先处理 设计原则 服务隔离机制 服务降级机制 熔断机制 提供实时的监控和警报功能 提供实时的配置修改功能 引入依赖 &lt;!-- Eureka客户端依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 加入feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 加入actuator健康监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加hysteix熔断器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加可视化监控组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 配置文件 server: port: 8060 spring: application: name: hystrix eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ feign: hystrix: enabled: true management: endpoints: web: exposure: include: &#39;hystrix.stream&#39; ⑨Spring Cloud 配置中心 Spring Cloud Config可以通过服务端为多个客户端提供配置服务。Spring Cloud Config可以将配置文件存储在本地，也可以将配置文件存储在远程仓库中。可以在不重启微服务的前提下来修改它的配置。具体操作就是创建Config Server，通过它管理所有的配置文件。 依赖引入 配置yml server: port: 8762 spring: application: name: nativeconfigserver profiles: active: native cloud: config: server: native: search-locations: classpath:/shared 创建启动类 package com.config; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; @SpringBootApplication @EnableConfigServer public class NativeConfigServerApplication { public static void main(String[] args) throws Exception { SpringApplication.run(NativeConfigServerApplication.class, args); } } 重点： 在创建客户端后，在里面创建一个名为bootstrap.yml的配置文件（名称不能是别的，这是规定），用来读取配置中心的对应配置文件信息 bootstrap的配置信息如下： spring: application: name: configclient profiles: active: dev cloud: config: uri: http://localhost:8762 fail-fast: true 其中，通过spring.application.name结合spring.profiles.active拼接获得目标配置文件名称configclient-dev.yml，去Config Server中查找该文件。 （拖更…）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"学习春天の靴子（springBoot）","slug":"学习春天の靴子（springBoot）","date":"2021-07-06T02:00:00.000Z","updated":"2022-06-14T11:37:03.399Z","comments":true,"path":"undefined/学习春天の靴子（springBoot）/","link":"","permalink":"/undefined/学习春天の靴子（springBoot）/","excerpt":"","text":"学习春天の靴子（springBoot）ps：以下笔记内容主要搬运自尚硅谷(雷神)的笔记 Chapter1—自动配置原理1.1、依赖管理 父项目做依赖管理 依赖管理 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; 他的父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; 几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制 开发导入starter场景启动器 1、见到很多 spring-boot-starter-* ： *就某种场景 2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入 3、SpringBoot所有支持的场景 https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter 4、见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。 5、所有场景启动器最底层的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 可以修改默认版本号 1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。 2、在当前项目里面重写配置 &lt;properties&gt; &lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt; &lt;/properties&gt; 1.2、自动配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自动配好SpringMVC 引入SpringMVC全套组件 自动配好SpringMVC常用组件（功能） 自动配好Web常见功能，如：字符编码问题 SpringBoot帮我们配置好了所有web开发的常见场景 默认的包结构 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来 无需以前的包扫描配置 想要改变扫描路径，@SpringBootApplication(scanBasePackages=“xxx”) 或者@ComponentScan 指定扫描路径 @SpringBootApplication 等同于 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(&quot;com.atguigu.boot&quot;) Chapter2—容器功能2.1、组件添加1、@Configuration Full模式与Lite模式 `java#############################Configuration使用示例######################################################/** 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 2、配置类本身也是组件 3、proxyBeanMethods：代理bean的方法 Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】 Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】 组件依赖必须使用Full模式默认。其他默认是否Lite模式 /@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig { /** Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 @return*/@Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例public User user01(){User zhangsan = new User(“zhangsan”, 18);//user组件依赖了Pet组件zhangsan.setPet(tomcatPet());return zhangsan;} @Bean(“tom”)public Pet tomcatPet(){return new Pet(“tomcat”);}} ################################@Configuration测试代码如下######################################## @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(“com.atguigu.boot”) public class MainApplication { public static void main(String[] args) { //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) { System.out.println(name); } //3、从容器中获取组件 Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class); Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); User user01 = run.getBean(&quot;user01&quot;, User.class); Pet tom = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom)); } } ```java * 4、@Import({User.class, DBHelper.class}) * 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名 * * * */ @Import({User.class, DBHelper.class}) @Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件 public class MyConfig { } 2、@Conditional条件装配：满足Conditional指定的条件，则进行组件注入 2.2、配置绑定1、@ConfigurationProperties/** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 */ @Component @ConfigurationProperties(prefix = &quot;mycar&quot;) public class Car { private String brand; private Integer price; public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public Integer getPrice() { return price; } public void setPrice(Integer price) { this.price = price; } @Override public String toString() { return &quot;Car{&quot; + &quot;brand=&#39;&quot; + brand + &#39;\\&#39;&#39; + &quot;, price=&quot; + price + &#39;}&#39;; } } 2.3、按需开启自动配置项虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration 按照条件装配规则（@Conditional），最终会按需配置。 总结 SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定 生效的配置类就会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能就有了 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改。 xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值 —-&gt; application.properties Chapter3—配置文件1、文件类型1.2、yaml1.2.1、简介YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 非常适合用来做以数据为中心的配置文件 1.2.2、基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#’表示注释 字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义 1.2.3、示例@Data public class Person { private String userName; private Boolean boss; private Date birth; private Integer age; private Pet pet; private String[] interests; private List&lt;String&gt; animal; private Map&lt;String, Object&gt; score; private Set&lt;Double&gt; salarys; private Map&lt;String, List&lt;Pet&gt;&gt; allPets; } @Data public class Pet { private String name; private Double weight; } # yaml表示以上对象 person: userName: zhangsan boss: false birth: 2019/12/12 20:12:33 age: 18 pet: name: tomcat weight: 23.4 interests: [篮球,游泳] animal: - jerry - mario score: english: first: 30 second: 40 third: 50 math: [131,140,148] chinese: {first: 128,second: 136} salarys: [3999,4999.98,5999.99] allPets: sick: - {name: tom} - {name: jerry,weight: 47} health: [{name: mario,weight: 47}] 2、配置提示自定义的类和配置文件绑定一般没有提示。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Chapter4—Web开发1.1、模板抽取（thymeleaf） 首先，根据需求提取出模板网页 在模板网页中，利用th:fragment=”xxx”将模板”碎片化“ 然后在需要的网页中使用th:insert=“[模板名称]::[碎片名]”或th:replace=“[模板名称]::[碎片名]”或th:include=“[模板名称]::[碎片名]” 1.2、拦截器配置 配置拦截器 将拦截器注册到容器中（其实是先配置到一个config配置类中，然后容器再通过调用 配置类 来进行 装配） 必要时会指定拦截路径 1.2.1、拦截器原理（复习）1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】 2、先来顺序执行 所有拦截器的 preHandle方法 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle 2、如果当前拦截器返回为false。直接 倒序执行所有已经执行了的拦截器的 afterCompletion； 3、如果任何一个拦截器返回false。直接跳出不执行目标方法 4、所有拦截器都返回True。执行目标方法 5、倒序执行所有拦截器的postHandle方法。 6、前面的步骤有任何异常都会直接倒序触发 afterCompletion 7、页面成功渲染完成以后，也会倒序触发 afterCompletion 1.3、文件上传 /** * MultipartFile 自动封装上传过来的文件 * @param email * @param username * @param headerImg * @param photos * @return */ @PostMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException { log.info(&quot;上传的信息：email={}，username={}，headerImg={}，photos={}&quot;, email,username,headerImg.getSize(),photos.length); if(!headerImg.isEmpty()){ //保存到文件服务器，OSS服务器 String originalFilename = headerImg.getOriginalFilename(); headerImg.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); } if(photos.length &gt; 0){ for (MultipartFile photo : photos) { if(!photo.isEmpty()){ String originalFilename = photo.getOriginalFilename(); photo.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); } } } return &quot;main&quot;; } 1.4、原生组件注入（Servlet、Filter、Listener）该注解写在主程序类中 @ServletComponentScan(basePackages = “xxx”) :指定原生Servlet组件都放在那里 下列注解用来表示各个组件： @WebServlet(urlPatterns = “/my”) @WebFilter(urlPatterns={“/css/*“,“/images/*“}) @WebListener 1.4.1、利用RegistrationBean来注入组件@Configuration public class MyRegistConfig { @Bean public ServletRegistrationBean myServlet(){ MyServlet myServlet = new MyServlet(); return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;);//在注入的servlet，以及对应的映射路径 } @Bean public FilterRegistrationBean myFilter(){ MyFilter myFilter = new MyFilter(); // return new FilterRegistrationBean(myFilter,myServlet()); FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; } @Bean public ServletListenerRegistrationBean myListener(){ MySwervletContextListener mySwervletContextListener = new MySwervletContextListener(); return new ServletListenerRegistrationBean(mySwervletContextListener); } } Chapter5—数据访问导入JDBC场景 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 导入数据库驱动默认版本：&lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- &lt;version&gt;5.1.49&lt;/version&gt;--&gt; &lt;/dependency&gt; 想要修改版本 1、直接依赖引入具体版本（maven的就近依赖原则） 2、重新声明版本（maven的属性的就近优先原则） &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt; &lt;/properties&gt; 另外，可以通过修改spring.jdbc来修改JdbcTemplate的相关值测试：@Slf4j @SpringBootTest class Boot05WebAdminApplicationTests { @Autowired JdbcTemplate jdbcTemplate;//！！！！！！！！！！！！！这里的自动注入可能会无法注入，解决方法在下面 @Test void contextLoads() { // jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;) // jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,) Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class); log.info(&quot;记录总数：{}&quot;,aLong); } } 解决JdbcTemplate无法自动注入的问题： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;--&gt; 只要不引入上面那个注释掉的依赖就可以了（我也不知道为什么，我给这个折磨了好一阵子了。。。） 使用Druid数据源 引入druid-starter &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; 能够进行自动配置的相关属性 扩展配置项 spring.datasource.druid DruidSpringAopConfiguration.class, 监控SpringBean的；配置项：spring.datasource.druid.aop-patterns DruidStatViewServletConfiguration.class, 监控页的配置：spring.datasource.druid.stat-view-servlet；默认开启 DruidWebStatFilterConfiguration.class, web监控配置；spring.datasource.druid.web-stat-filter；默认开启 DruidFilterConfiguration.class}) 所有Druid自己filter的配置 使用mybatis &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 使用yaml配置mybatis（替代原先的mybatis-congfig.xml全局配置文件） # 配置mybatis规则 mybatis: # config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml configuration: map-underscore-to-camel-case: true 可以不写全局；配置文件，所有全局配置文件的配置都放在configuration配置项中即可 总的来说整合mybatis的操作和以前几乎一样 导入mybatis官方starter 编写mapper接口。标准@Mapper注解 编写sql映射文件并绑定mapper接口 在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （建议；配置在mybatis.configuration） mybatis-plus(mybatisX)不用手写crud了！ &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; MybatisPlusAutoConfiguration 配置类，MybatisPlusProperties 配置项绑定。mybatis-plus：xxx 就是对**mybatis-plus的定制** SqlSessionFactory 自动配置好。底层是容器中默认的数据源 mapperLocations 自动配置好的。有默认值。**classpath*:/mapper/*/\\.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。 建议以后sql映射文件，放在 mapper下** 容器中也自动配置好了 SqlSessionTemplate @Mapper 标注的接口也会被自动扫描；建议直接 @MapperScan(“xxx”) 批量扫描就行 注意： mybatis_plus 默认会使用 “id” 为主键字段，如果数据库的主键字段不是“id”的话，使用mybatis-plus中的 selectById ,getById 方法查询数据是查询不出来的。所以就会出现空指针…（折磨人，别问我为什么知道…） 解决方法： 在实体类的主键字段加上@TableId(value =“数据库你的主键字段”)注解即可","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"/tags/Spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于算法周预习作业的一些答案","slug":"关于算法周预习作业的一些答案","date":"2021-06-14T15:00:00.000Z","updated":"2022-06-14T11:22:56.463Z","comments":true,"path":"undefined/关于算法周预习作业的一些答案/","link":"","permalink":"/undefined/关于算法周预习作业的一些答案/","excerpt":"","text":"关于算法周预习作业的一些答案第二周 适合用分治法求解的问题一般具有哪些基本特征？ 首先问题规模一般比较大，但是随着问题规模的缩小到一定程度便能够轻松解决 各个子问题之间相互独立，无公共子问题 分治法求解问题主要包括哪几个步骤？ 分而治之（分解，求子问题的解，最后合并所有问题的解） 递归算法的算法框架？ 寻找递归方程，确定递归出口n0，若问题规模超过n0，则将问题分解成子问题 分治策略若使用递归算法实现，如何使用主定理法推算其大 O? 合并排序算法基本思想？ 将n个待排序的元素分成两个规模差不多的子数组，如果子数组不为单元素则继续分解。因为单元素数组默认已经排好了序，这时候再将相邻的两个数组两两合并，最后得到结果 合并排序算法解题步骤？ 如何建立递归方程分析合并排序算法的时间复杂性？ 由T(n)=aT(n/b)+f(n)得，规模为n的问题被分为两个规模为n/2的子问题，即a=2，b=2，因此k=1。所以T(n)=O(nlogn) 二分搜索是如何完成折半查找的？ 有手就行 如何分析二分搜索的搜索效率？ 规模n的问题简化为一个规模为n/2的子问题，所以a=1，b=2，因此k=0,。所以T(n)=O(logn) 第三周1) 二分搜索具有较高搜索效率的主要原因是什么？ 充分利用了元素之间的次序关系，加速了搜索进程 2) 快速排序算法包含哪几个主要步骤？ 分解：一般默认第一个元素为基准元素，将数组中的元素依次与基准元素比较，比其大的放在基准右边，反之放在左边。一轮扫描结束后，基准元素应该处于整个数组的中间位置。之后以基准元素的分界点，将数组分为两段。 递归求解：若数组长度不为1，一直递归求解左右子问题 合并 3) 快速排序当选择了基准元素之后如何进行子问题划分？ 比基准元素小的所有元素划分为左子问题，比基准元素大的所有元素划分为右子问题 4) 为什么快速排序不需要子问题解合并的步骤？ 因为每次分解都对这个元素实现了排序 5) 为什么快速排序算法只有在最好情况下，时间复杂性才有 Ο(nlogn)？ 因为每次选择基准元素的时候，很难保证每次都选择到所有元素中的中值元素，因此也就很难均匀地划分子问题 6) 什么情况下，快速排序算法复杂性会达到 Ο(n2 )？如何改进？ 当每次选择的基准元素都为第一个元素，可以使用平衡快速排序和基于随机支点选择的快速排序法 7) 为什么快速排序算法只讨论平均情况下的时间复杂性？ 第四周 线性时间选择 线性时间选择问题提出是如何在最坏情况下用线性时间在一个包 含 n 个元素的线性序集中找到第 k 小元素。为什么采用快速排序 的 randomizedSelect 算法无法保证在最坏情况下可以用O (n )线性 时间找到第 k 小元素? 线性时间选择算法的关键是要解决划分不平衡的问题，那么如何 选择基准元素才能解决这个问题?其选择的基准元素会出现在哪 个范围之内? 线性时间选择算法基本思想的核心是什么?线性时间选择算法为 什么每一次递归搜索都至少能放弃 n/4 个元素? 如何分析线性时间选择算法的计算效率？如何由其递归方程推算 其大 O? 第六周回溯算法框架 回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜 索解空间树。其可以系统地搜索问题的所有解或任一解。 1）如何定义问题解空间？如何组织问题的解空间结构？ 有一个n元向量来定义解空间，通过树的形式来组织问题解空间 2）回溯法的基本思想？ 深度优先策略 3）常用的问题解空间树主要包含哪两种？各自有何特点。 子集树：求解的结果是集合SS的某一子集的时候 排列树：求解的结果是集合SS的元素的某一种排列的时候","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"临时抱佛脚之数据库","slug":"临时抱佛脚之数据库","date":"2021-06-13T04:00:00.000Z","updated":"2022-06-14T11:20:06.726Z","comments":true,"path":"undefined/临时抱佛脚之数据库/","link":"","permalink":"/undefined/临时抱佛脚之数据库/","excerpt":"","text":"临时抱佛脚之数据库面向死记硬背的Oracle数据库 因为懒得打开学习通 第一单元：实例 Oracle进程结构中完成更新控制文件与数据文件,使其同步并触发DBWR进程,使其将脏缓存块写入数据文件中的进程是( )。—后台进程CKPT 当Oracle服务器启动时,下列哪种文件不是必须的( )。—归档日志文件 ( )是数据库数据字典的所有者。—sys 在同一个表空间中，可以有多个但是不会存在重复的是（）—文件号 可以在Oracle 11g服务器的安装目录下的( )文件中查看Oracle11g服务器的各种参数的使用情况。—initorcl.ora Oracle数据库的实例由( )组成。—SGA(系统全局区)和后台进程 以下内存区不属于实例的是( )。—PGA 如果服务器进程无法在数据缓冲区中找到空闲块,为添加从数据文件中读出的数据块,则系统会启动如下哪一个进程( )。—DBWR 数据字典表和视图存储在( )。—SYSTEM表空间 Bob试图正常关闭数据库,Oracle显示实例处于空闲状态,他试图启动数据库,Oracle显示数据库已启动,Bob最好使用( )命令关闭数据库。—ABORT Oracle进程结构中完成将重做记录从重做日志高速缓冲区写入重做日志文件的进程是( )。—后台进程LGWR 将修改过的数据块写入数据文件的进程是( )。—DBWR 关闭数据库的各种方式中,最省时又不会出现数据不一致(不一致即需要恢复数据库)的情况的是( )。—immediate 使用哪一条SHUTDOWN语句关闭数据库时,下次打开数据库是需要做恢复操作( )。—SHUTDOWN ABORT 指定( )表空间参与排序操作,可以提高排序效率。—TEMPORARY 最近使用过的SQL语句存储在( )。—共享池 下列哪种表空间可以被设置为脱机状态( )。—用户表空间 ( )不属于数据库物理存储结构。—表空间 Oracle分配磁盘空间的最小单位是( )。—数据块 Oracle 数据库启动时需要经历三个步骤和状态变换,以下顺序正确的是( )。—nomount→mount→open 回退段存储( )。—事务修改的数据原值 段是表空间中一种逻辑存储结构,以下( )不是ORACLE数据库使用的段类型。—代码段. 回退段的作用是( )。—数据库恢复、事务回滚、数据的读一致性 已提交的事务所做的数据改变由( )进程记录。–-DBWR Oracle中标准的数据块大小应该由参数 ( )决定。—DB_BLOCK_SIZE Oracle事务提交即( ) 。—LGWR进程成功写入日志 数据块的哪三个部分合称为块头部?( )—表目录、行目录、标题 数据库启动过程中哪一步读取初始化参数文件?( )—实例启动 ( )是用于保存数据库的所有变化信息的,从而保护数据库的安全。—重做日志文件 ( )是较小的二进制文件,用来描述数据库结构。—控制文件 启动DBWR进程的条件有( )。—当数据缓存的LRU列表的长度达到初始化 DB_ BLOCK _WRITE _BATCH指定值的一半时、当检查点发生时,将启动DBWR进程、若发生超时(大约3秒未被启动)、执行INSERT、UPDATE等操作时 ,没有足够的空闲块 下面属于SGA组成部分的是( )。—数据高速缓冲区、大型池、共享池、Java池 启动LGWR进程的条件包括( )。—每隔3秒,即发生一次超时,将启动LGWR、重做日志缓存被写满三分之一、用户通过COMMIT语句提交当前事务、DBWR进程开始将脏缓存块写入数据文件时先启动LGWR CKTP进程一定会引起更新的文件有( )。—控制文件、联机重做日志文件、数据文件 第二单元：结构管理 在非归档日志方式下,操作的数据库禁用了( )。—归档日志 当复用了控制文件后,其中一个控制文件损坏,理想的解决方法是( )。—用好的控制文件,覆盖坏的控制文件 创建一个数据库需要多少个控制文件?( )— 1 利用哪个参数可以设置撤销空间的管理方式?( )—UNDO_MANAGEMENT Oracle数据文件的管理策略不包含( )。—重做日志文件最好与数据文件存放在同一个磁盘上。 如何修改数据库所允许的重做日志个数( )。—修改控制文件 UNDO 数据的自动管理方式下( )。—使用 UNDO 表空间统一存储还原数据 控制文件中不包含( )。—实例信息 以下哪一个文件记录了在数据库恢复期间使用的检查点信息?( )—控制文件3 启动数据库时,如果一个或多个CONTROL_FILES参数指定的文件不存在或不可用,会出现什么样的结果?( )—Oracle返回警告信息,但不加载数据库 尽管oracle默认每个重做日志组中至少有一个成员,但是oracle建议在生产数据库中重做日志文件应该至少有几个成员?( )—4 增加控制文件的镜像文件,说法正确的是( )。—需要修改初始化参数文件 当创建一个新数据库时,以下哪种方法可以正确地多重映像控制文件?( )—在发CREATE DATABASE语句之前使用参数文件中的CONTROL_FILES初始化参数来说明至少两个控制文件的名字和位置 关于脱机表空间的说法哪一个是正确的?( )—如果将表空间设置为脱机状态,下次启动数据库时,不会对该表空间的数据文件进行可用性检查。 对撤销表空间不能执行哪些操作?( )—CREATE TABLE 在创建数据库时,必需的表空间是( )。—SYSTEM TABLESPACE DBA使用( )命令显示当前归档状态。—ARCHIVE LOG LIST DBA 在执行下列语句时返回了错误,DROP TABLESPACE USRES;可能的原因是下列哪个?( )—该表空间为非空,包含数据对象。 如果UNDO空间有活动事务,那么( )。—可以正常切换,切换后活动事务对应的撤销段保留在旧的 UNDO 表空间。 如果日志文件尺寸过小,最可能引起的问题是?( )—日志经常处于等待 在为已有的数据库增加重做日志文件时,数据库应处于哪种状态?( )—OPEN 当创建控制文件时,数据库必须处于什么状态?( )—未加载 在( )状态下可对重做日志组进行删除。—inactive 哪一个表空间不能切换为脱机状态?( )—系统表空间 假如一个表空间只具有一个大小为 100MB 的数据文件,现需将该数据文件的大小修改为 10MB,哪种方法是正确的?( )—使用带有 RESIZE 子句的 ALTER DATABASE DATAFILE 语句 如果某个数据库拥有两个重做日志组,但是第 2 重做日志组突然损坏(其中所有的成员日志都不可用),这时 DBA 应采取下列哪项操作?( )—删除原有的第 2 重做日志组,然后再使用 ALTER DATABASE ADD LOGFILE GROUP2 语句建立新的第 2 重做日志组。 表空间与数据文件关系属性正确的是( )。—一个数据文件只可属于一个表空间 把多路复用控制文件存储于不同磁盘的最大好处是( )。—防止失败 以下哪个不是撤销段的作用( )。—存储数据库对象 一个实例最多可以建立( )个归档进程。—10 删除表空间数据文件的说明正确的是( )。—只能删除空的数据文件。 在向一个现有的数据库中添加了一个数据文件之后,紧接着要做的操作是什么?( )—*备份控制文件 启动Oracle Database 11g至少需要( )个联机重做日志组。—2 如果某个数据库 LGWR 进程经常会因为检查点未完成而进入等待状态,DBA 应当采取什么措施来解决这个问题?( )—增加新的重做日志组 如果需要将oracle数据库的模式从NOARCHIVE 改为ARCHIVE模式,需要在什么状态进行?( )—mount 用于显示所有表空间描述信息的视图是（ ）—v$tablespaces 表空间管理策略,正确的是( )。—A、 [将表空间的数据文件分散保存到不同的硬盘上,平均分布物理I/O操作。] B、 [将回滚数据与用户数据分离,避免硬盘损坏而导致永久性的数据丢失。] C、 [将数据字典与用户数据分离,避免由于数据字典对象和用户对象保存在一个数据文件中而产生I/O冲突。] D、 [能够将表空间设置为脱机状态或联机状态,以便对数据库的一部分进行备份或恢复。] E、 [为不同的应用创建独立的表空间,避免多个应用之间的相互干扰。] F、 [能够将表空间设置为只读状态,从而将数据库的一部分设置为只读状态。] 关于联机重做日志,以下哪两个说法是正确的?( )—同一组中的所有成员文件都是同样大小、同一组的成员文件应置于不同的磁盘、同一组的成员文件内容完全相同 在以下有关控制文件设置与备份的论述中,哪个是正确的?( )—应该在向一个现有的数据库中添加一个数据文件之后备份控制文件、应该在创建一个表空间之后备份控制文件 第三单元：模式对象 在Oracle中创建用户时,比较适合DEFAULT TABLESPACE的表空间是( )—USERS 关于创建表时,对于表的存储参数设置说法错误的是()—同一个表空间中的表的存储参数不能冲突 关于索引使用的说法,错误的是()—Oracle对索引使用的决定都是最优的 关于模式的描述下列哪一项不正确( )。—一个表可以属于多个模式 下列的约束中,不会自动创建索引的是()—foreign key 什么是模式?( )—数据库对象的逻辑组织结构 在Oracle中,一个用户拥有的所有数据库对象统称为 ( )。—模式 下列( )不是Oracle系统中提供的约束。—控制约束 在Oracle中当一个数据表产生了大量存储碎片时,最好的调整方式是()—表结构重组 关于索引的存储,说法错误的是()—索引的存储参数必须跟表的参数一致 表结构重组时,不会发生变化的是()—段的名称 关于约束的延迟检查,说法错误的是()—可以一次性将某个表中所有的可延迟的约束设置为延迟 分区表中的索引类型，不存在的是（）—本地非分区索引 下列不属于分区表类型的是（）—Time分区 唯一值约束和主键约束的区别是什么?( )—唯一值约束的列可以为空、主码列不可以为空 关于约束禁用与激活,说法错误的是()—禁用主键约束、惟一性约束时,会删除其对应的索引,无法保留。 删除表时,不会删除的内容是()—与该表相关的区 关于B树索引的效率与数据量相关性低的原因,正确的是()—B树索引会优先扩展同层节点,而不是增加层数 关于分区表中各个分区的数据存储，说法正确的是（）—可以忽略分区，直接向表中添加数据 第四单元：安全与备份 关于闪回技术,说法错误的是( )—闪回技术可以保护系统表空间中的表。 DML误操作可以使用( )来恢复。—还原段 创建用户的命令中,( )子句限制用户对象在数据库中占用的空间。—QUOTA 数据库运行在归档模式时,关于RMAN操作的描述正确的是( )。—RMAN需要恢复目录 完全备份时,数据库应该处于( )—mount状态 下面不是常用的对象权限的是( )。—grant 要恢复一个丢失的数据文件,而归档重做日志文件已经损坏,DBA应该执行的命令是( )。—RECOVER DATABASE UNTIL CANCEL; 使用RMAN进行数据库不完全恢复,目标数据库必须处于的状态为( )。—MOUNT 下列关于角色描述,说法有误的是( )—角色可以授予自己,也可以循环授予。 以下哪个权限是对象权限?( )—INDEX Oracle有不同类型的备份,不包括( )。—人工备份 利用下面闪回技术不能直接进行数据恢复的是( )。—闪回事务查询 为了执行一次完整的数据库介质恢复操作,数据库必须处于那种状态?( )—处于Mount状态,但不打开数据库 当数据库系统崩溃以后首要任务是()。—让数据库开启并对外提供服务 数据库运行在非归档模式,数据库的一个表空间不可用,DBA恢复数据库的方法是( )。—利用数据库的一致性备份修复数据文件、控制文件和重做日志文件 修复Recover是利用重做日志文件或数据库的增量备份文件重新建立已经丢失的数据,这是一种( )。—逻辑修复 概要文件中SESSIONS_PER_USER限制了什么?( )—每用户会话数量 若用户要连接数据库,则该用户必须拥有的权限是( )。—create session 哪个参数限制用户在断开前的最大空闲时间?( )—IDLE_TIME 给用户定义缺省角色时,下列哪种情况不行? ( )—当角色有密码时 关于闪回技术的描述正确的是( )。—闪回技术是数据库物理备份与恢复、逻辑备份与恢复的重要补充 使用( )命令,被授予权限的用户可以进一步将这个权限授予其他用户。—WITH ADMIN OPTION 以下权限哪个是系统权限?( )—BACKUP ANY TABLE 概要文件不能限制下列哪个资源的使用?( )—读取数据块时间 数据库处于归档模式,不可进行( )类型的备份。—使用ALTER DATABASE BACKUP TABLESPACE备份联机表空间 以下4种关闭数据库的方式中,只有( )在系统重新启动时需要进行数据库的恢复。—shutdown abort 以下哪种备份方式需要完全关闭数据库( )—非归档日志模式下的数据库备份 在数据库打开状态下进行备份时,下面描述不正确的是( )。—数据库必须处于READ ONLY状态 Oracle数据库利用( )进行资源限制和口令管理。—概要文件 在Oracle数据库中,管理员以管理员身份登录后,进入的模式是( )。—SYS 闪回数据库功能需要满足的条件有( )。—数据库必须处于归档模式、数据库设置了闪回恢复区、数据库必须使用管理员帐号登录、数据库启用了FLASHBACK DATABASE特性 用户属性包括( )。—A、账户状态B、表空间配额C、临时表空间D、默认表空间E、概要文件F、用户身份认证方式 概要文件资源限制类型包括( )。—用户连接数据库的总时间、CPU使用时间、用户连接数据库的空闲时间、逻辑读时间 备份原则与策略正确的有( )。—A、对于重要的表中的数据,可以采用逻辑备份方式进行备份。 B、在归档模式下,当数据库结构发生变化时,如创建或删除表空间、添加数据文件、重做日志文件等,应该备份数据库的控制文件 C、在刚建立数据库时,应该立即进行数据库的完全备份 D、至少保证两个归档重做日志文件的归档目标,不同归档目标应该分散于不同磁盘 E、将所有的数据库备份保存在一个独立磁盘上 F、根据数据库数据变化的频率情况确定数据库备份规律","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"大学所学","slug":"大学所学","permalink":"/tags/大学所学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"动态规划矩阵连乘","slug":"动态规划之矩阵连乘","date":"2021-05-14T15:00:00.000Z","updated":"2022-06-14T11:23:05.519Z","comments":true,"path":"undefined/动态规划之矩阵连乘/","link":"","permalink":"/undefined/动态规划之矩阵连乘/","excerpt":"","text":"Throw the problem事情是这样的，有这样一群捣鼓矩阵的人，他们模拟数的运算法则，整出了矩阵的运算法则。他们发现矩阵A和矩阵B相乘得到矩阵C要做很多次乘法。两个矩阵相乘，计算这个有手就行。三个矩阵相乘还可以接受，四个的话就有点慌，五个的话就有点吃力，六个、七个…既然人算费力，那就交给鸡算，呸，机算。虽然说不用人算，但是矩阵链的长度一上来，电脑也顶不住啊。这帮人开始思考能不能尽可能用最少的乘法次数来实现矩阵的连乘，他们联想到数的运算法则的乘法结合律,因为相邻的矩阵之间是可以若干个组合的。如果给他们加上括号以此来决定乘法的优先级，岂不美哉？光想没用，那就是试试呗。这一试就试出“问题”了。他们发现通过这种“结合运算”的方式，都能得到最终的结果，但是中间用到的乘法次数多少却是“两极分化”! 举个栗子 ：比如 A1 = 10x100，A2 = 100x5，A3 = 5x50，假如矩阵组合的方式为 ((A1A2)A3) 那么总的相乘次数应为 101005+10550 = 7500，而假如矩阵的组合方式为 (A1(A2A3)) 那么相乘的次数应为 100550+1010050 = 75000，我们可以发现两种不同的组合方式的相乘次数竟然相差这么多。 因此，如何找到最少的相乘次数显得尤为重要，那么该如何解决这个问题呢？ How 2 solve this shit？Recursion对于一个规模比较庞大的问题，我们首先想到的就是嫩不能把问题分解成若干个子问题。对于矩阵链（MatrixChain），我们可以递归一下 图中用红色方框框起来的代表在递归的过程中，会被重复计算的矩阵链，这还只是四个矩阵，那如果是四十个，四百个…重复计算的矩阵链只会越来越多（这谁顶得住啊.jpg），因此我们希望寻找更好的方法来解决它。 Dynamic planning要解决重复计算的问题，我们能想到的是用一张表来保存每次计算出的矩阵连乘积，如果在后续的计算中要用到原先的结果，只需要去表中查找就好了。于是乎，动态规划就起了作用。那么，啥是动态规划？ What is it?先来看它的官方定义：动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。 PS：其实在生活中，我们有时候也会使用动态规划这一思想。比如，公司评选优秀员工（最），直接评选不好安排，但是我们可以“自底向上”地比较筛选，那方法就是：选出每个小组表现优秀的员工，又因为一个部门有很多小组，这样能选出一个部门的优秀员工，最后公司又是由很多部门组成的，最后通过类似“集成”的形式就能选出最优秀的员工了。 Exert it！那么，对于矩阵链连乘积次数的求法，也能用类似的思路（自底向上），因为一个矩阵相乘的需要的连乘积次数为0。 所以我们先算出两个两个矩阵相乘的连乘积，然后把结果分别存入一张记录表里 接着计算三个矩阵链的… 四个的 五个的 ……………. 最后我们需要几个变量 p 数组用于存放每个矩阵的维数（每个矩阵对应的行和列） m 一个二维数组，用于存放计算某一个矩阵链所需的【连乘积】的次数 s 还是一个二维数组，用于存放矩阵链Ai···Aj的断裂点（k的位置） 拿两个矩阵相乘的情况举例，起始矩阵下标i从1开始，而i最后的位置应该为n-2，因为我们当前为两个矩阵相乘，到最后时结尾矩阵下标j位于整个矩阵序列的结尾处，所以此时起始矩阵下标i应该在结尾矩阵的下标j往回减2。结尾坐标的起始位置就是起始坐标的下标加上当前相乘矩阵的数目。举个例子，比如当前为两个矩阵相乘，那么 r = 2，那么起始坐标 i 的开始位置就是 0，结束位置就为 n - r，结尾下标为 j = i + n - 1。 然后我们在这个区间内再来求取断点 k ，断点的取值范围应该为[i,j)，然后对区间内的所有情况进行计算，即 m[i][k] + m[k+1][j] + 结果矩阵相乘次数（这里需要注意一下，这里是为了好理解，其实按照我们给定的输入，它的每三个数字代表两个矩阵，即比如 {35，30，25}，对应的矩阵应为 A1 = 35x30，A2 = 30x25。所以完全写成递归式应该为 m[i][k] + m[k+1][j] + p[i]p[k+1]*p[j]），比如当 i = i，r = 2 时，j = 1，k = i = 1 那么这时当前断点开始处的计算结果应为 m[1][1] + m[2][2] + p[0]p[1]p[2]. Code Segment（Less important）public class matrixChain { /*** * * @param p 用于存放每个矩阵的维数（每个矩阵对应的行和列） * @param m 一个二维数组，用于存放计算某一个矩阵链所需的【连乘积】的次数 * @param s 还是一个二维数组，用于存放矩阵链Ai···Aj的断裂点（k的位置） * @return */ public static int solution(int[]p,int[][]m,int[][]s){ int n=p.length-1;//矩阵个数 for(int r=2;r&lt;=n;r++){ for(int i=1;i&lt;=n-r+1;i++){ int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++){ int temp=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(temp&lt;m[i][j]){ m[i][j]=temp; s[i][j]=k; } } } } return m[1][n]; } public static void traceback(int i, int j, int[][] s) { // 输出A[i:j] 的最优计算次序 if (i == j) { // 递归出口 System.out.print(&quot;A&quot;+i); return; } else { System.out.print(&quot;(&quot;); // 递归输出左边 traceback(i, s[i][j], s); // 递归输出右边 traceback(s[i][j] + 1, j, s); System.out.print(&quot;)&quot;); } } public static void main(String[] args) { int[] p = new int[]{5,200, 2, 100, 30, 200}; int[][] m=new int[p.length][p.length]; int[][] s=new int[p.length][p.length]; int result=matrixChain.solution(p,m,s); System.out.println(result); traceback(1, p.length-1, s); } } Result of running the code","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"批作业处理问题","slug":"批作业处理问题","date":"2021-04-22T02:30:00.000Z","updated":"2022-06-14T11:37:52.962Z","comments":true,"path":"undefined/批作业处理问题/","link":"","permalink":"/undefined/批作业处理问题/","excerpt":"","text":"public class seriesOfWork { static int n = 5;//作业数量，其实用不到。。。 static int[] x = {1, 2, 3, 4, 5};//初始作业调度顺序 static int[] bestx = new int[x.length+1];//最优的作业调度顺序 static int f1;//机器1完成时间 static int[] f2 = new int[x.length+1];//机器2完成时间 static int f;//当前完成所有作业的时间 static int bestf=9999;//最优的时间 static int[][] chart = { {0, 0, 0}, {0, 3, 5}, {0, 6, 1}, {0, 5, 2}, {0, 4, 4}, {0, 3, 2}};//调度方案 public static void main(String[] args) { //int[] x = {1, 2, 3,4,5}; int[] temp=new int[x.length+1]; boolean isVisit[] = new boolean[x.length]; work( 0, x, temp, isVisit); System.out.println(&quot;最优的作业调度方案：&quot;); for(int i =1;i&lt;temp.length;i++){ System.out.print(&quot; &quot;+temp[i]+&quot; &quot;); } System.out.println(); System.out.println(&quot;最优值为：&quot;); System.out.println(bestf); } /** * @param x 需要进行全排列的作业调度顺序 * @param index 指向“固定”的位置的指针，值为0时，指向第一个固定位置，也就是temp[0] * @param temp 临时数组，用于存放被“固定”的作业 * @param isVisit 用来标记该作业是否已经被选择“固定” */ public static void work( int index, int[] x, int[] temp, boolean[] isVisit) { if (index == x.length) {//结束递归条件 //System.out.println(Arrays.toString(temp)); for(int i=1;i&lt;x.length+1;i++){//----------------------------------------核心代码 f1+=chart[temp[i]][1]; f2[i]=(Math.max(f2[i - 1], f1))+chart[temp[i]][2]; f+=f2[i]; } if(f&lt;bestf){ bestf=f; for(int j=1;j&lt;=x.length;j++){ bestx[j]=temp[j]; } } } for (int i = 0; i &lt; x.length; i++) {//遍历数组的每个数（作业） if (!isVisit[i]) {//判断数是否被使用，如果未使用则继续后面的操作 temp[index+1] = x[i];//将该作业插入temp数组 isVisit[i] = true;//将该数标记为已使用 work( index + 1, x, temp, isVisit);//开始递归，插入下一个数 isVisit[i] = false;//执行到这一步的时候，说明有一个作业排列已经打印出来了，这时从后往前将每个作业重置为未访问使用 f1=0; f=0; } } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"霍夫曼树の创建、编码、解码","slug":"霍夫曼树の创建、编码、解码","date":"2021-04-14T08:30:00.000Z","updated":"2021-04-14T16:05:24.000Z","comments":true,"path":"undefined/霍夫曼树の创建、编码、解码/","link":"","permalink":"/undefined/霍夫曼树の创建、编码、解码/","excerpt":"","text":"开头霍夫曼树的相关概念就不一一赘述了，直接上代码。放心，必要的地方我会加上我自己都看不懂的注释 Mr.Winterの实验要求： 读取一个文本文件，并统计出每个字符的出现次数。随后将一个字符的出现次数作为字符的权值（霍夫曼树中的叶子节点的权值） 将字符和其权值保存起来（链表？or动态数组？） 利用得到的所有字符，构建霍夫曼树（拿到霍夫曼树的根节点） 对每一个字符进行霍夫曼编码，并得到一张编码表 根据编码表，输入一个编码后能够对其进行解码并返回其所对应的字符 步骤读取文本文件并统计各个字符的出现次数（权值）package readtxt; import java.io.*; import java.util.HashMap; import java.util.Map; public class ReadTxt { /** * 传入txt路径读取txt文件 * * @param txtPath * @return 返回读取到的内容 */ public static HashMap&lt;String, Integer&gt; readTxtAndCount(String txtPath) throws IOException { File file = new File(txtPath); FileInputStream fileInputStream = new FileInputStream(file); InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); StringBuffer sb = new StringBuffer(); String text = null; while ((text = bufferedReader.readLine()) != null) {//按行读取字符串 sb.append(text);//将每一行保存到StringBuffer缓冲里 } String txt = sb.toString();//保存为字符串 char[] TXT = txt.toCharArray();//将字符串保存为字符数组 Map&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;();//创建哈希表（类似键值对），统计字符出现的次数 for (char c : TXT) { String s = String.valueOf(c);//取出一个字符 if (null != m.get(s)) {//若该字符不是第一次出现 int count = m.get(s);//取出之前出现的次数count m.put(s, count + 1);//+1 } else { m.put(s, 1);//若一次也没有出现，则置为1 } } return (HashMap&lt;String, Integer&gt;) m; } public static void main(String[] args) throws IOException { HashMap&lt;String,Integer&gt; m=ReadTxt.readTxtAndCount(&quot;U:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;); } } 值得一提的是，哈希表yyds。它的作用类似Python里面的字典（键值对），字符:出现次数 创建节点类Node保存字符信息package node; public class Node implements Comparable&lt;Node&gt; { //字符 public String sign; //每个叶子节点对应的哈夫曼编码 String code; //叶子节点的权重 public int weight; //非叶子节点的左右孩子 public Node lchild; public Node rchild; Node next;//叶子节点的enxt，用于专门指向root，便于后续的解码操作 public Node(String sign, int weight) { this.sign = sign; this.weight = weight; } public String getCode() { return code; } @Override public int compareTo(Node o) { return this.weight - o.weight; } @Override public String toString() { return &quot;Node{&quot; + &quot;sign=&#39;&quot; + sign + &#39;\\&#39;&#39; + &quot;, weight=&quot; + weight + &#39;}&#39;; } public void CodingByPreOrder(String code, Node root) {//先序遍历哈夫曼树 if (!this.sign.equals(&quot;非叶子节点&quot;) &amp;&amp; !this.sign.equals(&quot;根节点&quot;)) { this.code = code; System.out.println(this.sign + &quot;的哈夫曼编码&quot; + code); } if (this.lchild != null) { this.lchild.CodingByPreOrder(code += &quot;0&quot;, root); } //StringBuilder能够替换原字符串的最后一个字符（仅仅是替换最后一个），不使用String的substring方法是因为这个方法会替换所有与替换字符相同的字符 StringBuilder sb = new StringBuilder(code);//回溯时，需要修改最后一个字符，将其置为空，下一次向右递归code的最后一个字符就会被置为1 //replace(参数1，参数2，参数3)，参数1为要替换的开始位置，参数2为要替换的结束位置，参数3为替换内容, code = sb.replace(code.length() - 1, code.length(), &quot;&quot;).toString(); if (this.rchild != null) { this.rchild.CodingByPreOrder(code + &quot;1&quot;, root); } //将所有叶子节点的next都指向root节点，方便后续的解码操作 if (!this.sign.equals(&quot;非叶子节点&quot;) &amp;&amp; !this.sign.equals(&quot;根节点&quot;)) { this.next = root; } } /*** * * @param root 霍夫曼树根节点 * @param code 输入的一个编码 * @param index code的索引下标 * @return */ public String Decoding(Node root, String code, int index) { Node ROOT=root; StringBuilder s = new StringBuilder(); while (index &lt; code.length()) {//遍历code的每一个字符（也就是那一串01...） if (code.charAt(index) == &#39;0&#39;) { ROOT = ROOT.lchild;//向左子树移动 } if (code.charAt(index) == &#39;1&#39;) { ROOT = ROOT.rchild;//向右子树移动 } if (ROOT.next == root) {//如果到达叶子节点，也就是它的next指向了根节点 s.append(ROOT.sign); ROOT=root;//当解码出一个字符，需要将ROOT重置为root根节点，方便进行下一个字符的解码 } index++;//索引后移 } if(ROOT==root){//编码全部正确 System.out.println(code+ &quot;解码后对应的字符为&quot; + s.toString()); return s.toString(); } else if(!s.toString().equals(&quot;&quot;)&amp;&amp;ROOT.next==null){//部分编码正确的情况 System.out.println(&quot;输入的编码部分有误，仅能解码出部分字符&quot;+s.toString()+&quot;...&quot;); return s.toString(); } else {//编码全部错误 System.out.println(&quot;输入的编码完全错误，无法解码...&quot;); return null; } } } 利用得到的节点类构建霍夫曼树package huffmantree; import node.Node; import java.util.*; public class HuffmanTree { /* public static void main(String[] args) throws IOException { Node root = createHuffmanTree(ReadTxt.readTxtAndCount(&quot;E:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;)); root.sign = &quot;根节点&quot;; preOrder(root); }*/ //构建哈弗曼树 public static Node createHuffmanTree(HashMap&lt;String, Integer&gt; arr) { //int count = 0; List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //将字符出现的次数作为权值value，并以此加入node节点中 for (String key : arr.keySet()) { nodes.add(new Node(key, arr.get(key))); } //System.out.println(nodes);//打印所有节点（验证） Collections.sort(nodes);//将节点排序 System.out.println(&quot;各个字符对应的权重：&quot;); System.out.println(&quot;nodes =&quot; + nodes); while (nodes.size() &gt; 1) { //取出根节点权值最小的兩顆二叉树 //取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); //取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //构建一棵新的二叉树 Node parent = new Node(&quot;非叶子节点&quot;, leftNode.weight + rightNode.weight); parent.lchild = leftNode; parent.rchild = rightNode; //删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //将parent加入到nodes nodes.add(parent); //重新排序 Collections.sort(nodes); //System.out.println(&quot;第&quot; + (++count) + &quot;次处理后&quot; + nodes); } return nodes.get(0); } public static void preOrder(Node root) {//利用先序遍历打印霍夫曼编码表 if (root != null) { root.CodingByPreOrder(&quot;&quot;, root); } else { System.out.println(&quot;空树无法遍历...&quot;); } } public static String deCoding(Node root, String code, int index) {//解码 return root.Decoding(root, code, index); } } PS：另外，编码和解码的核心代码在Node类中 主程序的测试代码import java.io.IOException; import java.util.Scanner; import huffmantree.HuffmanTree; import node.Node; import readtxt.ReadTxt; public class Test { public static void main(String[] args) throws IOException { boolean flag=true; Scanner sc=new Scanner(System.in); int key=0; Node root=new Node(null,0); while(flag){ menu(); while(true) { key = sc.nextInt(); if(key&lt;1||key&gt;3){ System.out.println(&quot;请输入正确的序号...&quot;); menu(); }else{ break; } } switch (key){ case 1: root=HuffmanTree.createHuffmanTree(ReadTxt.readTxtAndCount(&quot;U:\\\\烂盘\\\\dark二\\\\带二第二学期\\\\程序设计综合实验\\\\实验3\\\\Demo.txt&quot;)); HuffmanTree.preOrder(root); break; case 2: System.out.println(&quot;请输入一个来自编码表的编码...&quot;); String s=sc.next(); HuffmanTree.deCoding(root,s,0); break; case 3: flag=false; break; } } } public static void menu() { System.out.println(&quot;\\n §※§※§※§※§※§ 霍夫曼编码与解码.§※§※§※§※§※§\\t\\n&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 1. 霍夫曼の编码(获得编码表).※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 2. 霍夫曼の解码.※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\t※◎※◎※◎※◎ 3. 退出程序.※◎※◎※◎※◎\\t&quot;); System.out.println(&quot;\\n\\t请选择：\\t&quot;); } } 结果截图： 结尾 各位爷，代码也看了注释也读了思路应该也理清一点点了，接下来应该做啥就不用我说了吧（可怜巴巴）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于我写了个装载问题的野鸡算法的那档事","slug":"关于我写了个装载问题的野鸡算法的那档事","date":"2021-04-10T13:00:00.000Z","updated":"2022-06-14T11:22:00.331Z","comments":true,"path":"undefined/关于我写了个装载问题的野鸡算法的那档事/","link":"","permalink":"/undefined/关于我写了个装载问题的野鸡算法的那档事/","excerpt":"","text":"由于原来的（书上的）算法我实在是看不懂…所以我想仿照我之前解决全排列的思路（逐个选择法）解决这个问题 import java.util.Arrays; public class Loading { static int[] w={5,2,1,3}; int n=4,c1=10,cw=0,bestw=0; static int[] isVisit=new int[w.length]; /*** * * @param c1 第一艘船的最大载重 * @param w 数组，用于记录每件货物的重量 * @param cw 当前最大载重 * @param bestw 最佳载重 * @param isVisit 整形数组（相当于解空间的其中一个解），若将货物搬上第一艘船，则用1表示，否则置为0，数组一开始初始化值均为0，表示还没货物上船 * @param index 从第几号货物开始，然后按照顺序决定是否将其搬上船 * @return * * 另外这代码的返回值是bestw，如果在某个阶段找到了bestw，则在回溯的时候bestw会被一直保留，在回溯的过程中bestw也有可能被替换 * 唯一的缺陷就是，在回溯的过程找到了最佳bestw无法单独打印出来，截图的效果就是缺陷，最后一种装载方案就是最佳的装载方案 */ public static int loading(int c1,int[] w,int cw,int bestw,int[] isVisit,int index){ for(int i=index;i&lt;w.length;i++) { if (isVisit[i]!=1&amp;&amp;(cw+w[i]&lt;=c1)){//如果当前货物A没上船并且（当前最大载重＋A的重量）＜第一艘船的最大载重 isVisit[i]=1;//A货物上船 cw+=w[i];//改变当前载重 if(cw&gt;bestw){//如果当前载重＞最佳载重，则更新最佳载重 bestw=cw; System.out.println(Arrays.toString(isVisit)); } else{//如果没有则直接返回，结束返回上一级函数 return bestw; } bestw=loading(c1,w,cw,bestw,isVisit,index+1); cw-=w[i]; isVisit[i]=0; } } //System.out.println(Arrays.toString(container)); return bestw; } public static void main(String[] args) { int[] w={5,2,1,3}; int c1=10,cw=0,bestw=0; int[] container=new int[w.length]; int bw= Loading.loading(c1,w,cw,bestw,isVisit,0); System.out.println(&quot;第一艘货船最多能载的货物重量为&quot;+bw); System.out.println(&quot;其中最后一种装载方案是最优的...&quot;); } } 最后的结果截图（也是这段代码最大的问题…虽然结果对了）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"线性时间选择","slug":"线性时间选择","date":"2021-03-23T11:30:00.000Z","updated":"2022-06-14T11:43:03.164Z","comments":true,"path":"undefined/线性时间选择/","link":"","permalink":"/undefined/线性时间选择/","excerpt":"","text":"线性时间选择问题描述：在一个的数组中（数组中的元素有n个），查找第k小的数。 常规思路：若数组有序，直接输出arr[k-1]即可… 但是…如果一个数组是无序的话，上面的方法就不太行了，因此需要引入线性时间选择。线性时间选择可以模仿快速排序，基本思想是对输入数组进行递归划分，与快速排序不同的是，它只对划分出来的子数组之一进行递归处理 参数说明： p：数组最左 r：数组最右 k：要查找的第k小的元素 解题步骤： 先将数组按五个一组的划分，共有n/5列 然后利用任意排序方法求出每一列的中位数 将每一列的中位数按照顺序与原数组的前几位元素互换位置 再递归求解出中位数的中位数，也就是基准量x 用得到的基准在整个数组使用快速排序，得到x在数组中的下标i（第j=i+1-p小的数） 将k和j进行比较，若k≤j，说明要查找的数在j的左边的数组，返回步骤一，继续递归 反之，则向j的右边的数组递归 不要说了不要说了，先上代码先上代码！public class Select { public static Comparable select(int p,int r,int k,int[] arr){ if(r-p&lt;75){//如果n＜75，則直接使用任意一个排序方法直接求出第k小的数 int[] arr1=BubbleSort.bubble(arr); return arr1[p+k-1]; } for(int i=0;i&lt;=(r-p-4)/5;i++){//将数组的元素五个为一列，分出i+1列 int s=p+5*i;//每列的首位元素 int t=s+4;//每列最后一个元素 for(int j=0;j&lt;3;j++){//对每列进行冒泡排序，因为我们只要每列（只有五个元素）的中位数，所以只要三趟冒泡排序，将中位数元素&quot;沉底&quot;到中间 Bubble.bubble(arr,s,t-j); Swap.swap(arr,s+2,p+i);//每列的中位数按顺序分别与数组前几位调换位置 } } Comparable x=select(p,(r-p-4)/5,(r-p+6)/10,arr);//寻找中位数的中位数x（快速排序的基准） int i=Partition.partion(p,r, (Integer) x,arr);//用得到的基准进行快速排序 int j=i-p+1;//表示第j小的元素 if (k&lt;=j) return select(p,i,k,arr);//要执行这一步，说明要找的第k小的元素在基准的左边，因此继续向左边递归 else return select(i+1,r,k-j,arr);//反之亦然 } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"汇编语言学习笔记（注：本篇笔记均摘自一位热心的B站用户---_惜取少年时_）","slug":"汇编语言学习笔记","date":"2021-03-14T06:00:00.000Z","updated":"2022-06-14T11:38:13.962Z","comments":true,"path":"undefined/汇编语言学习笔记/","link":"","permalink":"/undefined/汇编语言学习笔记/","excerpt":"","text":"汇编语言学习笔记（【汇编语言】小甲鱼零基础汇编）[TOC] 注：本篇笔记均摘自一位热心的B站用户—惜取少年时 第一章 基础知识【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】 汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。 1.汇编课程的研究重点 如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作 2.汇编语言的主体是汇编指令 3.汇编指令和机器指令的差别在于指令的表示方法上 汇编指令是机器指令便于记忆的书写格式 4.汇编语言时机器指令的助记符 5.汇编语言的组成 1.汇编指令（机器码的助记符） 2.伪指令（由编译器执行） 3.其他符号（由编译器识别，如：+ - * /） 汇编语言的核心是汇编指令，他决定了汇编语言的特性 6.CPU对存储器的读写 CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互 1.地址信息：存储单元的地址 2.控制信息：芯片的选择，读或写命令3.数据信息：读或写的数据 第二章 寄存器（CPU工作原理）CPU=运算器+控制器+【寄存器】，器件之间通过总线相连 8086CPU有14个寄存器，名称分别为： AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW 2.1 通用寄存器 1.8086CPU所有的寄存器都是16位的，可以存放2个字节 2.AX、BX、CX、DX通常用来存放一般性数据 被称为通用寄存器 3.8086上一代CPU中的寄存器都是8位的，为了保证兼容性 这四个寄存器都是可以分为2个独立的8位寄存器使用 AX=AH+AL BX=BH+BL CX=CH+CL DX=DH+DL 4.AX的低8位（0-7）构成AL寄存器 高8位（8-15）构成了AH寄存器 AH和AL寄存器是可以独立使用的8位寄存器 2.2 字在寄存器中的存储 8086一个字16位 2.3 几条汇编指令 1.汇编指令不区分大小写 2.几条汇编指令 mov ax,18 ;AX=18 mov ah,78 ;AH=78 add ax,8 ;AX=AX+8 mov ax,bx ;AX=BX add ax,bx ;AX+=BX 3.用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方 mov ax,2 ;ax=2 add ax,ax ;ax=4 add ax,ax ;ax=8 add ax,ax ;ax=162.4 物理地址 1.CPU访问内存单元时，要给出内存单元的地址。 2.所有的内存单元够成的存储空间是一个一维的线性空间 3.我们将这个唯一的地址称为物理地址2.5 16位结构的CPU 16位结构描述了一个淳朴具有以下几个方面特征： 1.运算器一次最多可以处理16位的数据 2.寄存器的最大宽度为16位 3.寄存器和运算器之间的通路是16位的2.6 8086CPU给出物理地址的方法 1.8086有20位地址总线，可传送20位地址，实际上的寻址能力为1M 2.8086内部为16位结构，它只能传送16位的地址，理论上表现出的寻址能力却只有64K 3.问题：8086CPU如何用内部16位的数据转换成20位的地址？ 1.8086CPU采用一种在内部用两个16位地址合成的方法，来形成20位的物理地址 即：段地址+偏移地址=物理地址 2.地址加法器合成物理地址的方法： 物理地址=段地址×16+偏移地址 3.“地址段×16”即是数据左移4位（二进制位的左移4位，十六进制的左移1位） 在地址加法器中，如何完成“段地址×16”？ 二进制形式的段地址左移4位2.7 “段地址×16+偏移地址=物理地址”的本质含义 1.即可以用两个16位的二进制数来表示一个20位的二进制数 2.8086CPU中内部为16位结构，但地址线却是20位的，使用地址加法器可以把16位地址变成20位地址 具体操作就是：段地址×16+偏移地址2.8 段的概念 1.内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址×16+偏移地址=物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存 2.以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段， 使用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元 3.注意 1.段地址必然是16的倍数，即一个段的起始地址必然是16的倍数 2.偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K 3.CPU可以用不同的段地址和偏移地址形成同一个物理地址2.9 段寄存器 1.段寄存器就是提供段地址的 8086CPU有4个段寄存器： 1.CS（code segment） 2.DS（data segment） 3.SS（stack segment） 4.ES（extra segment） 2.当8086CPU要访问内存时，有这4个段寄存器提供内存单元的段地址2.10 CS和IP 1.CS和IP时候8086CPU中最关键的寄存器 他们指示了CPU当前读取指令的地址。 2.CS和IP的含义 CS：代码段寄存器 IP：指令指针寄存器【专用寄存器】 3.8086CPU工作过程的简要描述 1.从CS:IP指向内存单元，读取指令，读取的指令进入指令缓冲器 2.IP=IP+所读取指令的长度，从而指向下一条指令 3.执行指令，转到步骤1，重复这个过程 4.开机时的CS和IP 1.在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为 CS=FFFFH，IP=0000H 2.即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行 3.FFFF0H单元中的指令是8086PC机开机后执行的第一条指令 5.修改CS、IP的指令 1.在CPU中，程序员能够【用指令读写】的部件只有【寄存器】， 程序员可以通过改变寄存器中的内容实现对CPU的控制 2.CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容 控制CPU执行目标指令 3.如何修改CS和IP？ 1.通过mov改变AX等，但是不能通过mov改变CS和IP 2.【jmp 段地址:偏移地址】 可以用来同时修改CS和IP 指令中的段地址修改CS 偏移地址修改IP 3.【jmp 某一合法的寄存器】 仅修改IP的内容 比如：jmp ax 或者 jmp bx（类似于mov IP ax） 4.jmp是只具有一个操作对象的指令2.11 代码段 1.可以将长度为N（N&lt;=64KB）的一组代码，存放在一组地址连续、其实地址为16的倍数的内存单元中 这段内存是用来存放代码的，从而定义了一个代码段 2.CPU中只认被CS:IP指向的内存单元中的内容为指令 【实验一】查看CPU和内存，用机器指令和汇编指令编程 1.R命令：查看、改变CPU寄存器的内容 r后面加寄存器的名称可以改变CPU寄存器的内容 2.D命令：查看内存中的内容 3.E命令：改写内存中的内容 4.U命令：将内存汇总的机器指令翻译成汇编指令 5.T命令：执行一条机器指令 6.A命令：以汇编指令的格式在内存中写入一条机器指令 1.debug中输入的默认是16位数 2.空格数量任意 7.按Q可以退出 第三章 寄存器（内存访问）3.1 内存中字的存储 1.任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个存储单元 也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元2.注意：在内存的表示中，从高到低，是从0号单元开始，然后逐渐变大， 即在书写时，低位写在高的地方，高位写在低的地方， 如上图所示：4E20H即是0号字节存储20，1号字节存储4E3.2 DS和[address] 1.8086中有一个DS寄存器，通常用来存放要访问的数据的段地址 2.例如：我们要读取10000H单元的内容可以用如下程序段进行： mov bx,1000H mov ds,bx mov al,[0] 上面的三条指令将10000H（1000:0）中的数据读到al中 1.复习：已知mov指令可以完成的两种传送功能 1.将数据直接送入寄存器 2.将一个寄存器中的内容送入另一个寄存器中 2.除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器 mov指令格式：mov 寄存器名,内存单元地址 […]表示一个内存单元，“[…]”中的…表示内存单元的【偏移地址】 执行指令时，8086CPU自动取DS中的数据为内存单元的【段地址】 3.如何把1000H放入DS中？ 要通过通用寄存器把段地址传入到DS中 8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器 即：mov ds,1000H 是非法的 数据-&gt;通用寄存器-&gt;段寄存器 3.写几条指令，将AL中的数据送入内存单元10000H？ mov bx,1000H mov ds,bx mov [0],al ;al中的字节型数据送入到1000H:0中3.3 字的传送 1.8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据 即：一次可以传送一个字 2.比如 mov bx,1000H mov ds,bx mov ax,[0] ;1000H:0处的字型数据送入ax中 mov [0],cx ;cx中的16位数据送入到1000H:0中3.4 mov、add、sub指令 1.复习：已学mov指令的几个形式 1.mov 寄存器,数据 ;立即寻址 2.mov 寄存器,寄存器 ;寄存器寻址 3.mov 寄存器,内存单元 ;直接寻址 4.mov 内存单元,寄存器 ;寄存器寻址？ 5.mov 段寄存器,寄存器 ;寄存器寻址 6.mov 寄存器,段寄存器 ;寄存器寻址 2.add、sub同mov一样，都有两个操作对象 1.add的用法 1.add 寄存器,数据 ;立即寻址 2.add 寄存器,寄存器 ;寄存器寻址 3.add 寄存器,内存单元 ;直接寻址 4.add 内存单元,寄存器 ; 2.sub的用法 【不带借位的减法】 指令格式 sub op1,op2 ;意为：op1=op1-op2 1.sub 寄存器,数据 ;立即寻址 2.sub 寄存器,寄存器 ;寄存器寻址 3.sub 寄存器,内存单元 ;直接寻址 4.sub 内存单元,寄存器 ;3.5 数据段 如何访问数据段中的数据？ 将一段内存当作数据段，是我们在编程时的一种安排 具体操作：用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元3.6 栈 1.8086CPU提供相关的指令来以栈的方式访问内存空间 这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用 2.8086CPU提供入栈和出栈指令：（最基本的） push（入栈） pop（出栈） 1.push ax：将寄存器ax中的数据送入栈中 2.pop ax：从栈顶取出数据送入ax 3.8086CPU的入栈和出栈操作都是以【字（16位）】为单位进行的 4.pop和push可以在寄存器和内存之间传送数据 3.CPU如何知道一段内存空间被当做栈使用？ 1.8086CPU中，有两个寄存器 1.段寄存器SS：存放栈顶的段地址 2.寄存器SP：存放栈顶的偏移地址【专用寄存器】 2.任意时刻SS:SP指向栈顶元素，当栈为空的时候，也就不存在栈顶元素 ss:sp也就指向栈最高地址单元的下一个单元 4.执行push和pop的时候，如何知道哪个单元是栈顶单元？ 1.执行push ax时 1.sp=sp-2 2.将ax中的内容送入到ss:sp指向的内存单元 ss:sp此时指向新栈顶 2.执行pop ax时 1.将ss:sp指向的内存单元的内容送入到ax中 注意：这里取出的内容在内存中还是存在的，并没有被重置 下一轮push会覆盖 2.sp=sp+2 5.如果栈是空的，sp指向哪里？ sp指向最高地址单元的下一个单元3.7 栈顶超界的问题 ss、sp只记录了栈顶的地址，依靠ss、sp可以保证在入栈和出栈时找到栈顶 可以，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？ 1.8086CPU不保证栈的操作不会越界 2.当栈空的时候，再执行pop出栈 或者 当栈满的时候再使用push入栈 都会发生栈顶超界问题，会操作到栈以外的数据， 这些数据可能是其他用途的数据或者代码 栈顶超界是危险的！！！ 3.8086CPU没有记录栈顶上下限的寄存器3.8 栈段 1.将一段内存当做栈段，仅仅是我们在编程时的一种安排， 2.ss:sp指向我们定义的栈段的栈顶； 3.当栈空时，sp指向最高地址的下一个单元 4.思考：一个栈段最大可以设为多少？ 64KB 5.设栈顶的变化范围是0-FFFFH，从栈空时sp=0（最高地址单元FFFFH的下一个单元0000H） 一直压栈，直到栈满，sp=0； 如果再次压栈，栈顶将环绕，覆盖原来栈中的内容 6.一段内存，既可以是代码的存储空间，又可以是数据的存储空间，还可以是栈空间 也可以是什么都属实。 关键在于CPU中寄存器的设置，即：cs、ip、ss、sp、ds的设置 **可以通过mov直接给sp赋值【立即数寻址】，但是不能通过mov给cs、ip、ss、ds赋值 给cs和ip赋值需要使用jum指令 给ss和ds赋值需要使用mov ss或ds,寄存器 ;【寄存器寻址】 【实验二】 第四章 第一个汇编程序4.1 一个源程序从写出到执行的过程 1.一个汇编语言程序从写出到最终执行的简要过程 编写-&gt;编译连接-&gt;执行 2.对源程序进行编译连接 1.使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】 2.再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】。 3.可执行文件包含两部分内容 1.程序（从源程序的汇编指令翻译过来的机器码）和数据（源程序中定义的数据） 2.相关的描述信息（比如：程序有多大、要占多少内存空间等） 4.执行可执行文件中的程序 1.在操作系统（如：MSDOS）中，执行可执行文件中的程序 2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存 并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序 4.2 源程序的主要结构 源程序由 汇编指令+伪指令+宏指令 组成 伪指令：编译器处理 汇编指令：编译为机器码 1.伪指令 1.没有对应的机器码的指令，不能由CPU直接执行 2.伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作 2.segment和ends【定义一个段】 1.segment和ends是一对成对使用的伪指令 2.编写汇编程序【必须】使用到的指令 3.segment和ends的功能是定义一个段 segment：说明一个段开始 ends：说明一个段结束 4.一个段必须有一个名称来标识，使用格式为 段名 segment 段名 ends 5.一个汇编程序由多个段组成 这些段用来存放【代码、数据、或当作栈空间】来使用 一个有意义的汇编程序至少要有一个段，这个段用来存放代码。 3.end【真正的没了】 1.end是一个汇编程序的结束标记 2.编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译 3.如果程序写完了，要在结尾处加上伪指令end 否则，编译器无法知道程序在何处结束 4.【切记】不要把end和ends搞混了 end：汇编程序的结束标记 ends：与segment成对出现 4.assume【寄存器和段的关联假设】 1.它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联 2.通过assume说明这种关联，在需要的情况下， 编译程序可以将段寄存器和某一具体的段相联系 5.程序和源程序 1.我们将源程序文件中的所有内容称为【源程序】 2.将源程序中最终由计算机执行处理的指令或数据称为【程序】 3.程序最先以汇编指令的形式，存储在源程序中 然后经过编译、连接后转变为机器码，存储在可执行文件中 6.标号，标号与段名称有所区别 1.一个标号指代了一个地址，即是段名称。 2.段名称 放在segment的前面，作为一个段的名称 这个段的名称最终将被汇编、连接程序处理为一个段的段地址 7.DOS中的程序运行 1.DOS是一个单任务操作系统 2.一个程序结束后，将CPU的控制权交还给是他得以运行的程序 我们称这个过程为：程序返回 8.程序返回 mov ax，4c00H int 21H ;【中断机制】是DOS最伟大的机制,Windows系统上是【消息机制】 这两条指令所实现的功能就是程序返回 9.几个和结束相关的内容 1.段结束：伪指令 通知编译器一个段的结束【ends】 2.程序结束：伪指令 通知编译器程序的结束【end】 3.程序返回：汇编指令 mov ax,4c00H int 21H 10.语法错误和逻辑错误 1.语法错误 1.程序在编译时被编译器发现的错误 2.容易发现 2.逻辑错误 1.在编写时不会表现出来的错误、在运行时会发生的错误 2.不容易发现 4.3 以简化的方式进行汇编和连接 汇编使用的程序：masm.exe 连接使用的程序：link.exe 简化方式进行汇编和连接的程序：ml.exe 4.4 汇编和连接的作用 连接的作用 1.当源程序很大时，可以将他们分成多个源程序文件夹编译 每个源程序编译成为目标文件后，再用连接程序将它们连接在一起， 生成一个可执行文件 2.程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起 生成一个可执行文件 3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接 用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。 所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用 连接程序对目标文件进行处理，生成可执行文件 4.5 可执行文件中的程序装入内存并运行的原理 1.在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2 将P1从可执行文件中加载入内存，将CPU的控制权交给P1，P1才能得以运行 2.当P1运行完毕后，应该将CPU的控制权交还给使他得以运行的程序 3.操作系统的外壳 1.操作系统是由多个功能模块组成的庞大、复杂的软件系统 任何通用的操作系统，都需要提供一个称为shell（外壳）的程序， 用户（操作人员）使用这个程序来操作计算机系统工作 2.DOS中有一个程序command.com，这个程序在DOS中称为命令解释器 也就是DOS系统的shell 4.执行可执行文件1.exe时， （1）什么程序将CPU的控制权交给了1.exe？ （2）将程序1.exe加载入内存后，如何使程序得以运行？ （3）1.exe程序运行结束后，返回到了哪里？ 1.在DOS中直接执行1.exe时，是正在运行的cmd.exe将1.exe中的程序加载入内存 2.cmd.exe设置CPU的CS:IP指向程序的第一条指令（即，程序的入口） 从而使程序得以运行 3.程序运行结束后，返回cmd.exe中，CPU继续运行cmd.exe 【实验三】 第五章 【bx】和loop指令5.1 [bx] 1.和[0]类似，[0]表示内存单元，它的偏移地址是0； 2.[bx]同样也表示一个内存单元，它的段地址在DS中 它的偏移地址在bx中，至于是取字还是取字节， 要看他放入的寄存器是8位还是16位 3.补充：inc指令：相当于C语言中的++运算符5.2 Loop指令 这个指令和循环有关 1.指令格式：loop 标号 CPU执行loop指令的时候，要进行两步操作 1.(cx)=(cx)-1; 2.判断cx中的值，若不为零，则转至标号处执行程序 若为零，则向下执行。 2.通常，loop指令实现循环，cx中存放循环的次数 3.标号 在汇编语言中，标号代表了一个地址，标号标识了一个地址 4.使用cx和loop指令相配合实现循环功能的三个要点 1.在cx中存放循环次数 2.loop指令中的标号所标识地址要在前面 3.要循环执行的程序段，要写在标号和loop指令的中间 5.用cx和loop指令相配合实现循环功能的程序框架 mov cx,循环次数 S:循环执行的程序段 loop s5.3 在Debug中跟踪供loop指令实现的循环程序 **注意：在汇编程序中，数据不能以字母开头，如果要输入像FFFFH这样的数 则要在前面添加一个0 在debug程序中引入G命令和P命令 1.G命令 G命令如果后面不带参数，则一直执行程序，直到程序结束 G命令后面如果带参数，则执行到ip为那个参数地址停止 2.P命令 T命令相当于单步进入（step into） P命令相当于单步通过（step over）5.4 Debug和汇编编译器Masm对指令的不同处理 1.在debug中，可以直接用指令 mov ax,[0] 将偏移地址为0号单元的内容赋值给ax 2.但通过masm编译器，mov ax,[0] 会被编译成 mov ax,0 1.要写成这样才能实现：mov ax,ds:[0] 2.也可以写成这样： mov bx,0 mov ax,[bx] ;或者mov ax,ds:[bx]5.5 loop和[bx]的联合应用 1.计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中 1.注意两个问题 1.12个8位数据加载一起，最后的结果可能会超出8位（越界），故要用16位寄存器存放结果 2.将一个8位的数据加入到16位寄存器中，类型不匹配，8位的数据不能与16位相加 2.【解决办法】 把原来8位的数据，先通过通用寄存器ax，将它们转化成16位的 3.代码如下 assume cs:codesg codesg segment start: ;指定数据段 mov ax,0ffffh mov ds,ax ;初始化 mov ax,0 mov dx,0 mov bx,0 ;指定循环次数，12次 mov cx,0ch circ: ;把8位数据存入al中,即ax中存放的是[bx]转化之后的16位数据，前8位都是0 mov al,[bx] ;进行累加 add dx,ax ;bx自增，变化内存的偏移地址 inc bx loop circ ;程序返回 mov ax,4c00h int 21H codesg ends end start 5.6 段前缀 1.指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中 2.我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器 比如 mov ax,ds:[0] mov ax,ds:[bx] 这里的ds就叫做【段前缀】 5.7 一段安全的空间 1.8086模式中，随意向一段内存空间写入内容是很危险的 因为这段空间中可能存放着【重要的系统数据或代码】 2.在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用【0:200~0:2FF】 的256个字节的空间。所以，我们使用这段空间是安全的 第六章 包含多个段的程序6.1在代码段中使用数据 1.dw的含义【定义字型数据：define word，16字节】 在数据段中使用dw定义数据，则数据在数据段中 在代码段中使用dw定义数据，则数据在代码段中 堆栈段也是一样 2.在程序的第一条指令前加一个标号start，并且这个标号在伪指令end后面出现 可以通知编译器程序在什么地方结束，并且也可以通知编译器程序的入口在哪里6.2在代码段中使用栈 **补充：如果题目要求【逆序】存放，就要想到栈（FILO） 使用dw向系统申请一段空间，然后把这个空间当做栈6.3将数据、代码、栈放入不同的段 1.在前面的6.1和6.2中，我们在程序中用到了数据和栈，我们在编程的时候要注意 何处是数据，何处是栈、何处是代码 2.这样做显然有两个问题 1.把他们放在一个段中是程序显得混乱 2.前面程序中处理的数据很少，用到的栈空间也小，放在一个段里面没有问题 但数据、栈、代码需要的空间超过64KB，就不能放在一个段中 (8086中一个段的容量不能大于64KB) 3.我们可以和定义代码段一样的方法来定义多个段 然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间 4.将数据、代码、栈放入不同的段 1.我们可以在源程序中为这三个段起具有含义的名称 用来存放数据的段，我们将其命名为“data” 用来存放代码的段，我们将其命名为“code” 用来作栈空间的段，我们将其命名为“stack” 但是CPU看得懂吗？【不能】 2.我们在源程序中用伪指令 “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连 这样做了之后，CPU是都就会将cs指向code，ds指向data，ss指向stack 从而按照我们的意图来处理这些段呢？【不能】 伪指令CPU看不懂，伪指令是给编译器看的 3.若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令 才是CPU要执行的内容 需在在code段中给DS，CS、SS设置相应的值才能让CPU识别出数据段、代码段、堆栈段 其中汇编程序开始的地方（即代码段开始的地方）由end后面的标号所指向的地方给出 5.assume指令不可省略，至于为什么，需要以后多多体会 【实验五】 1.如果段中的数据占N个字节，则程序加载后，这段实际占有的空间为：N%16==0?N:16×(N/16+1); 因为一个段最小占用16字节，即有16个字节只有这个段可以访问到 2.在编辑源程序的时候，如果调换各个段的编写位置，最后CS、DS、SS的值会发生变化 3.如果去掉start，编译器会从上到下执行，如果第一个段是代码段，则可以正常运行 若第一个段不是代码段，则不会正常运行 4.代码示例1 assume cs:code,ds:data,ss:stack ;数据段 data segment ;8个数据 dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends ;栈段 stack segment ;8个数据 dw 0,0,0,0,0,0,0,0 stack ends ;代码段 code segment start: ;栈空间初始化 mov ax,stack mov ss,ax mov sp,16 ;数据段初始化 mov ax,data mov ds,ax push ds:[0];一个栈单元是一个字 push ds:[2] ;存放数据不会改变 pop ds:[2] pop ds:[0] ;程序返回 mov ax,4c00h int 21h code ends end 5.将a，b数据段中的内容分别相加，结果放入data数据段中 assume cs:code ;数据段 a segment db 1,2,3,4,5,6,7,8 a ends ;数据段 b segment db 1,2,3,4,5,6,7,8 b ends ;数据段 data segment db 0,0,0,0,0,0,0,0 data ends ;代码段 code segment start: mov bx,0 mov ax,0 mov dx,a mov ss,dx mov dx,b mov es,dx mov dx,data mov ds,dx mov cx,8 circ: add al,ss:[bx] add al,es:[bx] mov [bx],al inc bx mov al,0 loop circ ;程序返回 mov ax,4c00h int 21h code ends end start 6.将a数据段中的前8个字型数据逆序存储到b段中 assume cs:code a segment dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh a ends b segment dw 0,0,0,0,0,0,0,0 b ends code segment start: mov ax,0 mov ax,a mov ss,ax mov sp,0 mov ax,0 mov ax,b mov ds,ax mov bx,0 mov cx,8 circ: pop [bx] add bx,2 loop circ mov ax,4c00h int 21h code ends end start 第七章 更灵活地定位内存地址本章主要讲解一些更灵活的定位内存地址的方法和相关的编程方法 7.1 and和or指令 1.and指令：逻辑与指令，按位进行与运算 1.如:mov al,01100011B and al,00111011B 执行后： al=00100011B 2.通过and指令可将操作对象的相应位设为0，其他位保持不变 例如al的第6位设为0：and al,10111111B 例如al的第7位设为0：and al,01111111B 例如al的第0位设为0：and al,11111110B 2.or指令，逻辑或运算，按位进行或运算 1.如:mov al,01100011B or al,00111011B 执行后： al=01111011B 2.通过该指令可将操作对象的相应位设为1，其他位不变 or al,01000000B;将al的第6位设为1 or al,10000000B;将al的第7位设为1 or al,00000001B;将al的第0位设为17.2 关于ASCII码 一种编码方案，在计算机系统中通常被采用，8位 7.3 以字符形式给出的数据 1.在汇编程序中，可以使用’×××’的方式指明数据是以字符的形式给出的 2.编译器会将它们转化为相应的ASCII码 3.例如 1.db ‘unIX’ ;相当于：db 75H,6EH,49H,58H ‘u’、’n’、’I’、’X’的ASCII码分别为75H,6EH,49H,58H 2.mov al,’a’ ;相当于：mov al，61H ‘a’的ASCII码为61H 4.ASCII码中，大写字母和小写字母之间的规律 小写字母=大写字母+32 小写字母=大写字母+20H 大写字母从41H开始排，小写字母从61H开始排大写|二进制|小写|二进制-|-|-|-A|01000001|a|01100001B|01000010|b|01100010C|01000011|c|01100011D|01000100|d|01100100 7.4 大小写转换的问题 1.方案一： 1.识别出是该字节是表示一个的大写英文字符，还是小写的 用于条件判断的汇编程序，目前还没有学到 2.根据+20H 或者 -20H进行大小写转换 2.方案二： 1.若全部转化为大写，则将第5位置0 and al,11011111B 2.若全部转化为小写，则将第5位置1 or al,00100000B7.5 [bx+常数] mov ax,[bx+200]的含义： 1.将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个入一个子单元 该字单元的偏移地址为bx中的数值加上200，段地址在ds中 2.也可以写成 1.mov ax,200[bx] 2.mov ax,[bx].2007.6 用[bx+idata]的方式进行数组的处理 在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写 1.我们观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5 2.我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放 3.我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符 4.注意这个数组的定位方式，对比C语言 C语言的数组定位方式：a[i]，b[i]， a、b是地址常量 汇编语言的数组定位方式：0[bx],5[bx] 所以：[bx+常数]的方式为高级语言实现数组提供了便利的机制 assume cs:codesg,ds:datasg datasg segment db &#39;BaSiC&#39; db &#39;MinIX&#39; datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 mov cx,5 ;做5次循环 circ: mov al,[bx] and al,11011111b mov [bx],al mov al,[bx+5];等价于mov al,5[bx];等价于mov al,[bx].5 or al,00100000b mov 5[bx],al inc bx loop circ mov ax,4c00h int 21h codesg ends end start 7.7 SI和DI 已经学过的10个寄存器：AX、BX、CX、DX、DS、CS、SS、ES、IP、SP 1.SI和DI是8086CPU中和bx功能相近的寄存器 bx不够用，所以引进了SI和DI 2.SI和DI（16位）不能够分成两个8位寄存器来使用【和bx的区别】 3.下面三组指令实现了相同的功能 1.mov bx,0 mov ax,[bx] 2.mov si,0 mov ax,[si] 3.mov di,0 mov ax,[di] 4.下面三组指令也实现了相同的功能 1.mov bx,0 mov ax,[bx+123] 2.mov si,0 mov ax,[si+123] 3.mov di,0 mov ax,[di+123] 5.用寄存器SI和DI实现将字符串&#39;welcome to masm!&#39;复制到它后面的数据区中 通常用ds:si指向要复制的源始字符串 通常用ds:di指向要复制的目的空间 **注意si、di是16位寄存器，循环中自增时，应该+2 assume cs:code,ds:data data segment db &#39;welcome to masm!&#39; db &#39;................&#39; data ends code segment start: mov ax,data mov ds,ax mov si,0 mov di,16 mov cx,8 circ: mov ax,0[si] mov [di],ax inc di inc di inc si inc si loop circ mov ax,4c00h int 21h code ends end start 7.8 [bx+si]和[bx+di] 1.[bx+si]和[bx+di]的含义类似，我们以[bx+si]为例进行讲解 [bx+si]表示一个内存单元，它的偏移地址为bx中的数值加上si中的数值 它的偏移地址在ds中 2.[bx+si]也可以写成[bx][si]7.9 [bx+si+常数]和[bx+di+常数] 1.以[bx+Si+常数]为例讲解 [bx+si+常量]表示一个内存单元，偏移地址为bx的值+si的值+常数 2.指令mov ax,[bx+si+常数]也可以写成如下形式 1.mov ax,200[bx+si] 2.mov ax,200[bx][si] 3.mov ax,[bx].200[si]7.10 不同的寻址方式的灵活应用 1.总结几种定位内存的方法 1.ds:[常数] 【直接寻址】 用一个常量来表示地址，可用于直接定位一个内存单元 2.[bx] 【寄存器间接寻址】 用一个寄存器的值来表示内存地址，可以间接定位一个内存单元 3.[bx+常数] 【？？】 用一节寄存器的值和常量表示内存地址，可在一个起始地址的基础上用变量间接定位一个内存单元 4.[bx+si] 5.[bx+si+常数] 2.编程，给定数据段data，将data段中每个单词的头一个字母改写成大写字母 assume cs:code,ds:data data segment db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends code segment start: mov ax,data mov ds,ax mov bx,0 mov cx,6 circ: mov al,[bx+3] and al,11011111b mov [bx+3],al add bx,16 loop circ mov ax,4c00h int 21h code ends end start 3.编程，给定数据段data，将data段中的每个单词改为大写字母 1.【loop指令cx-1之后，在判断是否为0】 2.双重循环用汇编怎么实现？ 应该在每次开始内循环的时候，将外层循环的cx的值保存起来， 在执行外层循环的loop指令前，在恢复外层循环的cx数值。 **可以用寄存器来临时保存，也可以用栈空间（内存）保存【没有多余的寄存器】 更好的方法是使用：栈 1.使用寄存器实现 assume cs:code,ds:data data segment db 4,4,6,4,7,4;单词的字母数 db &#39; &#39;;补齐 db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends code segment start: mov ax,data mov ds,ax mov bx,16 mov si,0 mov di,0 mov cx,6;外层循环6次 outer:;外层循环 mov dx,cx;用寄存器将外层循环的次数保存，C语言中是用栈来保存的 mov cx,0 mov cl,[di];内循环的次数 inner:;内层循环 mov al,[bx][si+3] and al,11011111b mov [bx][si+3],al inc si loop inner add bx,16 mov si,0 inc di mov cx,dx;恢复外层循环的次数 loop outer mov ax,4c00h int 21h code ends end start 2.使用栈实现【更好的方法】 assume cs:code,ds:data,ss:stack data segment db 4,4,6,4,7,4;单词的字母数 db &#39; &#39;;补齐 db &#39;1. file &#39; db &#39;2. edit &#39; db &#39;3. search &#39; db &#39;4. view &#39; db &#39;5. options &#39; db &#39;6. help &#39; data ends stack segment dw 1,2,3,4,5,6,7,8 stack ends code segment start: mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,16 mov bx,16 mov si,0 mov cx,6;外层循环6次 outer:;外层循环 push cx;将外层循环的次数保存 mov cx,0 mov cl,[di];内循环的次数 inner:;内层循环 mov al,[bx][si+3] and al,11011111b mov [bx][si+3],al inc si loop inner add bx,16 mov si,0 inc di pop cx;恢复外层循环的次数 loop outer mov ax,4c00h int 21h code ends end start 第八章 数据处理的两个基本问题本章对前面的所有内容是具有总结性的 计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中： 1.处理的数据在什么地方？ 2.要处理的数据有多长？ 这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作 8.1 bx、si、di、bp 1.在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中，用来进行内存单元的寻址 2.在“[…]”中，这四个寄存器（bx、bp、si、di）可以单个出现， 或者只能以以下4种组合出现 1.bx和si 2.bx和di 3.bp和si 4.bp和di 3.错误的用法 mov ax,[bx+bp] mov ax,[si+di] 4.只要在[…]中使用寄存器bp，则指令中没有显性给出段地址，那么 段地址就默认在ss中，比如： mov ax,[bp] ax的值为栈空间中，偏移地址为bp的内存单元 mov ax,[bp+常数] mov ax,[bp+si] mov ax,[bp+si+常数]8.2 机器指令处理的数据所在的位置 1.绝大部分机器指令进行数据处理的指令大致可分为3大类 读取、写入、运算 2.在机器指令这一层，并不关心数据的值是多少，而关心指令执行前一刻 它将要处理的数据所在的位置 3.指令在执行前，所要处理的数据可以在三个地方 CPU内部（寄存器）、内存、端口8.3 汇编语言中数据位置的表达 汇编语言中用三个概念来表达数据的位置 1.立即数 2.寄存器 3.段地址（SA）和偏移地址（EA） 1.存放段地址的寄存器可以是默认的， 既可以是默认在ds中，也可以是在ss中（使用bp寄存器） 2.存放段地址的寄存器也可以显性的给出 mov ax,ds:[bp] mov ax,es:[bx] mov ax,ss:[bx+si] mov ax,cs:[bx+si+8]8.4 寻址方式 8.5 指令要处理的数据有多长？ 1.8086CPU的指令，可以处理两种尺寸的数据，byte和word 所以在机器指令中要指明，指令进行的是字操作还是字节操作 2.8086CPU确定数据长度的几种方法 1.通过寄存器名指明要处理的数据的尺寸 mov al,1 ;指明数据是字节型的 mov bx,ds:[0] ;指明数据是字型的 2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度 X在汇编指令中可以为word或byte 1.下面的指令中，用byte ptr指明了指令访问的内存单元是字节型单元 mov byte ptr ds:[0],1 inc byte ptr [bx] inc byte ptr ds:[0] add byte ptr [bx],2 2.下面的指令中，用word ptr指明了指令访问的内存单元是字型单元 mov word ptr ds:[0],1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 3.其他方法 有些指令默认了访问的内存单元类型 pop、push指令，一定是字型数据 3.在没有寄存器参与的内存单元访问指令中，用word ptr或者byte ptr 显性地指明所要访问的内存单元的长度，是非常有必须要的 否则，CPU无法得知所要访问的单元是字单元，还是字节单元8.6 寻址方式的综合应用8.7 div指令 1.div是除法指令（division），使用div作除法的时候，要求 1.除数：8位或16位，在寄存器或内存单元中 2.被除数：（默认）放在AX或DX和AX中 3.除数与被除数的相互关系 除数 被除数 8位 16位（AX） 16位 32位（DX+AX） 4.结果存放的位置 运算 8位 16位 商 AL AX 余数 AH DX 2.div指令格式 1.div 寄存器 2.div 内存单元 除数是寄存器或内存单元的内容 3.div指令示例 1.div byte ptr ds:[0] ;被除数是16位，除数是ds:[0]的内容(8位) 含义：(al)=(ax)/((ds)16+0)的商 (ah)=(ax)/((ds)16+0)的余数 2.div word ptr es:[0] ;被除数是32位，除数是es:[0]的内容(16位) 含义：(ax)=[(dx)10000H+(ax)]/((es)16+0)的商 (dx)=[(dx)10000H+(ax)]/((es)16+0)的余数 4.利用除法指令计算100001/100 1.被除数100001大于65535，要使用dx和ax两个寄存器联合存放 即说要进行的16位的除法 2.除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位 除数应为16位，所以要用16位寄存器来存放除法100 3.现将100001表示成十六进制数：186A1H，即dx中存放1H，ax中存放86A1H mov dx,1 mov ax,86A1H mov bx,100 div bx ;默认除数是16位的 8.8 伪指令dd 1.dd是用来定义双字型数据的 2.示例 data segment db 1 ;字节型数据 dw 1 ;字型数据 dd 1 ;双字型数据 data ends 3.已知data段数据，用div计算data中第一个数据除以第二个数据后的结果， 商存放在第3个数据的内存单元中 assume cs:code,ds:data data segment dd 100001 dw 100 dw 0 data ends code segment start: mov ax,data mov ds,ax mov bx,0 mov ax,[bx] ;低位存放在ax中 mov dx,[bx+2] ;高位存放在dx中 div word ptr [bx+4] mov [bx+6],ax ;商存放在ax中，把ax中的内容放入内存中 mov ax,4c00h int 21h code ends end start 8.9 dup 1.dup是一个操作符，在汇编语言中，同db、dw、dd等一样，也是有编译器识别处理的符号 2.dup和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复 3.dup示例 1.db 3 dup(0) ;定义了3个字节，他们的值都是0 2.db 3 dup(0,1,2) ;定义了9个字节，他们是0、1、2、0、1、2、0、1、2 3.db 3 dup(‘abc’,’ABC’) ;定义了18个字节，相当于db’abcABCabcABCabcABC’ 4.dup的使用格式 db 重复的次数 dup(重复的字节型数据) dw 重复的次数 dup(重复的字型数据) dd 重复的次数 dup(重复的双字型数据) 【实验七】 没调试成功 assume cs:code,ds:data,ss:stack,es:table stack segment ;空栈时，sp指向16 dw 8 dup(0) stack ends data segment ;表示21年的21个字符串 ;起始地址0，终止地址21*4-1：83 db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39; db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39; db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39; ;表示21年公司总收入的21个双字型数据 ;起始地址21*4：84，终止地址21*4+21*4-1：167 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;表示21年公司雇员人数的21个字型数据 ;起止地址21*8：168，终止地址21*8+21*2-1：209 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends table segment db 21 dup(&#39;year summ ne ?? &#39;) table ends code segment start: mov ax,data mov ds,ax mov ax,table mov es,ax mov ax,stack mov ss,ax mov sp,16 mov si,0 mov di,0 mov bx,0 mov bp,0 mov cx,21 outer: push si add si,si mov ax,ds:[bp] mov es:[bx][di],ax mov ax,ds:84[bp] mov es:[bx][di+5],ax pop si mov al,168[si] mov es:[bx][di+10],al inc si add di,2 push si add si,si mov ax,ds:[bp] mov es:[bx][di],ax mov ax,ds:84[bp] mov es:[bx][di+5],ax pop si mov al,168[si] mov es:[bx][di+10],al inc si add di,2 add bx,16 loop outer mov ax,4c00h int 21h code ends end start 第九章 转移指令的原理8086CPU的转移指令分为以下几类： 1.无条件跳转指令（如：jmp） 2.条件跳转指令 3.循环指令（如：loop） 4.过程，就像C语言中的函数 5.中断 9.1 操作符offset 操作符offset在汇编语言中由编译器处理，它的功能是取标号的偏移地址 如：s:mov ax,offset s9.2 jmp指令 1.无条件转移，可以只修改ip，也可以同时修改cs和ip 1.【jmp 段地址:偏移地址】 可以用来同时修改CS和IP 指令中的段地址修改CS 偏移地址修改IP 这种用法编译器不认识，只能做在debug中使用 2.【jmp 某一合法的寄存器】 仅修改IP的内容 比如：jmp ax 或者 jmp bx（类似于mov IP ax） 2.jmp指令要给出两种信息： 1.转移的目的地址 2.转移的距离（段间转移、段内短转移、段内近转移）9.3 依据位移进行转移的jmp指令 1.jmp short 标号【转到标号处执行指令,段内短转移】 此格式实现的是：段内短转移，它对ip的修改范围为-128~127 2.也就是说，它向前转移时可以最多越过128个字节，负数使用补码表示 向后转移可以最多越过127个字节 3.CPU不需要目的地址就可以实现对ip的修改 jmp指令的机器码中不包含目的地址，但是可以实现跳转 实现的方式，是在原地址的基础上进行一个偏移量，即位移 4.还有一种和指令“jmp short 标号”功能类似的指令格式： jmp near ptr 标号，它实现的是段内近转移 功能为：(ip)=(ip)+16位位移 jmp short 标号是8位的位移，而jmp near ptr 标号是16位位移9.4 转移的目的地址在指令中的jmp指令 前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前ip的转移位移 1.指令“jmp far ptr 标号” 实现的是段间转移，又称为远转移,这时机器码中应该明确给出【段地址】 2.指令“jmp far ptr 标号”功能如下： (CS)=标号所在段的段地址 (IP)=标号所在段中的偏移地址 far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip9.5 转移地址在寄存器中的jmp指令 指令格式：jmp 16位寄存器 功能：修改ip寄存器中的值，把16位寄存器中的值送入到ip寄存器中9.6 转移地址在内存中的jmp指令 转移地址在内存中的jmp指令有两种格式： 1.jmp word ptr 内存单元地址（段内转移） 功能：将内存中的那个字视为一个偏移地址，然后跳转到那个偏移地址 与【jmp 寄存器】功能相似 内存单元地址可用寻址方式的任意格式给出 2.jmp dword ptr 内存单元地址（段间转移） (ip)=(内存单元地址) ;双字中的低位字是给ip的 (cs)=(内存单元地址+2) ;双字中的高位字是给cs的 跟【jmp 段地址:偏移地址】功能类似 内存单元地址可用寻址方式的任意格式给出 补充：不能直接向内存单元中加入立即数 要通过寄存器，把立即数加进去9.7 jcxz指令 1.有条件跳转指令，所有的有条件跳转指令都是短转移 对应的机器码中包含转移的位移，而不是目的地址。对ip的修改范围都为：-128~127 另一个有条件跳转指令【loop指令】 2.指令格式：jcxz 标号 如果（cx）=0，则跳转到标号处执行 3.jcxz 标号 指令的操作： 1.当(cx)=0时，(ip)=(ip)+8位位移 2.当(cx)!=0时，什么也不做（程序继续向下执行）9.8 loop指令 1.循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移 2.指令格式：loop 标号 3.指令的内部操作 1.cx=cx-1 2.如果cx!=0，(ip)=(ip)+8位位移，跳转 3.(cx)=0，什么也不做，程序向下执行 cx用来控制循环的次数9.9 根据位移进行转移的意义 1.根据位移进行转移，这样设计，方便了程序段在内存中的浮动装配 可以实现代码的复用 2.如果在机器码中直接给出【段地址:偏移地址】， 这段程序在内存中换一个位置，则会运行不正确 3.段内近转移、段内短转移都是根据位移进行转移，一共有四种方式 1.jmp short ptr 标号 2.jmp near ptr 标号 3.jcxz 标号 4.loop 标号9.10 编译器对转移位移超界的检测 注意，根据位移进行转移的指令，他们的转移范围会受到限制 如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错 【实验八、九】【这个实验要重点看】 第十章 call和ret指令call和ret指令都是转移指令，它们都能修改ip，或同时修改cs和ip 10.1 ret和ref 1.ret指令用栈中的数据，修改ip的内容，从而实现【近转移】 CPU执行ret指令时，进行下面两步操作： 1.(ip)=((ss)16+(sp)) ;ip的值修改为栈顶的内容 2.(sp)=(sp)+2 ;栈顶移动 2.retf指令用栈中的数据，修改cs和ip的内容，从而实现【远转移】 CPU执行retf指令时，进行下面四步操作 1.(ip)=((ss)16+(sp)) ;ip的内容修改为栈顶的内容 2.(sp)=(sp)+2 ;栈顶移动 3.(cs)=((ss)16+(sp)) ;cs的内容修改为栈顶移动之后，栈顶的内容 4.(sp)=(sp)+2 ;栈顶移动 栈顶的两个字，低位字修改为ip，高位字修改为cs 3.可以看出，如果我们用汇编语法来解释ret和retf指令，则 1.CPU执行ret指令，相当于 pop ip 2.执行retf指令时，相当于 pop ip pop cs10.2 call指令 1.call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作： 1.将当前的ip或cs和ip压入栈中 2.转移 2.call指令不能实现短转移，除此之外， call指令实现转移的方法和jmp指令的原理相同 【依据位移进行转移的call指令】 3.CPU执行“call 标号”这种格式的call指令时，进行如下操作： 1.(sp)=(sp)-2 ;栈顶移动 2.((ss)16+(sp))=(ip) ;当前ip内容压栈 3.(ip)=(ip)+16位位移 ;跳转到标号处 4.call指令格式：call 标号 相当于执行： push ip jmp near ptr 标号10.4 转移的目的地址在指令中的call指令 1.指令格式：call far ptr 标号 实现的是段间转移 2.执行这种格式的call指令时CPU的操作 1.(sp)=(sp)-2 ;栈顶移动 2.((ss)×16+(sp))=(cs) ;先把cs压栈 3.(sp)=(sp)-2 ;栈顶移动 4.((ss)×16+(sp))=(ip) ;然后把ss压栈 3.CPU执行“call far ptr 标号”时，相当于进行 push cs push ip jmp far ptr 标号10.5 转移地址在寄存器中的call指令 1.指令格式：call 16位寄存器 2.执行这种指令时，在CPU中的操作 1.(sp)=(sp)-2 2.((ss)×16+(sp))=(ip) 3.(ip)=(16位寄存器) 3.相当于 push ip jmp 16位寄存器10.6 转移地址在内存中的call指令 转移地址在内存中的call指令有两种格式： 1.call word ptr 内存单元地址 汇编语法解释 push ip jmp word ptr 内存单元地址 2.call dword ptr 内存单元地址 汇编语法解释 push cs ;cs存放在高位 push ip ;ip存放在低位 jmp dword ptr 内存单元地址10.7 call和ret的配合使用10.8 mul指令 相乘的两个数；要么都是8位，要么都是16位 1.8位：AL中和8位寄存器或内存字节单元中 AL中的内容作为被乘数 结果放在AX中 2.16位：AX中和16位寄存器或内存字单元中 AX中的内容作为被乘数 结果放在DX（高位）和AX（低位）中。 3.格式如下： mul 寄存器 mul 内存单元（byte ptr或 word ptr指明是字还是字节）10.9 模块化程序设计10.10 参数和结果传递的问题 【编程】计算data段中第一组数据的3次方，结果保存在后面一组dword单元中 data sgement dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0 data ends 10.11 批量数据的传递 使用寄存器、内存、栈传递数据 【编程】将一个全是字母，以0结尾的字符串，转化为大写 【实验十 编写子程序】 1.显示字符串 2.解决除法溢出问题 3.数值显示 【课程设计1】 第十一章 标志寄存器8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW） 本章中的标志寄存器（以下简称为flag）是我们要学习的最有一个寄存器 flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息 8086CPU的flag寄存器的结构： 1.flag的1、3、4、12、13、14、15位共7位在8086CPU中没有使用，不具有任何含义 而0、2、4、6、7、8、9、10、11位共9位都具有特殊的含义 2.示意图 11.1 ZF标志 1.flag的第6位是ZF，零标志位。 它记录相关指令执行后， 1.结果为0，ZF=1 2.结果不为0，ZF=0 2.示例： mov ax,1 sub ax,1 指令执行后，结果为0，则ZF=1 mov ax，2 sub ax，1 指令执行后，结果不为0，则ZF=0 3.注意，在8086CPU的指令集中，有的指令的执行会影响标志寄存器 比如：add、sub、mul、div、inc、or、and等 他们大都是运算指令（逻辑运算或者算术运算） 有的指令的执行对标志寄存器没有影响， 比如：mov、push、pop等，他们大都是传送指令11.2 PF标志 flag的第2位是PF，奇偶标志位 它记录指令执行后，结果的所有二进制位中1的个数 1.为偶数，PF=1 2.为奇数，PF=011.3 SF标志 1.flag的第7位是SF，符号标志位 2.它记录指令执行后 1.结果为负。sf=1 2.结果为正，sf=0 sf标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负 sf标志把所有数当作有符号数 如果把数据当作无符号数运算，sf的值则没有意义，虽然相关指令会影响它的值 3.也就是说，CPU在执行add等指令时，是必然要影响sf标志位的值 至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算11.4 CF标志 1.flag的第0位是CF，进位标志位 一般请况下，在进行无符号数运算的时候， 它记录了运算结果的最高有效位向更高位的进位值， 或从更高位的借位值 代表假想的更高位 2.CPU在运算时，不会丢弃进位值，而是记录在一个特殊的寄存器的某一位上 8086CPU就用flag的cf为来记录这个进位值，借位也一样 3.在debug中的显示 4.无符号的时候产生的结果 11.5 OF标志 flag中的第11位 进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出 1.这里所讲的溢出，只是对有符号数运算而言 就像进位只是相对于无符号数而言！ 2.一定要注意cf和of的区别 当需要把机器码看成有符号数则使用of 当需要把机器码看成无符号数则使用cf11.6 adc标志 adc是带进位的加法指令，他利用了cf上记录的进位值 1.格式：adc 操作对象1，操作对象2 2.功能：操作对象1=操作对象1+操作对象2+cf 比如：adc ax,bx实现的功能是： (ax)=(ax)+(bx)+cf 3.执行adc指令的时候，加上的cf的值的含义，由adc指令前的指令决定 也就是说，关键在于所加上的cf值是被什么指令设置的 4.如果cf是被sub指令设置的，那么他的含义就是借位值 如果是被add指令设置的，那么它的含义就是进位值 5.下面的指令和add ax,bx具有相同的结果 add al,bl adc ah,bh CPU提供adc指令的目的，就是来进行加法的第二步运算的 adc指令和add指令相配合就可以对更大的数据进行加法运算 【实验：编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中】11.7 sbb标志 sbb是带借位减法指令，他利用了cf位上记录的借位值 1.格式：sbb 操作对象1，操作对象2 2.功能：操作对象1=操作对象1-操作对象2-cf 3.利用sbb指令，我们可以对任意大的数据进行减法运算 4.sbb和adc是基于相同的思想设计的两条指令， 在应用思路上和adc类似11.8 cmp标志 1.cmp是比较指令，功能相当于减法指令，只是不保存结果 2.cmp指令执行后，将对标志寄存器产生影响 3.其他相关指令通过识别这些被影响的标志寄存器，来得知比较结果 4.cmp指令格式：cmp 操作对象1,操作对象2 5.功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置 6.比如：cmp ax,ax 做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关位 指令执行后 zf=1 ;结果为0 pf=1 ;结果的1的个数为偶数 sf=0 ;结果为正号 cf=0 ;结果没有产生进位或借位 of=0 ;结果没有溢出 7.根据flag，判断cmp指令的结果（无符号数） 8.cmp既可以对无符号数进行比较，也可以对有符号数进行比较 cmp 操作数1,操作数2 ;操作数1、操作数2都是有符号数 1.of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负 of=0，sf=1 则 操作数1比操作数2小 of=0，sf=0 则 操作数1比操作数2大 2.of=1，说明有溢出，逻辑上真正结果的正负与实际结果的正负相反 of=1，sf=1 则 操作数1比操作数2大 of=1，sf=0 则 操作数1比操作数2小 11.9 检测比较结果的条件转移指令 1.这些条件转移指令通常和cmp相配合使用 2.因为cmp指令可以同时进行两种比较，无符号数和有符号数的比较 所以，这些转移指令也分为两种，即： 1.根据【无符号数】的比较结果进行转移的条件转移指令， 他们检测zf、cf的值 2.根据【有符号数】的比较结果进行转移的条件转移指令 他们检测sf、of和zf的值 3.无符号比较，条件转移指令小结【无符号，6个】 1.je 等于则转移 zf=1 2.jne 不等于则转移 zf=0 3.jb 低于则转移 cf=1 【b表示below】 4.jnb 不低于则转移 cf=0 5.ja 高于则转移 cf=0，zf=0【a表示above】 6.jna 不高于则转移 cf=1或zf=111.10 DF标志和串传送指令 1.flag的第10位DF，方向标志位 在串处理指令（movsb，movsw）中，控制每次操作后si、di的增减 df=0：每次操作后si，di递增 df=1：每次操作后si，di递减 2.格式：movsb 3.功能：（以字节为单位传送） 1.((es)16+(di))=((ds)16+(si)) 2.如果df=0，则：(si)=(si)+1 (di)=(di)+1 如果df=1，则：(si)=(si)-1 (di)=(di)-1 3.功能文字描述 movsb的功能是将ds:si指向的内存单元中的字节 送入es:di中，然后根据标志寄存器df位的值， 将si和di递增或递减 4.movsw 传送一个字 5.movsb和movsw都和rep配合使用 格式：rep movsb rep的作用根据cx的值，重复执行后面的串传送指令 6.cld指令和std指令 cld指令：将标志寄存器的df置为0【c:clear】 std指令：将标志寄存器的df置为1【s:set】 11.11 pushf和popf pushf：将标志寄存器的值压栈 popf：从栈中弹出数据，送入标志寄存器中 pushf和popf为直接访问标志寄存器提供了一种方法 11.12 标志寄存器在debug中的表示 第十二章 内中断**引言和简介 1.中断是CPU处理外部突发事件的一个重要技术 2.它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后 又立即返回断点，继续进行CPU原来的工作。 3.引起中断的原因【即：发出中断请求的来源叫作中断源】 4.根据中断源的不同，可以把中断分为：【软件中断】和【硬件中断】两大类 而硬件中断又可以分为【外部中断】和【内部中断】两类 12.1 内中断的产生 1.外部中断一般是指计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断。 外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。 2.内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断）所引起的中断。 内部中断是不可屏蔽的中断 3.软件中断其实并不是真正的中断，他们只是可被调用执行的一般程序， DOS的系统功能调用（int 21h）都是软件中断 4.CPU为了处理并发的中断请求，规定了中断的优先权，优先权由高到低的顺序是： 1.除法错、溢出中断、软件中断 2.不可屏蔽中断 3.可屏蔽中断 4.单步中断12.2 中断处理程序简介 1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系 使得CPU根据中断信息可以找到要执行的处理程序。 2.中断信息中包含有表示中断的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序的。 3.CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址 即中断类型码是中断向量在中断向量表中的索引12.3 中断向量表【中断向量表就是中断向量的列表】 1.中断向量表在内存中保存，其中存放着256个【2^8,8位中断类型码】中断源所对应的中断处理程序的入口 对于8086PC机，中断向量表指定放在内存地址0处 2.从0:0-0:03ffh的1024个字节【2564，物理地址使用段地址和偏移地址存放，需要4个字节】中存放着中断向量表12.4 中断过程 1.可以用中断类型码，在中断向量表中找到中断处理程序的入口 找到这个入口地址的最终目的是用它设置cs和ip，使CPU执行中断处理程序 2.用中断类型码找到中断向量，并用它设置cs和ip，这个工作时由CPU的硬件自动完成的 CPU硬件完成这个工作的过程被称为【中断过程】 3.中断过程 8086CPU的中断过程 1.（从中断信息中）取得中断类型码 2.标志寄存器的值入栈（保护标志位） 3.设置标志寄存器的第8位TF和第9位IF设置为0（后面讲解本步的目的） 4.cs内容入栈 5.ip内容入栈 6.从内存地址为中断类型码4和中断类型码4+2的两个子单元中 读取中断处理程序的入口地址设置cs和ip 4.使用汇编语言描述中断过程，如下 1.取得中断类型码N 2.pushf 3.TF=0，IF=0 4.push cs 5.push ip 6.（ip）=（N4），（cs）=（N*4+2）12.5 中断处理程序 1.由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序， 所以，中断处理程序必须一致存储在内存某段空间中 2.而中断处理程序的入口地址，即【中断向量】，必须存储在对应的中断向量表表项中 3.中断处理程序的编写方法和子程序的比较类似，下面是常规的步骤 1.保存用到的寄存器 2.处理中断 3.恢复用到的寄存器 4.用iret指令返回 **iret指令的功能用汇编语法描述为 pop ip pop cs popf iret通常和硬件自动完成的中断过程配合使用 iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序12.6 除法错误中断的处理 当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的终端信息 CPU将检测到这个信息，然后引发中断程序，转去执行0号中断对应的中断处理程序 例如： mov ax 1000h mov bh，1 div bh 此程序会产生溢出 运行之后，会显示 12.7 编程处理0号中断 现在重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to here!”的广告词，然后返回到操作系统 把中断处理程序放到安全空间中 中断程序的框架 12.8 安装 计算中断程序的长度：offset 标号1-offset 标号2 在代码段中存放数据12.9 do012.10 设置中断向量12.11 单步中断 如果检测到标志寄存器的tf位为1，则产生单步中断，引发中断过程12.12 响应中断的特殊情况 第十三章 int指令13.1 int指令 1.int格式：int n ;n为中断类型码 它的功能是引发中断过程 2.CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下 1.取中断类型码 2.标志寄存器入栈，if=0，tf=0 3.cs，ip入栈 4.从此处转去执行n号中断的中断处理过程 3.可以在程序中使用int指令调用任何一个中断的中断处理程序 可以用int指令调用这些子程序，也可以自己编写一些中断处理程序供别人使用13.2 编写供应用程序调用的中断例程 【实例1】编写、安装中断7ch的中断例程，实现求一个word型数据的平方 1.功能：求一word型数据的平方 2.参数：（ax）=要计算的数据 3.返回值：dx、ax中存放结果的高16位和低16位 4.应用举例：求2*3456^2 ;程序1：调用中断程序计算平方 code segment assume cs: code start: mov ax,3456; (ax)=3456 int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方 add ax,ax adc dx,dx ;存放结果，讲结果乘以2 mov ax,4c00h int 21h code ends end start ;程序2：编写中断程序 ;程序2中要做三部分工作 ; 1.编程实现求平方功能的程序 ; 2.安装程序，我们将其安装在0:200处 ; 3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。 code segment assume cs:code start: mov ax,cs mov ds,ax mov si,offset sqr ;设置ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov cx,offset sqrend - offset sqr ;设置cx为传输长度 cld ;设置传输方向为正 rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h ;设置中断向量地址，偏移地址 mov word ptr es:[7ch*4+2],0 ;设置中断向量地址，段地址 mov ax,4c00h int 21h sqr: mul ax iret sqrend: nop code ends end start 【实例2】编写、安装中断7ch的中断例程，实现将一个全是字母，以0结尾的字符串，转化为大写。 code segment assume cs:code start: mov ax,cs mov ds,ax mov si,offset capital mov ax,0 mov es,ax mov di,200h mov cx,offset capitalend - offset capital cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h capital: push cx push si change: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b inc si jmp short change ok: pop si pop cx iret capitalend: nop code ends end start 13.3 对int、iret和栈的深入理解 【问题】用7ch中断例程完成loop指令的功能 不要随便修改sp，可以使用bp进行间接访问13.4 BIOS和DOS所提供的中断例程13.5 BIOS和DOS中断例程的安装过程 1.开机后，CPU一加电，初始化（cs）=0ffffh，ip=0，自动从ffff:0单元开始执行程序 ffff:0处有一条跳转指令，CPU执行该指令后，转去执行bios中的硬件系统的检测和初始化程序。 2.初始化程序将建立bios所支持的中断向量，即将bios提供的中断例程的入口地址登记在中断向量表中。 3.硬件系统检测和初始化完成后，调用19h进行操作系统的引导。从此将计算机交由操作系统控制。 4.DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量13.6 BIOS中断例程的应用 1.int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序 一般来说，一个供程序员调用的中断例程中，往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序 2.bios和dos提供的中断例程，都用ah来传递内部子程序的编号13.7 DOS中断例程应用 int 21h中断例程是dos提供的中断例程，其中包含了dos提供给程序员造编程时调用的子程序 【实验13】 **介绍一本汇编语言的书《The Art of Assembly Language》 第十四章 端口CPU可以直接读写3个地方的数据 1.CPU内部的寄存器 2.内存单元 3.端口 14.1 端口的读写 1.对端口的读写不能用mov、push、pop等内存读写指令 端口的读写指令只有两条：【in】和【out】分别用于从端口读取数据和往端口写入数据 2.CPU执行内存访问指令和端口访问指令时，总线上的信息： 1.访问内存 mov ax,ds:[8]; 假设执行前（ds）=0 执行时，与总线相关的操作： 1.CPU通过地址线将地址信息8发出 2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 3.存储器将8号单元中的数据通过数据线送入CPU 2.访问端口 这里的【端口】是对硬件开放的端口 in al,60h; 从60h号端口读入一个字节 执行时与总线相关的操作 1.CPU通过地址线将地址信息60h发出 2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据 3.端口所在的芯片将60h端口中的数据通过数据线送入CPU 注意：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据 访问8位端口时用al，访问16位端口时用ax 3.对0-255以内的端口进行读写 in al,20h ;从20h端口读一个字节 out 20h,al ;往20h端口写一个字节 4.对256-65535的端口进行读写时，端口号放在【dx】中 mov dx,3f8h ;将端口号3f8送入dx in al,dx ;从3f8h端口读一个字节 out dx,al ;从3f8h端口写一个字节14.2 CMOS RAM芯片 1.PC机中有一个CMOS RAM芯片，其有如下特征 1.包含一个实时钟和一个有128个存储单元的RAM存储器。（早期的计算机为64字节） 2.该芯片靠电池供电。因此，关机后其内部的实时钟仍可以正常工作，RAM中的信息不丢失 3.128字节的RAM中，内部实时钟占用0-0dh单元来保存时间信息，其余大部分分单元用于 保存系统配置信息，供系统启动时bios程序读取 bios也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息 补充：BIOS BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。 在IBM PC兼容系统上，是一种业界标准的固件接口。BIOS这个字眼是在1975年第一次由CP/M操作系统中出现。 BIOS是个人电脑启动时加载的第一个软件 4.该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS RAM。 5.70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据 或要写入到其中的数据 2.比如：读CMOS RAM的2号单元： 1.将2送入端口70h 2.从71h读取2号单元的内容 14.3 shl和shr指令 shl和shr是逻辑移位指令，后面的课程中我们要用到移位指令 1.shl逻辑左移指令，功能为： 1.将一个寄存器或内存单元中的数据向左移位 2.将最后移出的移位写入cf中 3.最低位用0补充 例如有如下指令： mov al,01001000b shl al,1 ;将al中的数据左移一位 执行后(al)=100100000b，cf=0. 如果移动位数大于1时，必须将移动位数放在cl中 2.shr逻辑右移指令，与shl刚好相反14.4 CMOS RAM中存储的时间信息 在CMOS RAM中存放着当前时间 秒：00h 分：02h 时：04h 日：07h 月：08h 年：09h 这6个信息的长度都为1个字节 这些数据以BCD码的方式存放，一个字节可以表示两个BCD码 CMOS RAM存储时间信息的单元中存储了用两个BCD码表示的两个十进制数 高4位的BCD码表示十位，低四位的BCD码表示个位 【编程】：在屏幕中间显示当前的月份 1.CMOS RAM芯片回顾： 1.70h为地址端口，存放要访问的CMOS RAM单元的地址 2.71h为数据端口，存放从选定的CMOS RAM单元中【读取】的数据，或【写入】其中的数据 2.分析 这个程序主要做两部分工作 1.从CMOS RAM的8号单元读取当前月份的BCD码 要读取CMOS RAM的信息，我们首先要向地址端口70h写入要访问的单元的地址 mov al,8 out 70h,al 然后从数据端口71h中取得指定单元中的数据 in al,71h 2.将用BCD码表示的月份以十进制的形式显示到屏幕上 ;编程：在屏幕中间显示当前的月份 code segment assume cs:code start: mov al,8 out 70h,al in al,71h mov ah,al mov cl,4 shr ah,cl and al,00001111b add ah,30h add al,30h mov bx,0b800h ;显存 mov es,bx mov byte ptr es:[160*12+40*2],ah ;显示月份的十位数码 mov byte ptr es:[160*12+40*2+2],al ;显示月份的个位数码 mov ax,4c00h int 21h code ends end start 【实验十四】编程：以“年/月/日 时:分:秒”的格式，显示当前日期和时间 第十五章 外中断**CPU除了有运算能力，还有I/O能力 15.1 接口芯片和端口 1.在PC系统的接口卡和主板上，装有各种接口芯片，这些外设接口芯片的内部装有若干寄存器 CPU将这些寄存器当做【端口】访问 2.外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的【端口】中 3.CPU向外设的输出也是要先送入【端口】中，再由相关芯片送入到外设 4.CPU可以向外设输出控制命令，这些控制命令也是先送到【端口】中，然后相关芯片根据命令进行相关工作 5.可见：CPU与外部设备的交流是通过【端口】进行的 CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入15.2 外中断信息 1.在PC系统中，外中断源一共有两类 1.可屏蔽中断 2.不可屏蔽中断 2.可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断 要看标志寄存器的IF位的设置 当CPU检测到可屏蔽中断信息时： 1.若IF=1，则CPU在执行完当前指令后相应中断，引发中断过程 2.若IF=0，则不响应可屏蔽中断 3.可屏蔽中断所引发的中断过程，除在第一步的实现上与内中断有所不同外，基本上和内中断的中断过程相同 4.因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的 而内中断的中断码是在CPU内部产生的 5.IF设置为0的原因：在进入中断处理程序后，禁止其他的可屏蔽中断 当然，如果中断处理程序中需要处理可屏蔽中断，可以用指令将IF设置为1 6.8086CPU提供的设置IF的指令如下： sti ;用于设置IF=1 cli ;用于设置IF=0 7.不可屏蔽中断是CPU必须相应的外中断。 当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后 立即响应，应发中断过程 8.8086CPU不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码 9.不可屏蔽中断的中断过程 1.标志寄存器入栈，IF=0，TF=0 2.CS，IP入栈 3.（IP）=（8），（CS）=（0AH） ;固定地址 10.几乎所有外中断，都是可屏蔽中断。当外设有需要处理的事件发生时 相关芯片向CPU发出可屏蔽中断信息。 不可屏蔽中断是系统中有必须处理的紧急情况发生时用来通知CPU的中断信息，本门课程中，主要讨论可屏蔽中断 15.3 PC机键盘的处理过程 1.下面看一个键盘输入的处理过程，并以此来体会PC机处理外设输入的基本方法 1.键盘输入 2.引发9号中断 3.执行int 9中断例程 2.PC机键盘的处理过程 1.键盘上每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一触键的开关状态进行扫描。 2.按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明按下的键在键盘上的位置 扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H 3.松开控下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时 产生的扫描码也被送入60H端口中。 一般按下一个键时，产生的扫描码称为通码，松开一个键产生的扫描码称为断码 扫描码长度为一个字节，通码的第七位为0，断码的第七位为1 即：断码=通码+80H **BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要的工作如下： 1.读出60H端口中的扫描码 2.如果是字符键的扫描码，将该扫描码对应的字符码（即：ASCII码）送入内存中的BIOS键盘缓冲区 3，如果是控制键和切换键的扫描码，则将其转变为状态字节，写入内存中存储状态字节的单元 4.键盘的输入到达60H端口时，相关的芯片会向CPU发出中断类型码为9的可屏蔽中断信息。 5.CPU检测到中断信息后，如果IF=1，则相应中断，同时将IF设置为0（不让其他可屏蔽中断进行干扰），引发中断过程，转去执行int9中断例程 3.BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接受的键盘输入的内存区 4.该内存区可以存储15个键盘输入，int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码， 所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高字节存放扫描码，低字节存放字符码 5.0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下： 15.4 编写int9中断例程,并安装 梳理键盘输入的处理过程 1.键盘产生扫描码 2.扫描码送入60H端口 3.一旦侦测到60H端口有动静，引发9号中断 4.CPU执行int9中断例程处理输入 以上的过程，前三步都由硬件系统自动完成，能够修改的只有第四步，修改int9中断程序 【任务演示】在屏幕中依次显示“a”~“z”并可以让人看清。在显示过程中，按下Esc键后，该表显示的颜色 ;程序1：实现连续显示“a”~“z” ;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。 ;部分功能代码： stack segment db 128 dup (0) stack ends code segment assume cs:code start: mov ax,stack mov ss,ax mov sp,128 mov ax,0b800h mov es,ax mov ah,&#39;a&#39; s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,&#39;z&#39; jna s mov ax,4c00h int 21h delay: push ax push dx mov dx,0010h ;循环10000000h次 mov ax,0 s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret code ends end start ;程序2：实现改变颜色 ;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#39;Esc&#39;键后，改变显示的颜色。 stack segment db 128 dup (0) stack ends data segment dw 0,0 data ends code segment assume cs:code start: mov ax,stack mov ss,ax mov sp,128 mov ax,data mov ds,ax mov ax,0 mov es,ax push es:[9*4] pop ds:[0] push es:[9*4+2] pop ds:[2] ;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中 mov word ptr es:[9*4],offset int9 mov es:[9*4+2],cs ;在中断向量表中设置新的int 9中断例程的入口地址 mov ax,0b800h mov es,ax mov ah,&#39;a&#39; s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,&#39;z&#39; jna s mov ax,0 mov es,ax push ds:[0] pop es:[9*4] push ds;[2] pop es;[9*4+2] ;将中断向量表中int 9中断例程的入口恢复为原来的地址 mov ax,4c00h int 21h delay: push ax push dx mov dx,0010h mov ax,0 s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret ;------以下为新的int 9中断例程-------------------- ;int9中断例程是在进行键盘输入之后，由系统自动调用 int9: push ax push bx push es in al,60h pushf pushf pop bx and bh,11111100b push bx popf call dword ptr ds:[0] ;对int指令进行模拟，调用原来的int 9中断例程 cmp al,1 jne int9ret mov ax,0b800h mov es,ax inc byte ptr es:[160*12+40*2+1] ;属性增加1，改变颜色 int9ret: pop es pop bx pop ax iret code ends end start 第十六章 直接定址表16.1 描述了单元长度的标号 1.本章讨论如何有效合理地组织数据，以及相关的编程技术 1.前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址 2.还可以使用一种标号，这种标号不但可以表示内存单元的地址，还表示了内存单元的长度 即：表示在此标号处的单元，是一个字节单元，还是字单元还是双字单元 2.例如 1.标号1 a : db 1,2,3,4,5,6,7,8 b : dw 0 此种标号只能标记地址 此种加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用 2.标号2 a db 1,2,3,4,5,6,7,8 ;标号a，描述了地址code:0,和从这个地址开始，以后的内存单元都是字节单元 b dw 0 ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元 此种标号既可以标记地址，也可以表示此标号处的单元 3.使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据 这种标号此后称为数据标号，它标记了存储数据的单元的地址和长度 4.数据标号的用法 指令：mov ax,b ;相当于：mov ax,cs:[8] 指令：mov b,2 ;相当于：mov word ptr cs:[8],2 指令：inc b ;相当于：inc word ptr cs:[8] 指令：mov al,a [si] ;相当于：mov al,cs:0[si] 指令：mov al,a[3] ;相当于：mov al,cs:0[3] 指令：mov al,a[bx+si+3] ;相当于：mov al,cs:0[bx+si+3]16.2 在其他段中使用数据标号 1.注意，如果想在代码段中，直接用数据标号访问数据， 则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来。 否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。 2. 当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要， 用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。 3.我们可以将数据标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。 1.把数据标号当做数据来定义时，使用【dw】定义数据 比如： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw a,b ;数据标号c处存储的两个字型数据为标号a、b 的偏移地址。 data ends 数据标号c处存储的两个字型数据为标号a、b 的偏移地址。 相当于： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a, offset b data ends 2.把数据标号当做数据来定义时，使用【dd】定义数据 再比如： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dd a,b ;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。 data ends 数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。 相当于： data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a, seg a, offset b, seg b ;seg操作符，功能为取得某一标号的段地址。 data ends seg操作符，功能为取得某一标号的段地址。 16.3 直接定址表 本节课，我们将使用“查表”的方法，编写相关程序的技巧 【任务】编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据 code segment assume cs:code start: mov al,0eh ;al中存放了byte型数据 call showbyte mov ax,4c00h int 21h ;子程序： ;用al传送要显示的数据 showbyte: jmp short show table db &#39;0123456789ABCDEF&#39; ;字符表 show: push bx ;保护现场 push es mov ah,al shr ah,1 shr ah,1 shr ah,1 shr ah,1 ;右移4位，ah中得到高4位的值 and al,00001111b ;al中为低4位的值 mov bl,ah mov bh,0 mov ah,table[bx] ;用高4位的值作为相对于table的偏移，取得对应的字符 mov bx,0b800h mov es,bx mov es:[160*12+40*2],ah mov bl,al mov bh,0 mov al,table[bx] ;用低4位的值作为相对于table的偏移，取得对应的字符 mov es:[160*12+40*2+2],al pop es pop bx ret code ends end start 16.4 程序入口地址的直接定址表 【编程】实现一个子程序setscreen，为显示输出提供如下功能： 1.清屏 2.设置前景色 3.设置背景色 4.向上滚动一行 1.入口参数说明： 1.用ah寄存器传递功能号 0：清屏；1：设置前景色；2：设置背景色；3：向上滚动一行 2.对于2、3号功能，用al传递颜色值 al∈{0，1，2，3，4，5，6，7} 2.各种功能如何实现 1.清屏： 将显存中当前屏幕中的字符设为空格符； 2.设置前景色： 设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位； 012位存放前景色 3.设置背景色： 设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位； 456位存放背景色 4.向上滚动一行： 依次将第 n+1行的内容复制到第n行处：最后一行为空。 ;功能子程序1：清屏 sub1: push bx ;保护现场,调用子程序的时候，注意要保护现场，运行子程序的时候，可能会修改一些寄存器的值 push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 sub1s: mov byte ptr es:[bx],&#39; &#39; ;循坏2000次 add bx,2 loop sub1s pop es ;恢复现场 pop cx pop bx ret ;功能子程序2：设置前景 sub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: and byte ptr es:[bx],11111000b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;功能子程序3：设置背景色 sub3: push bx push cx push es mov cl,4 shl al,cl mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: and byte ptr es:[bx],10001111b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;功能子程序4：向上滚动一行 sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160 ;ds:si指向第n+1行，第1行 mov di,0 ;es:di指向第n行，第0行 cld mov cx,24;共复制24行 sub4s: push cx mov cx,160 rep movsb ;复制 pop cx loop sub4s mov cx,80 mov si,0 sub4s1: mov byte ptr es:[160*24+si],&#39; &#39; ;最后一行清空 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret ;sub4 ends 3.可以将这些功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应 ;编程：实现一个子程序setscreen，为显示输出提供如下功能： ;(1) 清屏。 ;(2) 设置前景色。 ;(3) 设置背景色。 ;(4) 向上滚动一行。 ; ;入口参数说明： ;(1) 用 ah 寄存器传递功能号：0 表示清屏，1表示设置前景色，2 表示设置背景色，3 表示向上滚动一行； ;(2) 对于2、3号功能，用 al 传送颜色值，(al) ∈{0,1,2,3,4,5,6,7} setscreen: jmp short set table dw sub1,sub2,sub3,sub4 set: push bx cmp ah,3 ;判断传递的是否大于 3 ja sret mov bl,ah mov bh,0 add bx,bx ;根据ah中的功能号计算对应子程序的地址在table表中的偏移 call word ptr table[bx] ;调用对应的功能子程序，学会本句代码，是本章节的【精髓】 sret: pop bx iret ;功能子程序1：清屏 sub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000 sub1s: mov byte ptr es:[bx],&#39; &#39; add bx,2 loop sub1s pop es pop cx pop bx ret ;sub1 ends ;功能子程序2：设置前景色 sub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub2s: and byte ptr es:[bx],11111000b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ;sub2 ends ;功能子程序3：设置背景色 sub3: push bx push cx push es mov cl,4 shl al,cl mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 sub3s: and byte ptr es:[bx],10001111b or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx ret ; sub3 ends ;功能子程序4：向上滚动一行 sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160 ;ds:si指向第n+1行 mov di,0 ;es:di指向第n行 cld mov cx,24;共复制24行 sub4s: push cx mov cx,160 rep movsb ;复制 pop cx loop sub4s mov cx,80 mov si,0 sub4s1: mov byte ptr es:[160*24+si],&#39; &#39; ;最后一行清空 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret ;sub4 ends 第十七章 使用BIOS进入键盘输入和磁盘读写**引言 1.大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。 2.程序和数据通常需要长期存储，磁盘是最常用的存储设备。 3.BIOS 为这两种外设的I/O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。 17.1 int9中断例程对键盘输入的处理 CPU 在9 号中断发生后，执行int 9中断例程，从60h 端口读出扫描码， 并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。 17.2 使用int16h中断例程读取键盘缓冲区 1.BIOS提供了int 16h 中断例程供程序员调用。 2.int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。 3.下面的指令从键盘缓冲区（缓冲区的最低位）中读取一个键盘输入，并且将其从缓冲区中删除： mov ah,0 int 16h 结果：(ah)=扫描码，(al)=ASCII码。 4.int 16h 中断例程的 0 号功能，进行如下的工作： （1）检测键盘缓冲区中是否有数据； （2）没有则继续做第1 步；（缓冲区随时有可能输入数据） （3）读取缓冲区第一个字单元中的键盘输入； （4）将读取的扫描码送入ah，ASCII 码送入al； （5）将己读取的键盘输入从缓冲区中删除。 5.可见，B1OS 的int 9 中断例程和int 16h 中断例程是一对相互配合的程序， int 9 中断例程向键盘缓冲区中写入， int 16h 中断例程从缓冲区中读出。 它们写入和读出的时机不同，int 9 中断例程在有键按下的时候向键盘缓冲区中写入数据； 而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。 【编程】接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， 将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。 ;编程： ;接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， ;将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。 ;A、B、C处的程序指令比较有技巧，请读者自行分析 code segment assume cs:code start: mov ah,0 int 16h ;int 16h 0号功能实现从键盘缓冲区读取一个键盘输入 mov ah,1 ;A cmp al,&#39;r&#39; je red cmp al,&#39;g&#39; je green cmp al,&#39;b&#39; je blue jmp short sret red: shl ah,1 ;B green: shl ah,1 ;C blue: mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 s: and byte ptr es:[bx],11111000b ;设置颜色 or es:[bx],ah ;设置颜色 add bx,2 loop s sret: mov ax,4c00h int 21h code ends end start 17.3 字符串的输入 int 21h的0a号功能可以实现字符串的输入 也可以用int 16h，通过显示键盘缓冲区中的内容，实现字符串的显示 1.使用int 16h显示字符串程序的处理过程如下 ① 调用int 16h读取键盘输入； ② 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行① ； ③ 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行① ； ④ 如果是Enter 键，向字符栈中压入0，返回。 2.子程序：字符栈的入栈、出栈和显示 参数说明 (ah)=功能号，0表示入栈，1表示出栈，2表示显示； ds : si 指向字符栈空间； 对于0 号功能：(al)=入栈字符； 对于1 号功能：(al)=返回的字符； 对于2 号功能：(dh)、(dl) =字符串在屏幕上显示的行、列位置。 ;使用int 16h显示字符串的子程序：字符栈 ;最基本的字符串输入程序，需要具备下面的功能： ;（1） 在输入的同时需要显示这个字符串； ;（2）一般在输入回车符后，字符串输入结束； ;（3）能够删除已经输入的字符。 ;编写一个接收字符串的输入子程序，实现上面三个基本功能。 ;因为在输入的过程中需要显示，子程序的参数如下： ; (dh)、(dl)=字符串在屏幕上显示的行、列位置； ; ds:si 指向字符串的存储空间，字符串以O 为结尾符。 ;功能子程序实现 charstack: jmp short charstart table dw charpush,charpop,charshow top dw 0 ;栈顶 charstart: push bx push dx push di push es cmp ah,2 ja sret mov bl,ah mov bh,0 add bx,bx jmp word ptr table[bx] ;使用直接定址表 charpush: mov bx,top mov [si][bx],al inc top jmp sret charpop: cmp top,0 je sret dec top mov bx,top mov al,[si][bx] jmp sret charshow: mov bx,0b800h mov es,bx mov al,160 mov ah,0 mul dh mov di,ax add dl,dl mov dh,0 add di,dx mov bx,0 charshows: cmp bx,top jne noempty mov byte ptr es:[di],&#39; &#39; jmp sret noempty: mov al,[si][bx] mov es:[di],al mov byte ptr es:[di+2],&#39; &#39; inc bx add di,2 jmp charshows sret: pop es pop di pop dx pop bx ret 17.4 应用int13h中断例程对键盘进行读写 1.磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。 2.注意，我们只能以扇区为单位对磁盘进行读写。 在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。 3.BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。 4.我们可以通过调用BIOS中断例程来访问磁盘。 BIOS 提供的访问磁盘的中断例程为int 13h 。 如下，读取0面0道1扇区的内容到0:200： 返回参数： 操作成功：（ah）=0，（al）=读入的扇区数 操作失败：（ah）=出错代码 将0:200中的内容写入0面0道1扇区示例 返回参数： 操作成功： (ah)=0，(al)=写入的扇区数 操作失败： (ah)=出错代码 5.注意：使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的， 很可能覆盖掉重要的数据。 【编程】将当前屏幕的内容保存在磁盘上 分析：1 屏的内容占4000个字节，需要8 个扇区（一个扇区512B），我们用0面0道的1~8扇区存储显存中的内容。 code segment assume cs:code start: mov ax,0b800h mov es,ax mov bx,0 ;es:bx 指向将写入磁盘的数据的内存区 mov al,8 ;写入的扇区数 mov ch,0 ;磁道号，从0开始 mov cl,1 ;扇区号 从1开始 mov dl,0 ;驱动器号0:软驱A, 1:软驱B,硬盘从80h开始， 80h:硬盘C，81h:硬盘D mov dh,0 ;磁头号，（对于软盘即面号，因为一个面用一个磁头来读写） mov ah,3 ;传递 int 13h 写入数据的功能号 int 13h ;返回参数 ;操作成功:(ah) = 0,(al) = 写入的扇区数 ;操作失败:(ah) = 出错代码 return: mov ax,4c00h int 21h code ends end start 【实验17和课程设计2】 课程设计1在第十章 综合研究研究试验1 搭建一个精简的C语言开发环境 研究试验2 使用寄存器 研究试验3 使用内存空间 研究试验4 不用main函数编程 研究试验5 函数如何接受不定数量的参数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"大学所学","slug":"大学所学","permalink":"/tags/大学所学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"全排列问题","slug":"全排列问题","date":"2021-03-12T09:30:00.000Z","updated":"2022-06-14T11:20:51.016Z","comments":true,"path":"undefined/全排列问题/","link":"","permalink":"/undefined/全排列问题/","excerpt":"","text":"全排列问题问题定义：给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [[1,2,3], [1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 问题分析：人脑建模过程（类似“走迷宫”，试一步走一步，当前的路走不通就返回上一个路口）： 先取原数组的第一个数，把它“固定”在一个temp数组的首位，比如：[1，num，num] 再取出原数组的第二个数，把它“固定”在temp数组的第二位，比如：[1，2，num] 再取出原数组的第三个数，把它“固定”在temp数组的第三位，比如：[1，2，3] 此时我们得到了第一个排列 接着我们会想，如果在第二步中，取出的是第三个数，也就是[1，3，num]，那么显然就有[1，3，2] 再接着我们又会往前想，如果我们在第一步取的是第二个数，然后进行后续的操作。同样的如果第一步是是第三个数呢？ 由图可知，我们每次不重复地从arr中取出一个数进行“固定”，每一次的“固定”都会影响下一次的“固定”的选择。通俗地讲，就是高中学过的排列组合里面的排列，第一次可以有三种选择，第二次有两种选择，第三次只有一种选择。 问题解决：话不多说，先上代码： import java.util.Arrays; public class fullPermutation { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] temp = new int[arr.length]; boolean isVisit[] = new boolean[arr.length]; perm(arr, 0, temp, isVisit); } /** * * @param arr 需要进行全排列的数 * @param index 指向“固定”的位置的指针，值为0时，指向第一个固定位置，也就是temp[0] * @param temp 临时数组，用于存放被“固定”的数 * @param isVisit 用来标记该数是否已经被选择“固定” */ public static void perm(int[] arr, int index, int[] temp, boolean[] isVisit) { if (index==arr.length) {//结束递归条件 System.out.println(Arrays.toString(temp)); return; } for (int i = 0; i &lt; arr.length; i++) {//遍历数组的每个数 if (!isVisit[i]) {//判断数是否被使用，如果未使用则继续后面的操作 temp[index] = arr[i];//将该数插入temp数组 isVisit[i]=true;//将该数标记为已使用 perm(arr, index + 1, temp, isVisit);//开始递归，插入下一个数 isVisit[i] = false;//执行到这一步的时候，说明有一个排列已经打印出来了，这时从后往前将每个数重置为未访问使用 } } } } 人脑在“固定”数时能避开选择重复数，但是计算机本身是不能避开的。那么如何解决这个问题呢？很简单，我们可以给每个数arr[i]“贴上”一个名叫isVisit[i]的布尔值。如果第一次选择到的数，isVisit[i]会被赋值为true，表示该数已被访问使用，再加上一个if（! isVisit[i]）判断，所以在下一次再选择到这个数的时候就会跳过选择【见line 24】 我们可以通过一个index指针来指向“固定（插入）”的位置 用一个temp数组来储存所有全排列的数 for循环遍历所有数组，如果当前数arr[i]对应的isVisit[i]=true，则跳过继续for循环，直到某个数对应的isVisit值为false，将其插入temp 然后开始递归，再回溯，回溯的时候将末尾数的isVisit赋值为false 当index等于temp数组长度时打印temp并return 问题结果：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"复习堆排序","slug":"复习堆排序","date":"2021-03-10T02:00:00.000Z","updated":"2022-06-14T11:23:19.135Z","comments":true,"path":"undefined/复习堆排序/","link":"","permalink":"/undefined/复习堆排序/","excerpt":"","text":"复习堆排序堆的定义：堆是一个具有以下性质的二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称之为大顶堆。反之称之为小顶堆。 那么，在代码中如何表示大小顶堆？arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2]//大顶堆 arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2]//小顶堆 堆排序の思想 先把待排序序列构建成一个大（小）顶堆 这时，整个序列的最大值就是堆顶的根节点（也就是数组的第一个元素） 将其与末尾元素进行交换，此时末尾就是最大值 然后将剩余的n-1个元素重新构造成一个新的堆，这样就得到n-1个元素的次小值，如此反复，就能得到一个有序序列——[重复（1），（2），（3）步骤] 代码实现：import java.util.Arrays; public class heapSort { public static void main(String[] args){ int[] arr={25, 30, 11, 7, 22, 16, 18, 33, 40, 55}; int temp=0; for(int i=arr.length/2-1;i&gt;=0;i--){//从左往右，从下往上寻找非叶子节点进行初始的堆排序 adjustHeap(arr,i, arr.length); } for(int j=arr.length-1;j&gt;=0;j--){//初始堆建成后，首尾的元素进行交换，此时大顶堆的结构被破坏 temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j);//因为是首尾交换所以只有最顶部的结点不符合顶堆的定义，中间的非叶子节点均符合堆顶义，所此时的i等于0，也就是只从顶部开始调整 } System.out.println(&quot;排序后的数组为：&quot;+Arrays.toString(arr)); } /** * * @param arr 待排序数组 * @param i 以i为父节点进行堆排序的树（数组） * @param length 数组长度 */ public static void adjustHeap(int[] arr,int i,int length){ int temp=arr[i]; for(int k=2*i+1;k&lt;length;k=2*k+1){//k指向i的较大的一个子结点 if((k+1&lt;length)&amp;&amp;arr[k]&lt;arr[k+1]){//判断i叶子结点的左右结点的大小，如果左边的小于右边的，则k++ k++; } if(arr[k]&gt;temp){//如果该子结点大于它的父结点，则将该子结点赋值给父节点 arr[i]=arr[k]; i=k;//以k为父节点继续和它的子节点比较 } } arr[i]=temp;//将最开始保存的arr[i]放到末尾 } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机组成原理与汇编语言(持续更新...)","slug":"计算机组成原理与汇编语言","date":"2021-03-05T07:00:00.000Z","updated":"2022-06-14T11:43:42.764Z","comments":true,"path":"undefined/计算机组成原理与汇编语言/","link":"","permalink":"/undefined/计算机组成原理与汇编语言/","excerpt":"","text":"计算机组成原理与汇编语言note①相关概念机器数：数字在计算机中的二进制表达形式，在二进制的最高位存放正或负符号，正数为0，负数为1 真值：带符号位的机器数对应的真正的数值 原码：符号位加上真值的绝对值 反码：正数の反码还是本身，而负数的反码：符号位不变，其余位按位取反 补码：反码+1 那么，为什么要引入反码和补码？ 人脑计算：我们会自动将符号位分开并进行计算 电脑（计算机）计算：因为符号位也是0,1表示，在做计算时，计算机无法辨别哪些是符号位哪些是数值位。如果硬要让计算机认识的话也不是不行，但是这会使计算机的基础电路设计变得异常复杂（这是要累死设计计算机的人- -） 所以我们希望符号位也能参与到运算当中。另外我们都知道CPU只有加法器而没有减法器，这是为什么呢？我们小学就知道，减法是加法的逆运算（减去一个数等于加上那个数的负数），因此只要解决计算机的加法问题就好啦 At First…原码君出来了，但是在运算中很快就发现了问题，比如一个正数和一个负数相加，就会出问题。比如1-1 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [1000_0010]原 = -2 And…出现了原码君的儿子反码君，值得高兴的是，反码能够使得计算结果的真值正确，但是唯独在0这个值上栽了跟头 1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原= [0000_0001]反 + [1111_1110]反 = [1111_1111]反 = [1000_0000]原 = -0 0已经能用[0000_0000]原 表示了，现在又整出一个[1000_0000]，没有意义啊这 Finally!原码君的孙子aka反码君的孙子——补码君诞生了，他很完美地解决了这个问题： 1-1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [0000_0001]补 + [1111_1111]补 = [0000_0000]补 =[0000_0000]原 = 0 Besides…除此之外，还可以用 [1000_0000]补 表示-128： (-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补 -1-127的结果应该是-128，在用补码运算的结果中， [1000_0000]补 就代表-128。 注意，-128并没有原码和反码表示。 使用补码不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数，这就是为什么8位二进制使用原码或反码表示的范围为 [-127, +127]，而使用补码表示的范围为 [-128, 127] 的原因。 因为机器使用补码，所以对于编程中常用到的32位int类型可以表示范围是 [-2^31, 2^31-1] ，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。 note②","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"大学所学","slug":"大学所学","permalink":"/tags/大学所学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"算法分析与设计(持续更新...)","slug":"算法分析与设计","date":"2021-03-03T01:00:00.000Z","updated":"2022-06-14T11:42:40.178Z","comments":true,"path":"undefined/算法分析与设计/","link":"","permalink":"/undefined/算法分析与设计/","excerpt":"","text":"算法分析与设计 chapter①：算法引论定义：解决某种问题的方法 特征：输入，输出，确定性（指令清晰无歧义），有限性（指令执行次数有限） 算法复杂性の分析 时间复杂性：T=T(N[问题规模],I[算法的输入],A[算法本身]) 空间复杂性 ：S=S(N,I) 渐进时间复杂性＝时间复杂度 大O表示法（算法时间运行时间的上界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≤C(g(n))，则称f(n)=O(g(n))，也称f(n)的阶不高于g(n)的阶 大Ω表示法（算法时间运行时间的下界） 设f(n)和g(n)是定义在正整数集上的正函数，若有正常数C和自然数n0。使得当n≥n0时，有f(n)≥C(g(n))，则称f(n)=Ω(g(n))，也称f(n)的阶不低于g(n)的阶 θ表示法（算法时间运行时间的准确界） C1(g1(n))≤f(n)≤C2(g2(n)) chapter②：递归与分治策略神魔是递归？) 还是…… 从上面的两张图我们可以看出，递归就是自己调用自己的过程。在算法中就是算法自己调用自己，这就是递归算法 很容易知道函数中自身调用自己就成为递归函数 分治（divide&amp;conquer）是乜嘢？凡治众如治寡，分数是也。分治分治，分而治之。大白话就是说把一个规模很大的问题分解成一个个规模较小的子问题，逐个求解，然后子问题的解再“治理”成大问题的最终解 如何使用分治法解决问题？ 解决小规模的问题 分解问题（divide） 递归求解子问题 将所有子问题的解合并为主问题的解 分治?=递归分治是解决问题的一种思想，递归是解决问题的一种方法，也就是说用分治法解决问题的具体实现形式大多是采用递归的方法 有关递归的经典算法实例：汉诺塔问题（略） 整数划分问题问题定义：一个非负正整数都能拆分成若干个数之和或者恰好为自身，比如6这个整数。可以被划分为 6 5+1 4+2 4+1+1 3+3 3+2+1 3+1+1+1 2+2+2 2+2+1+1 2+1+1+1+1 1+1+1+1+1+1 一共有11种划分。并且我们注意到最大的加数是它本身。所以这称为6的划分。如果我们想要得到最大加数≯m的划分个数。比如我们想要最大加数≯5的划分个数，通过上面的表格可以很容易地知道个数是9个，我们用一个函数来表示这个关系f(n,m) 我们很容易知道当n=1时，也就是——————f(1,m)，因为1的划分只能是1，什么你说1+0+0+0+0…不行么，我劝你还是关闭网页吧（bushi） m=1时，——————f(n,1)，也就是说n=(1+1+…+1)[n个1] 当n=m时，从上面的表格可以知道，f(n,n)=1+f(n,n-1)，”1“指的是加数是整数本身时的划分个数，而f(n,n-1)则指的是不包括整数本身的划分个数 当n&gt;m&gt;1时，f(n,m)： 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1); 当划分中包含m时，{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m。此时的划分个数其实就是n-m的划分个数，也就是f(n-m,m) 所以f(n,m)=f(n,m-1)+f(n-m,m)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机网络(持续更新...)","slug":"计算机网络","date":"2021-03-03T00:00:00.000Z","updated":"2022-06-14T11:44:31.377Z","comments":true,"path":"undefined/计算机网络/","link":"","permalink":"/undefined/计算机网络/","excerpt":"","text":"计算机网络注：按照课时进度整理 Part①网络的分类 电信网络：向客户提供电话，电报以及传真等服务 有线电视网络：向用户传送各类电视节目 计算机网络：能允许用户能够在计算机之间传送数据文件 思考：internet和Internet有何区别？ internet指的是互连网，它泛指有多个计算机网络互相连而成的计算机网络（网络的网络）。在这些网络之间的通信协议可以任意选择，不一定非要TCP/IP协议 Internet则是我们经常谈到的互联网（因特网），它是由当前全球最大的、开放的、由众多网络互相连接而成的互连网，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。PS：现在的互联网具有三级结构，即主干网、地区网、校园网（企业网） 相关名词：ISP（Internet Service Provider）：互联网服务提供者，也就是提供IP地址，比如我国的三大通信巨头：“移”不动、“联”不通、“信”不过，根据覆盖面积大小和IP数量的不同，ISP又分为：主干ISP、地区ISP、本地ISP 互联网的组成：边缘部分：连接在互联网的所有的端系统（手机端、电脑端、网络摄像头……），通过C/S方式和P2P方式进行通信 核心部分：路由器使用分组交换向边缘部分的端系统提供连通性 啥是分组交换？在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。 分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。 分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。 分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。 Part②计算机网络的分类 按照作用范围分类 广域网（远程网）WAN（Wide Area Network） 城域网MAN（Metropolitan Area Network） 局域网LAN（Local Area Network） 个人局域网PAN（Personal Area Network） 按照网络的使用者分类 公用网（public network） 专用网（private network） 用来把用户接入到互联网的网络 接入网AN（Access Network） 计算机网络的性能七dark指标 1、速率 计算机发送出的信号都是数字形式的。比特（bit）来源于binary digit，意思是一个”二进制数字“，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率。速率的单位是bit/s（比特每秒）（或b/s，有时也写作bps，即bit per second）。 当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的速率。 2、带宽 ”带宽“有以下两种不同的意义： （1）带宽本来指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫兹（或千赫、兆赫、吉赫等），在过去很长的一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号）。因此表示某信道允许通过的信号频带范围就称为该信道的带宽。 3、吞吐量 吞吐量表示在单位时间内通过某个网络的实际数据量。 4、时延 时延是指数据从网络的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或者迟延。 网络中的时延是由一下几个不同的部分组成的： （1）发送时延 发送时延是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做传输时延。发送时延的计算公式是： 发送时延=数据帧长度（bit）/发送速率（bit/s） （2）传播时延 传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是： 传播时延=信道长度（m）/电磁波在信道上大的传播速率（m/s） 电磁波在自由空间的传播速率是光速。即3.0*10^5km/s。 发送时延发生在机器内部的发送器中，与传输信道的长度没有任何关系。传播时延发生在机器外部的传输信道媒体上，而与信道的发送速率无关。信号传送的距离越远，传播时延就越大。 （3）处理时延 主机或路由器在收到分组时需要花费一定时间进行处理，例如分析分组的首部，从分组中提取数据部分、进行差错检验或查找合适的路由等，这就产生了处理时延。 （4）排队时延 分组在进行网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待，在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延无穷大。 这样数据在网络中经历的总时延就是以上四种时延之和：总时延=发送时延+传播时延+处理时延+排队时延。 一般来说，小时延的网络要优于大时延的网络。 5、时延带宽积 把传播时延和带宽相乘，就可以得到：传播时延带宽积，即： 时延带宽积=传播时延*带宽 6、往返时间RTT 在计算机网络中，往返时间RTT是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。 7、利用率 利用率有信道利用率和网络利用率等。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道利用率是零。网络利用率则是全网络 的信道利用率的加权平均值。信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 信道或网络的利用率过高会产生非常大的时延。 计算机网络的非性能 费用（网络设计和实现的费用，简称“网费”【我猜的】） 质量（构件质量） 标准化 … Part③计算机网络分层：分层基本原则 各层之间相互独立，每层只实现一种相对独立的功能 每层之间界面自然清晰，易于理解，相互交流尽可能少 结构上可分隔开，每层都采用最合适的技术来实现 2保持上层对下层的独立性，上层单向使用下层提供的服务 整个分层结构都应该促进标准化工作 OSI参考模型应用层：所有能和用户交互产生网络流量的程序 表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义） 数据格式转换（翻译官） 数据加密解密 数据压缩和恢复（比如，视频聊天） 会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据（建立同步） 建立管理终止会话 使用校验点可以使会话在通信失效时从 校验点恢复继续通信，实现数据同步（适合传输大文件） 传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或者是用户数据报 可靠传输（在发送数据时，发送端必须收到接收端的确认信息才能够进行下一步发送操作），不可靠传输（不用确认，直接发送 ） 差错控制 流量控制 复用（多个应用层进程可同时使用下面的运输层的服务）分用（运输层把收到的信息分别交付给上面应用层中的相应进程） 网络层（IP层）：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报 路由选择 流量控制（协调发送端的发送速度） 差错控制 拥塞控制（若所有节点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞） 数据链路层：把网络层的数据报组装成帧。数据链路层的传输单位是帧 成帧：定义帧的开始和结束 差错控制（帧错+位错） 流量控制 访问控制（控制对信道的访问）—不懂… 物理层：在物理媒体上实现比特流的透明传输，传输单位是比特 定义接口特性 定义传输模式（单工、半双工、双工） 定义传输速率 比特同步 比特编码 不是笔记的笔记chapter① 死记硬背（期末）\\1. 组成一个网络的必要条件：多个具有独立功能的计算机系统、通讯子网、网络软件 \\2. 计算机网络的生产与发展：面向终端的计算机网络阶段、以共享资源为主要目的的计算机网络阶段、标准、开放的计算机网络阶段、高速、智能的计算机网络阶段 \\3. 计算机网络的组成：物理结构：网络软、硬件子系统 逻辑结构：资源子网、通讯子网 \\4. 计算机网络体系结构：是系统、实体、层次、协议的集合，是计算机网络及其部件所应完成功能的精确定义 \\5. 系统：计算机网络构成的系统通常是包括一个或多个实体的具有信息处理和通信功能的物理整体。 \\6. 实体：在网络分层体系结构中，每一层都由一些实体组成。在一个计算机系统中,能完成某一特定功能的进程或程序都可成为一个逻辑实体。实体既可以是软件实体，也可以是硬件实体。 \\7. 层次：是人们对复杂问题的一种处理方法。通常将系统中能提供某种或某类型服务功能的逻辑构造称为层。 \\8. 协议：是指两个实体间完成通信或服务所必须遵循的规则和约定。 \\9. 接口(Interface)，是同一个节点或节点内相邻层之间交换信息的连接点。 \\10. 同等层：不同系统的相同层次。 \\11. 同等层实体(对等实体)：不同系统同等层上的两个正通信的实体。 \\12. 同等层通信：不同系统同等层实体之间存在的通信。 \\13. 同等层(对等)协议：同等层实体之间通信所遵守的规则。各层的协议只对所属层的操作有约束力，而不涉及到其他层。 \\14. 服务：层次结构中各层都支持其上一层进行工作，这种支持就是服务。 \\15. 服务访问点(SAP)：接口上相邻两层实体交换信息的地方。是相邻两层实体的逻辑接口。如N层SAP就是N+1层可以访问N层的地方。 \\16. 服务原语：是指某一层实体向另一层实体报告事件的发生。 \\17. 服务原语主要有4种类型：请求、指示、响应、确认。 \\18. 数据单元：通常将传递数据的每一个单位叫做数据单元。 \\19. 协议数据单元：通常将不同计算机系统的对等层实体之间所交换的数据单位的每一部分称为协议数据单元。 \\20. 服务数据单元：第N层要求第N-1层提供服务时所要传递的数据单元。 \\21. 接口数据单元：在同一系统的相邻两层实体的一次交互中，将传递的参数和返回的结果。 \\22. OSI是Open System Interconnection 的缩写，意为开放系统互联参考模型 \\23. 任何一个通信系统都可以看作是由发送设备、传输信道和接收设备三大部分组成。我们把产生和发送信息的一端称为信源，把接收信息的一端称为信宿，把信源传送到信宿的通信线路称为信道。 \\24. 信息泛指那些通过各种方式传播的、可被感受的声音、文字、图像、符号等所表征的某一特定事物的消息、情报或知识。 \\25. 数据是一种承载信息的实体，是对客观事物的符号表示，在计算机科学中是指所有输入到计算机中并被计算机程序处理的符号的总称。数据分为模拟数据（连续）和数字数据（离散）两种。 \\26. 信号是数据的具体物理表现形式，它具有确定的物理描述,如电信号、光信号或磁场强度等。信号分为模拟信号（连续）和数字信号（离散）两种。 \\27. 模拟信号：是一种连续变化的电信号，例如电话语音信号、电视信号等，它是随时间变化的函数曲线 \\28. 数字信号：是离散的不连续的电脉冲序列, 通常用“高”和“低”电平脉冲序列组成的编码来表示数据。 \\29. 基带信号(Baseband Signal)直接用两种不同的电压表示数字信号1和0，然后将其送到线路上进行传输。因此，一般将对应矩形电脉冲信号的固有频率称为“基带”，将相应的信号称为基带信号 \\30. 宽带信号(Wideband Signal)用多组基带信号和0分别调制不同频率的载波，并由这些分别占用不同频段的调制载波组成。换言之，宽带信号是指将基带信号进行调制后形成的频分复用模拟信号 \\31. 模拟通信系统：普通的电话、广播、电视等信号都属于模拟信号,由模拟信号所构成的通信系统属于模拟通信系统。模拟通信系统通常由信源、调制器、信道、解调器、信宿以及噪声源组成 \\32. 数字通信系统：计算机通信、数字电话以及数字电视等信号都属于数字信号，由数字信号构成的通信系统属于数字通信系统。数字通信系统通常由信源、编码器、信道、解码器、信宿以及噪声源组成 \\33. 数据传输速率：是指每秒钟传输的二进制比特数，又称数据率或比特率，速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等 \\34. 带宽（bandwidth）：本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等），现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s) \\35. 吞吐量（throughout）是指一组特定的数据在特定的时间段经过特定的路径所传输的信息量的实际测量值。 \\36. 码元传输速率：在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称波特率。 \\37. 波特率：是指数据信号对载波的调制速率，用单位时间内载波调制状态改变的次数来表示（也就是每秒调制的符号数），其单位是波特（Baud，symbol/s）。 \\38. 时延（delay 或Latency）：是指一个报文或分组从一个网络（或一条链路）的一端传送到另一端所需的时间。通常来讲，时延是由以下几个不同的部分组成的。 \\39. 数据经历的总时延(delay或latency)就是发送时延、传播时延、处理时延和排队时延之和 \\40. 发送时延：节点在发送数据时使数据块从节点进入传输介质所需要的时间，也就是从数据块的第一个比特开始发送算起，到最后一个比特发送完毕所需的时间。又称为传输时延。 \\41. 传播时延：电磁波在信道上需要传播一定的距离而花费的时间。 \\42. 处理时延：数据在交换节点为存储转发而进行一些必要的处理所花费的时间。 \\43. 排队时延：分组在经过网络传输时，要经过很多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。因此而产生的时延。 \\44. 时延带宽积：是指某一链路所能容纳的比特数。链路的时延带宽积又称为以比特为单位的链路长度。 \\45. 信道利用率：指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。信道利用率并非越高越好。 \\46. 网络利用率则是全网络的信道利用率的加权平均值。 \\47. 误码率：在一定时间内收到的数字信号中发生差错的比特数与同一时间所收到的数字信号的总比特数之比,就叫做“误码率”，也可以叫做“误比特率”。 \\48. 误码率（BER：bit error rate）是衡量数据在规定时间内数据传输精确性的指标。 \\49. 信道：是指以传输介质为基础的信号通路，它可以细分成狭义信道和广义信道。 \\50. 狭义信道：将有信号传输介质的信道称为狭义信道，按照具体介质的不同类型来划分，可细分为：有线信道、无线信道 \\51. 广义信道：根据研究对象和关心问题的不同，广义信道按照其包含的功能通常也可分成两种：调制信道和编码信道。 \\52. 模拟信道：传输模拟信号的信道。 \\53. 数字信道：传输数字信号的信道 \\54. 信道容量：是指信道在单位时间内可以传输的最大信号量，通常用来表示信道的极限传输能力。 \\55. 香农定理：在信号处理和信息理论的相关领域中，通过研究信号在经过一段距离后如何衰减以及一个给定信号能加载多少数据后得到了一个著名的公式，叫做香农（Shannon）定理 \\56. 并行传输是指数据以成组的方式在多个并行信道上传输。 \\57. 串行传输是指数据以串行方式，在一条信道上传输。 \\58. 同步传输（Synchronous）：位同步（包括外同步法、内同步法）字符同步 \\59. 异步传输（asynchronous）：异步传输一次只传输一个字符,每个字符用一位起始位引导、一位停止位结束。 \\60. 基带传输：是一种不搬移基带信号频谱的传输方式。未对载波调制的待传信号称为基带信号，它所占的基本频带称为基带，基带的高限频率与低限频率之比通常远大于1。基带传输广泛用于音频电缆和同轴电缆等传送数字电话信号 \\61. 频带传输：是在计算机网络系统的远程通信中把数字信息调制成模拟信号后再发送和传输，到达接收端时再把模拟信号解调成原来的数字信号的传输技术。 \\62. 数字数据的数字信号编码：就是如何把数字数据用物理信号的波形表示，是用高低电平的不同组合来表示二进制的方法 \\63. 解码： \\64. 数字数据的模拟信号编码： 数字数据的调制基于调幅、调频、调相3种调制技术，分别称为幅移键控、频移键控和相移键控 \\65. 振幅调制（Amplitude modulation，AM）：是以原来的模拟数据为调制信号对载波的幅值按调制信号的幅值进行调制，调制后载波信号的频率和相位不变,幅值随调制信号的幅值变化而变化 \\66. 频率调制（Frequency modulation，FM）：是以原来的模拟数据为调制信号,对载波的频率按调制信号的频率进行调制,调制后载波信号的相位和幅值不变，频率随调制信号的幅值变化而变化 \\67. 相位调制（Phase modulation，PM）：是以原来的模拟数据为调制信号,对载波的相位按调制信号的相位进行调制，调制后载波信号的频率和幅值不变,相位随调制信号的幅值变化而变化 \\68. 模拟数据数字编码的最常用方法是脉冲编码调制（Pulse Code Modulation，PCM)：PCM的工作过程包括3个步骤：采样、量化与编码 \\69. 多路复用：传输信号要求的带宽与传输介质允许通过的带宽是不一样的，为了节省开销，应当充分利用传输介质的带宽。在一条介质上同时传送多于一路以上信号的传输方式，叫做该介质的多路复用。 \\70. 频分多路复用：在物理信道的可用带宽超过单个原始信号所需带宽情况下，可将该物理信道的总带宽分割成若干个与传输单个信号带宽相同的子信道，每个子信道传输一路信号，这就是频分多路复用 \\71. 时分多路复用：时分多路复用（TDM）是将一条物理信道的传输时间划分为若干个时间片，每个用户分得一个时间片，在其占有的时间片内用户使用通信信道的全部带宽。 \\72. 波分多路复用（WDM）：采用的是波长分隔多路复用技术,在同一传输信道内传输多路不同波长的光信号。 \\73. 码分多路复用(CDM)：是一种用于移动通信系统的新技术,笔记本电脑和掌上电脑等移动性计算机的连网通信将会大量使用码分多路复用技术。 \\74. 有线(导向)传输介质：双绞线、同轴电缆、光纤 \\75. 同轴电缆（Coaxial Cable） ：有基带同轴电缆和宽带同轴电缆。 \\76. 物理层的功能：物理连接的建立、维持和释放、物理服务数据单元的传输(传输数据)、完成物理层的一些管理工作 \\77. 物理层4大接口的特性：机械特性、电气特性、功能特性、规程特性 \\78. 集线器（Hub）：主要功能是对接收到的信号进行再生、整形、放大，以扩大网络的传输距离，同时将所有节点集中在以它为中心的节点上。集线器工作在OSI参考模型中的物理层上。集线器与网卡、网线等传输介质一样，属于局域网中的基础设备，采用CSMA/CD访问方式。 \\79. 链路：指的是从一个节点到相邻节点的一段物理线路，并且在这段物理线路的中间，没有任何其他的交换节点。 \\80. 数据链路：当两个节点在一条路径上传输数据时，它们之间除了必须要有一条物理线路以外，还必须要有一些必不可少的通信协议，来控制数据的传输过程。附加了实现这些协议的硬件和软件的链路，才能被称为数据链路。 \\81. 帧同步：又称帧定界，指接收方能从接收到的比特流中准确提取数据帧，准确地区分出一帧的开始和结束位置。 \\82. 差错控制 ：在数据通信中受物理链路性能和网络通信环境等因素的影响，难免会出现一些传送错误。数据链路层主要是通过“差错控制”技术来实现此功能的。 \\83. 链路管理：包括数据链路的建立、维持、释放 \\84. MAC寻址：数据能发送到正确的目的地、接收方知道发送方的地址、由于局域网有多种媒体接入控制，无法采用统一的数据链路层，局域网的数据链路层分为逻辑链路控制和接入链路控制两层。 \\85. 透明传输 ：比特数据的任何组合都能在链路上传输，当数据的比特组合与控制字符相同时，采用相应的处理。 \\86. 数据链路层提供的服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务 \\87. 流量控制：该功能使发送与接收数据同步，是指采用一定技术措施，使通信网络中部分或全部链路，以及节点上的信息流量不超过某限制值，从而来保证信息流动顺畅，避免由于信息流量过大而造成信息拥挤，使信息通过能力下降，甚至造成系统“死锁”的情况发生 \\88. 停止等待ARQ协议：ARQ (Automatic Repeat reQuest)，直译是自动重传请求，但意思是自动请求重传。 \\89. 差错产生的原因：在数据通信中，接收端收到的数据与发送端的数据不一致 \\90. 常用的检错码有：奇偶校验码、循环冗余码、海明码等。 \\91. 纠错码：每个传输的分组带上足够的冗余信息；接收端能发现并自动纠正传输差错。 \\92. 差错控制的常用方法：反馈纠错、前向纠错、混合纠错 \\93. 差错控制的常用编码：奇偶校验码、循环冗余码CRC \\94. 网桥含义：网桥是第2层的设备，它的功能是连接两个或多个LAN分段。其中每一个分段都是一个独立的冲突域。 \\95. 交换机含义：交换机(Switch)也称为交换器或交换式集线器，是专门为计算机之间能够相互通信且独享带宽而设计的一种包交换设备。 \\96. 交换机的帧转发方式：存储式转发、直通式转发、无碎片式转发 \\97. 交换机的交换技术：端口交换技术、帧交换技术、信元交换技术 \\98. 局域网（Local Area Network，简称LAN）通常是指在某一区域内由多台计算机互连而成的计算机组。局域网可由一间办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 \\99. 局域网系统主要由局域网硬件系统和局域网软件系统这两部分组成。 \\100. 局域网的性能：拓扑结构、传输介质（同轴电缆、双绞线、光纤、电磁波等）、介质访问控制方法 \\101. 局域网的拓扑结构：星形网、环形网、总线网、树形网 \\102. 局域网的类型：共享介质局域网、交换式局域网 \\103. 局域网的网络模式：客户机/服务器模式（Client/Server，C/S）、浏览器/服务器模式、对等服务器网络模式 \\104. 局域网参考模型：局域网的体系结构只包含了数据链路层和物理层，其中，数据链路层又分为逻辑链路控制和介质访问控制两个子层。 \\105. 802.1：A定义了局域网体系结构;B定义了网络互连、网络管理与性能测试 \\106. 802.2：定义了局域网逻辑链路控制LLC子层的功能与服务 \\107. 802.3：定义了局域网CSMA/CD总线介质访问控制子层及物理层规范 \\108. 802.11：定义了无线局域网访问方法和物理层规范 \\109. 介质访问控制方法概念：将传输介质的频带有效地分配给网络上各结点的方法称为介质访问控制方法 \\110. IEEE 802规定了多种局域网媒体介质访问方法：适合总线结构的带冲突检测的载波监听多路访问（CSMA/CD）方法、适合环型结构的令牌总线（Token Bus）方法、适合环型结构的令牌环（Token Ring）方法 \\111. ALOHA系统最初是在无线电信道上实现的。纯ALOHA可以工作在无线信道，也可以工作在总线式网络中 \\112. CSMA：载波监听多点接入CSMA（Carrier Sense Multiple Access）又称载波侦听多路访问，CSMA协议与ALOHA的主要区别就是多了一个载波监听装置，其功能为发送前监听 \\113. CSMA协议的类型：非坚持CSMA、1-坚持CSMA、p-坚持CSMA \\114. 冲突：在信道上可能有两个或更多的设备在同一瞬间都发送帧，从而在信道上因造成帧的重叠而出现差错，这种现象称为冲突 \\115. CSMA/CD接收过程：网上每个站点平时都在监听总线，如果有信息帧到来，则接收信息帧；然后再分析和判断信息帧中的接收端地址，如果该地址为本站地址，则复制接收该帧；否则，简单丢弃该帧。 \\116. 常用的以太网MAC帧格式有两种标准：DIX Ethernet V2标准、IEEE802.3标准 \\117. 以太网数据封装格式：以太网IP数据报的封装在RFC 894中进行了详细的定义，IEEE 802网络的IP数据报封装则是在R.FC1042中定义 \\118. 以太网地址：单播地址(Unicast Address)、多播地址(Multicast Address)、广播地址(Broadcast Address) \\119. 10BASE-T中的T指双绞线，10BASE-5指传输距离500米(即粗缆) IEEE标准共有以下几种: l 10BASE-5：粗缆。最大传输距离500米，使用AUI连接器连接或使用收发器电缆和收发器(MAU)进行连接。 l 10BASE-2：细缆。实际传输距离为185米，使用BNC连接器(T型和N型)。 l 10BASE-T：双绞线。传输距离100米，使用RJ45连接器。 l 10BASE-F：光纤。分为FP，FL，FB 三种链接类型，FP使用无源集线器连接，传输距离500米，FB使用有源连接器，传输距离3000米，FL可以使用多个中继器，可以进一步延长器传输距离。 l 100BASE-TX：双绞线，使用两对非屏蔽双绞线或两对1类屏蔽双绞线连接，传输距离100米 l 100BASE-T4：4对3类非屏蔽双绞线，传输距离100米 l 100BASE-F： 单模或多模光纤，传输距离2000米左右 l 1000BASE-T：5类非屏蔽双绞线，传输距离100米 l 1000BASE-CX：屏蔽类双绞线，传输距离25-50米 l 1000BASE-LX：单模光纤，传输距离5000米/多模光纤，传输距离316-550米 l 1000BASE-SX：多模光纤，连接光纤使用SC型光纤连接器，传输距离275米至550米 \\120. 10Gbit/s万兆以太网，目标在于：扩展以太网，使其能够超越LAN，以进入WAN和MAN \\121. VLAN的概念：虚拟局域网，即VLAN (Virtual Local Area Network)。它是一种把局域网设备从逻辑上划分成更小的局域网，从而实现虚拟工作组的数据交换技术。 \\122. 802.1Q标准：通用标准，基于IEEE 802.1Q附加的VLAN信息，就像在传递物品时附加的标签。因此，它也被称作“标签型VLAN(Tagging VLAN)”。 \\123. ISL( Inner Switch Link)：专用标准，是Cisco特有的标记方法，只有Cisco的设备才可以理解ISL封装的数据帧 \\124. VLAN链路类型：接入链路(Access Link)、干道链路(Trunk Link)、混合(hybrid)链路 \\125. 令牌环网工作流程：截获令牌并且发送数据帧、接收与转发数据、取消数据帧并且重发令牌 \\126. 令牌总线网的工作原理：截获令牌、地址转载、令牌转发 \\127. 局域网的扩展：利用集线器/交换机进行扩展 \\128. 交换式以太网的主要特点：兼顾性、兼容性、易用性、灵活性、支持性 \\129. 无线局域网(Wireless Local-Area Network，WLAN)也称Radio LAN，就像其名字所描述的一样：它挣脱了传统线缆束缚，提供了以太网或者令牌网络的功能 \\130. WLAN的主要类型：红外局域网、扩频无线局域网、窄带微波无线局域网 \\131. IEEE802.11a扩充了标准的物理层，它工作在5.0GHz频带，传输速率为5Mb/s、11Mb/s和54Mb/s，采用正交频分多路复用(OFDM) 技术。 \\132. IEEE802.11b标准工作在2.4GHz频带，采用DSSS扩频技术和补偿编码键控(CCK)调制方式。传输速率为1Mb/s、2Mb/s、5.5Mb/s和11Mb/s。 \\133. IEEE802.11g标准工作在2.4GHz频带，采用正交频分多路复用(OFDM) 技术，速率可达54Mb/s \\134. 无线局域网的组成：有固定基础设施的无线局域网(Infrastructure工作模式)、无固定基础设施的无线局域网(Ad-hoc工作模式) \\135. WLAN的体系结构：IEEE802.11标准中的物理层、IEEE802.11标准中的MAC子层 \\136. 无线局域网中的复杂性问题：具体可分为隐蔽站问题和暴露站问题。 \\137. WLAN的介质访问控制方式：分布控制方式、中心控制方式 \\138. WLAN的组建方式：无线网络网卡、无线网络Hub、无线网络网桥 \\139. 网络层的功能：主要功能是提供路由，选择到达目标主机的最佳路径，并沿该路径传送数据包。其它功能:消除网络拥塞、流量控制、拥塞控制、建立和拆除网络连接、多路复用、分段和组块、服务选择和传输等功能。 \\140. 网络层提供的两种服务：面向连接服务、无连接服务 \\141. 面向连接服务类似于电话系统，而无连接服务则类似于邮政系统 \\142. IP 地址的编址方法：分类的 IP 地址、子网的划分、构成超网。 \\143. 特殊IP地址和专用IP地址：广播地址、有限广播地址、 “0”地址、回送地址 \\144. 子网划分原因：IP 地址空间的利用率有时很低、给每一个物理网络分配一个网络号会使每个网络中的主机数太大，因而使网络性能变坏。两级的 IP 地址不够灵活。 \\145. 掩码：掩码(NetMask)有网络掩码和子网掩码两种 \\146. IP 层转发分组的流程：直接交付和间接交付、使用子网掩码的分组转发 \\147. 网络地址转换类型：静态NAT、动态地址NAT、NAPT \\148. 地址解析协议ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题 \\149. 逆地址解析协议 RARP：使只知道自己硬件地址的主机能够知道其 IP 地址 \\150. DHCP (Dynamic Host Configuration Protocol):动态主机配置协议，l 工作在客户机/服务器(C/S)模式下，包括DHCP服务器和DHCP客户端两个角色，主要提供IP地址、默认网关、子网掩码的信息 \\151. DHCP的工作流程分为四步，分别是客户端请求IP、服务器响应、客户端选择IP、服务器确认IP租约。 \\152. 网际控制报文协议 ICMP(Internet Control Message Protocol)作用：为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 \\153. ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 \\154. ICMP 不是高层协议，而是 IP 层的协议。 \\155. ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。 \\156. 路由选择的不同策略：静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化；动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 \\157. 距离矢量路由选择算法是让每个路由器维护一张表(即向量)，表中给出了到每个目的地已知的最佳距离和路线。通过与相邻路由器交换信息来更新表的信息。距离矢量路由选择算法也被称为Bellman-Ford路由选择算法和Ford-Fulkerson算法，即RIP算法。 \\158. 最常见的距离矢量路由协议主要有：路由信息协议 (Routing Information Protocol,RIP)、内部网关路由协议 (Interior Gateway Routing Protocol,IGRP)等。 \\159. 自治系统AS(Autonomous System)的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS 之间的路由选择协议用以确定分组在AS之间的路由。 \\160. 内部网关协议 IGP (Interior Gateway Protocol) 即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。 \\161. 外部网关协议EGP (External Gateway Protocol) 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。 \\162. 因特网的路由选择协议 ² 内部网关协议 IGP：具体的协议有多种，如 RIP 和 OSPF 等。 ² 外部网关协议 EGP：目前使用的协议就是 BGP。 \\163. 内部网关协议RIP (Routing Information Protocol)：RIP 是一种分布式的基于距离向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 \\164. 内部网关协议OSPF （Open Shortest Path First开放最短路径优先）是分布式的链路状态协议。 \\165. OSPF的区域：为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。 \\166. OSPF三个要点 ① 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 ② 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 ③ 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 \\167. 内部网关路由协议(Interior Gateway Routing Protocol，IGRP)是一种在自治系统中提供路由选择功能的思科专有路由协议。 \\168. IGRP是一种距离矢量内部网关协议(IGP)。增强的内部网关路由选择协议(Enhanced Interior Gateway Routing Protocol，EIGRP)是增强版的IGRP。 \\169. 外部网关协议 BGP：是不同自治系统的路由器之间交换路由信息的协议，它只传输路径信息。BGP 较新版本是BGP-4（BGP 第 4 个版本） \\170. xxxxxxxxxxxxxxxxxxxxxxxxxxxxx \\171. 路由器主要有以下几种功能：网络互联功能、数据处理功能、网络管理功能 \\172. 直接交付和间接交付：互联网络中路由器转发IP分组的物理传输过程与数据报转发交付机制称为分组交付，分组交付可以分为直接交付和间接交付两类。当分组的源主机和目的主机是在同一个网络，或转发是在最后一个路由器与目的主机之间时将直接交付。如果目的主机与源主机不在同一个网络上，分组将间接交付 \\173. 路由器的结构：路由选择部分和分组转发部分；分组转发部分，由三部分组成：交换结构、一组输入端口和一组输出端口 \\174. 路由器交换结构：通过总线进行交换、通过纵横交换结构进行交换、共享存储器 \\175. 路由工作原理:p227 \\176. 路由表类型：静态路由表、动态路由表 \\177. 路由表项包括：目的网络前缀、子网掩码、下一跳字段 \\178. 路由表项的类型：网络路由、主路由、默认路由 \\179. 路由表结构：网络ID 、转发地址 、接口 、跃点数 \\180. IPv6地址主要有：单点传送、多点传送、任意点传送三种类型，它们也分别被称为单播地址、组播地址和泛播地址。 \\181. 单点传送地址是一个单接口标识符，送往单点传送地址的包将会被传送到该地址所标识的接口上。 \\182. 任意点传送地址是一组接口的标识符。送往某个任意点传送地址的包将会被传送到该地址所标识的一组接口中距离源节点最近（根据使用的路由协议进行度量）的一个接口上。 \\183. 多点传送地址是一组接口的标识符。送往某个多点传送地址的包将会被传送到该地址所标识的所有接口上。 \\184. 从 IPv4 向 IPv6 过渡：双协议栈(dual stack)、隧道(Tunneling)技术、NAT-PT (Network Address Translation-Protocol Translation，附带协议转换的网络地址转换) \\185. 端口：当一个应用程序(比如一个用户)进程想和远程的一个应用程序进程建立连接时，它必须指定是与哪个应用程序进程相连。正常采取的方法是定义进程能够侦听连接请求的传输地址。在因特网中，这些端点被称作端口(port)。 \\186. TSAP (Transport Service Access Point，传输服务访问点)。网络层中类似的端点(即网络层地址)则被称为NSAP。 IP地址就是NSAP的一个例子 \\187. 传输实体建立连接的方法：三次握手(three-way handshake)方法。 \\188. 释放传输连接：三次握手释放连接 \\189. 终止连接的方式：非对称释放和对称释放 \\190. 非对称释放是电话系统的工作方式：当一方挂机时，连接即告中断。 \\191. 对称释放把连接当做两个独立的单向连接处理，要求每一方单独释放连接。 \\192. 流量控制和缓冲：总结来说，对于低带宽流量，在发送方缓存比较好；对于高带宽流量的稳定传输，在接收方缓存比较好 \\193. TCP/IP的传输层有两个不同的协议：用户数据报协议(UDP)；传输控制协议(TCP)。 l 区别 ² UDP在传送数据之前不需要建立连接，即提供无连接的服务。此外，UDP不提供广播或者多播服务。 ² TCP则提供面向连接的服务，在传送数据之前必须先建立连接。TCP也不提供广播或者多播服务。 \\194. 用户数据报协议（UDP）概述：传输层协议需要具备以下功能：一是创建进程到进程的通信；二是在传输层提供控制机制 \\195. ＵＤＰ端口分配方法：客户进程的端口号分配、服务器进程的端口号分配 \\196. 套接字地址：UDP需要两个标识符，IP地址和端口号，它们各用在一端以建立一条连接。一个IP地址与一个端口号合起来就叫做套接字地址或插口地址。 \\197. 要使用UDP的服务，需要一对套接字地址：客户套接字地址和服务器套接字地址。 \\198. TCP是一种面向连接的、可靠的传输层协议。TCP协议向应用层用户进程提供可靠性、全双工的数据流传输 \\199. TCP数据编号与确认：TCP是面向字节的；在连接建立时，双方要商定初始序号；TCP的确认是对接收到的数据的最高序号表示确认 \\200. TCP流量控制：TCP协议是面向字节的。TCP将要传送的报文段看成是字节组成的数据流 \\201. 发送缓存与接收缓存：TCP需要缓存来存储数据。在每一个方向都有两个缓存，即发送缓存与接收缓存 \\202. 糊涂窗口综合征： 发送端产生的症状解决的方法是防止发送端TCP逐个字节地发送数据。必须强迫发送端TCP等待，让它收集数据，以便发送大块数据；接收端产生的症状解决方法。(1)Clark解决方法。(2)延迟的确认 \\203. TCP拥塞控制：加速递减策略、慢启动 \\204. 按照通信过程中，双方的地位是否相等，可以把网络应用模式分为：客户/服务器 (C/S ，Client/Server)模式、对等模式 (P2P，Peer to Peer)模式 \\205. P2P是Peer-to-Peer的缩写，称为对等网，强调系统中节点之间的对等关系， P2P网络强调节点地位的对等性。P2P中对等点之间的位置关系是逻辑意义上的。 \\206. 域名服务：在网络上辨别一台计算机的方式是利用IP，但是一组IP数字很不容易记，且没有什么联想的意义，因此，为网络上的服务器取一个有意义又容易记的名字，这个名字就叫域名(Domain Name)。 \\207. 域名：在TCP/IP中实现的这种层次型命名管理机制称为域名系统 \\208. TCP/IP域名系统包括概念上相互独立的两个层面。其中，一个层面是抽象层面，它规定命名语法以及域名管理特权的分派规则；另一个层面是具体层面，它描述如何具体实现从域名到IP地址的高效率映射。 \\209. 了解DNS服务器两种查询方式：迭代查询和递归查询 \\210. 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的传输服务 \\211. FTP 使用客户机/服务器模式工作 \\212. 一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。 \\213. FTP用户登录的类型：匿名访问、凭用户名和密码 \\214. 简单文件传输协议(Trivial File Transfer Protocol, TFTP)最初是打算用于引导无盘系统(通常是工作站或X终端), 所以它使用的是UDP而不是TCP来进行文件传输，以保证算法简单。 \\215. TFTP报文不提供用户名和口令，这是因为TFTP被设计用于系统引导进程，它不可能提供用户名和口令。 \\216. 端口号：TFTP服务器使用UDP端口69 \\217. 远程登录协议Telnet用途：简单地说，远程登录是指用户使用Telnet命令，使自己的计算机暂时成为远程主机的一个仿真终端这样一个过程。 \\218. Telnet远程登录服务实际上将用户用来登录的计算机当作一个输入终端，而将要登录的远程计算机或者远程主机作为具有快速处理能力的主机 \\219. 电子邮件系统具有三个主要组成部件： 用户代理(user agent)、 邮件服务器、电子邮件使用的协议 \\220. 电子邮件格式：由信封(envelope)和内容(content)两部分组成。 \\221. 电子邮件的相关协议：邮件读取协议 POP 或 IMAP 、邮件传送协议 SMTP \\222. 浏览器/服务器模式（B/S模式）：浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器；客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 \\223. 页面(page)：在一个客户程序主窗口上显示出的万维网文档称为页面 \\224. 超链接 \\225. 超文本文档 \\226. 统一资源定位符 URL（Uniform Resource Locator)：使用统一资源定位符 URL来标志万维网上的各种文档 \\227. 超文本传送协议 HTTP (HyperText Transfer Protocol)：在万维网客户程序与万维网服务器程序之间进行交互所使用的协议 \\228. HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 \\229. 超文本标记语言 HTML \\230. 动态主机配置协议 DHCP含义：动态主机配置协议 (Dynamic Host Configuration Protocol， DHCP ) 提供了即插即用连网(plug-and-play networking)的机制。 \\231. DHCP具有以下特点：安全而可靠的配置、集中管理、节省IP \\232. 作用域：是一个网络中的所有可分配的IP地址的连续范围。主要用来定义网络中单一的物理子网的IP地址范围。 \\233. 超级作用域：是一组作用域的集合，它用来实现同一个物理子网中包含多个逻辑IP子网。 \\234. 排除范围：是不用于分配的IP地址序列。 \\235. 地址池：在用户定义了DHCP作用域及排除范围后，剩余的地址构成了一个地址池，地址池中的地址可以动态地分配给网络中的客户使用。 \\236. 租用期(lease period)：DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 \\237. 保留地址：用户可以利用保留地址创建一个永久的地址租用期。保留地址保证子网中的指定硬件设备使用同一个IP地址。 \\238. DHCP 工作时使用客户/服务器方式","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"大学所学","slug":"大学所学","permalink":"/tags/大学所学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"蛋疼のNode学习之路(持续更新...)","slug":"蛋疼のNode学习之路","date":"2021-02-01T23:00:00.000Z","updated":"2022-06-14T11:43:27.343Z","comments":true,"path":"undefined/蛋疼のNode学习之路/","link":"","permalink":"/undefined/蛋疼のNode学习之路/","excerpt":"","text":"蛋疼のNode学习之路（持续更新…）Day1Previously on ‘Preface’，对于一个几乎零基础的我来说，搭建博客的过程是十分痛苦的，这现在只是一个简单的修改博客主题和编辑的过程啊（前端知识盲区o(╥﹏╥)o）。所以我决定花上一定时间来学习Node.js。希望学完之后我能更好的运维我的BLog（顺便复【yu】习一下Web相关知识，HTML5，CSS3，JavaScript什么的都快忘光光啦）话不多说，今天开始第一天的学习！ ①那么，Node.js是乜嘢？（what？）解释： 不是一门语言，不是库，不是框架。而是一个js的运行时 ，通俗地说就是能够一个能够运行js的平台环境。 可提供服务器级别的api（需要引入相关的模块，比如文件读写需要’fs’，也就是File-System）：文件读写，网络服务构建，网络通信，http服务器（http模块）……//后面会讲模块系统 特性： 事件驱动 非阻塞IO模型（异步）————————————-啊啥是同步和异步？，又要去恶补了o((⊙﹏⊙))o 轻量和高效 与Node.js相关的东东npm：全称是Node Package Manager。世界上最大的开源生态系统（大多数的js相关的包都在npm里）可在命令行通过下列语法获取相关包 npm install [jquery] ②Node.js能干啥哇？（do what？） web服务器后台（能干类似活的有Java,，PHP，Python，balabala…….） 命令行工具 npm git hexo （这个我熟哈哈） ③参考资源（resource） 《深入浅出Node.js》（偏理论） 《Node.js权威指南》 JavaScript标准参考教程（alpha）作者：阮一峰（惊了，英文名也叫Frank） Node入门（fen） cNode社区 ④安装Node（install）会的都会，不会的戳一戳下面的教程： 参考教程：https://www.runoob.com/nodejs/nodejs-install-setup.html ⑤模块系统（Module system） 在Node中，每一个js文件都是一个模块，另外Node中也没有全局作用域的概念。 在Node中，只能通过require()方法加载js文件。 require()方法只加载其中的代码。既然没有全局作用域，那么各个js文件之间是模块作用域。 模块全封闭。 外部和内部之间是无法互相访问的。 其实每个模块中有都一个exports专属的对象，该对象中可以封装各自模块中的数据和方法，方便其他模块应用 举个例子 var demo =require(&#39;./a&#39;)//调用模板a，并且获得a的exports对象,并且用一个变量demo接收 ——————-分割线，下面进入简单的实操环节——————– 启动一个简单服务器 var http = require(&#39;http&#39;)//创建http对象 var server = http.createServer()//利用http对象创建一个服务器对象server server.listen(4000, function () {//选择端口 console.log(&quot;贪玩蓝月服务器，琦动！&quot;) }) server.on(&#39;request&#39;, function (request, response) {//server监听是否收到客户端发送过来的request，收到后根据回调函数再返回响应 console.log(&quot;收到请求&quot;) response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;})//&lt;-----------解决乱码的方法 var url = request.url if (url == &#39;/&#39;) { response.end(&quot;欢迎来到贪玩蓝月，是兄弟就来砍我&quot;) } else if(url==&#39;/login&#39;){ response.end(&quot;貪玩藍月登錄註冊界面...&quot;) } else if(url==&#39;/register&#39;){ response.end(&quot;快進到貪玩藍月の註冊界面&quot;) } else{ response.end(&quot;404 not found...&quot;) } }) 但是第一次运行的时候出现这种情况……. 不用慌，在回调函数里的第一行加上 response.writeHeader(200, {&#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39;}) 运行后的截图 当然一个网站肯定不能只是傻傻地响应同一段内容，服务器必须根据浏览器(客户端)发来的请求信息来对应地响应合适的内容。 实现方法也特别简单，加入一组if-else的判断就可。（详情见上代码line10-21） 实现效果： And: 2.模块系统 解释：在demo中引入模板a—&gt;执行a的代码，在控制台打印starting语句—&gt;引入模板b—&gt;打印模板b的opening和closed—&gt;a中的引用结束，打印a的end—&gt;打印从a模板获取的值foo=200 从中我们发现输出的foo值是模板a中的，而不是b模板中的。这也体现了模块作用域的好处：可以加载执行多个文件，可以完全避免变量命名而产生的冲突（认真脸） ⑥相关知识补充 同步（Synchronous） A程序调用B程序，必须等待B程序完成才能返回到A程序，A程序继续执行……从流程上看是一条”直线“ 异步（Asynchronous） A程序调用B程序，此时A不会等待B程序是否执行完毕，而是继续往后执行自己的代码……从流程上看是出现了一条从主线产生的“支线” 回调函数 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（来自谷歌的解释） 通俗讲就是 ①你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 什么还不懂？行，还有个例子：②约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。~（单身的看例子①就好了） Day2 今天主要围绕模板引擎的概念以及应用方式、渲染这两点展开，并且相对应地结合两个小案例来更进一步的理解感受它们。话不多少，先介绍主要概念。 神么是模板引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。这就好比于我们的写作模板，我们想写什么类型的文章比如说明文，记叙文，抒情文，应用文。它们都有固定的一套模式，我们只要按照这套模式来，往里面添加我们自己的内容即可。 常用模板：art-template（art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。） 安装方法： npm install art-template --save 啥是渲染？在电脑绘图中，渲染是指在指用软件从模型生成图像的过程。而在HTML中则是指如何加工并且显示出最终的HTML页面。我们又根据加工场景位置的不同把HTML渲染分为服务端渲染和客户端渲染。 互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时ajax的兴起，使得业界就开始推崇前后端分离的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的客户端渲染了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。 服务端渲染aka后端渲染（service-side render）の优缺点： 优点 减轻前端压力 不用占用前端的资源，比如在用手机浏览网页时，浏览器的负担减轻，因此能够节省手机的电量 有利于SEO（Search Engine Optimization）搜索引擎优化。爬虫能够爬取到在后端的HTML文档 缺点 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则前端一般就是写一个静态html文件，然后后端再修改为模板，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； 或者是前端直接完成html模板，然后交由后端。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。 占用服务器端资源。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。 客户端渲染aka前端渲染（client-side render）的优缺点： 艾达王替矩（advantages）： 前后端分离，前端能够自定义UI而不用去过度依赖后端 diss艾达王替矩： 前端的响应速度会变慢，这就是为什么我们在浏览一些网页时，经常会“爱的魔力转圈圈”。（后端的渲染速度要比前端的快） 不利于SEO。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。因为服务器端可能没有保存完整的html，而是前端通过js进行dom的拼接，那么爬虫无法爬取信息。 除非搜索引擎的seo可以增加对于JavaScript的爬取能力，这才能保证seo。 小案例一：模拟Apacheの目录HTML（服务端渲染）在此之前我们还需要用到fs模块的readFile()和readdir()方法，简单介绍一下这两个方法： readFile()：能够读取指定路径下的文件并保存到data中，data是一个二进制的数据流（里面全是010101），因此要将其转变为我们认识的字符串需要用到toString()方法。 readdir()： 读取指定目录下的所有文件夹名，并返回一个由这些文件夹名构成的字符串数组files。 var fs = require(&#39;fs&#39;); fs.readdir(&#39;readdirtest&#39;, function(err,files){ if(err){ console.log(err); } console.log(files); }) 操作描述： 加载必要的模块fs，http… 设置端口号xxxx 为服务器设置响应信息 读取模板文件template.html（目录显示页），并且将要替换的区域使用特殊符号进行标记，这里我使用了-.-这个标记 读取目录列表的所有文件夹 并将要替换的部分用一个变量content表示 用forEach方法依次取出files里的文件夹名并构建content（见代码20—24） 将第一步读取的data转换为字符串 简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 发送响应 下面是一小段代码： var fs = require(&#39;fs&#39;) var http = require(&#39;http&#39;) var server = http.createServer() var wwwDir = &#39;F:/www&#39; server.on(&#39;request&#39;, function (req, res) { fs.readFile(&#39;./template.html&#39;, function (err, data) {//获得模板template.html if (err) { console.log(&#39;找不到文件......请重试&#39;) } fs.readdir(wwwDir, function (err, files) {//得到wwwDir的目录列表中的文件名和目录名 if (err) { return console.log(&#39;读取目录失败&#39;) } console.log(files)//files是一个字符数组，元素为目录中的文件名 var content = &#39;&#39;//将模板中要替换的部分构建为content files.forEach(function (item) {//利用forEach，取出files数组的每个元素（item），进行渲染${item}替换 content += `&lt;tr&gt;&lt;td data-value=&quot;新建 Microsoft Word 文档.docx&quot;&gt;&lt;a class=&quot;icon file&quot; draggable=&quot;true&quot; href=&quot;/F:/www/%E6%96%B0%E5%BB%BA%20Microsoft%20Word%20%E6%96%87%E6%A1%A3.docx&quot;&gt;${item}&lt;/a&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;0 B&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1612679895&quot;&gt;2021/2/7 下午2:38:15&lt;/td&gt; &lt;/tr&gt;` }) data = data.toString()//将二进制流的data转换为字符串 data=data.replace(&#39;-.-&#39;, content)//简单字符串解析替换操作，将template中替换的区域-.-（特殊标记）用content代替 res.end(data)//发送响应数据 }) }) }) server.listen(4001, function () { console.log(&#39;服务器，琦动！&#39;) }) 结果截图： 小案例二：art-template需要一个用于储存模板的html和一个js文件 html模板: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;This is Frank&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is {{ name }}.&lt;/p&gt; &lt;p&gt;I am {{ age }} years old.&lt;/p&gt; &lt;p&gt;I am from {{ province }}.&lt;/p&gt; &lt;p&gt;I like {{ each hobbies }} {{ $value }} {{/each}}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果没有art-template，运行结果如下： 加了art-template后： var fs=require(&#39;fs&#39;) var http=require(&#39;http&#39;) var template=require(&#39;art-template&#39;) http .createServer(function(req,res){ var url=req.url if(url===&#39;/&#39;){ fs.readFile(&#39;./Frank.html&#39;,function(err,data){ if(err){ return res.end(&#39;你访问的网址不存在噢&#39;) } data=data.toString() var Frank=template.render(data,{ name:&#39;Frank&#39;, age:20, province:&#39;ChongQing&#39;, hobbies:[&#39;打篮球&#39;,&#39;写博客&#39;,&#39;吹水&#39;] }) res.end(data) }) } }) .listen(3000,function(){ console.log(&#39;琦动！&#39;) 由此可见，art-template只关注中的值，不会去关心html中的格式。因此可以理解为js数据传到html中展示出来 Day3Node中的模块系统模块の定义： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。 使用Node编写应用程序主要就是在使用： Ecmascript 核心模块 文件操作fs http服务的http url路径操作的模块 path路径处理模块 os操作系统模块 第三方模块 art-template 必须通过npm下载 开发者自个儿写的模块（自定义的） 模块化 文件作用域 通信规则 加载require 导出CommonJs模块规范 这就是要谈论的——模 块 系 统 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员 加载require操作： var 自定义变量名称=require(&#39;模块&#39;) 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有成员只在当前文件模块有效 如果我们想要访问其他模块的成员，可以把这些成员加载到exports上去 导出多个成员： exports.demo=foo exports.test=&#39;233&#39; exports.fun=function(){ xxxxxxxxxxxxx } 也可以这样导出多个成员： module.exports={ add: function(){ return xxxxxxx }, foo:&#39;123&#39; } 导出单个成员（指定的）： module.exports=&#39;666&#39; module.exports=function(){ } 注意：在使用module.exports时，后一个的会覆盖前一个的module.exports 原理在底层代码中：exports是module.exports的一个引用—&gt;exports=module.exports console.log(exports===module.exports)//会返回true exports.foo=&#39;666&#39; module.exports.foo=&#39;666&#39;//等价 require方法加载规则 核心模块 模块名 第三方模块 模块名 开发者自己写的 路径 优先从缓存加载 加载过的模块会暂存入缓存中，若下次还有调用，直接从缓存中读取， 能有效提高模块加载效率 package.json每一个项目最好有一个包描述文件（package.json，就像产品的说明书）。可通过npm init生成 。有了该文件，再用npm install就能把文件里的依赖项全部下载回来，就相当于原先有了备份，现在进行备份还原 在每个项目的根目录下应该有一个package.json文件 每次安装第三方包时，应该在后面加上–save`，可以用来保存依赖项信息 npm [npm网站]: npmjs.com 命令行工具 npm install --global npm//更新命令 常用命令 npm init -y//快速生成package.json文件 npm install npm install 包名//下载指定包 npm install --save 包名//下载指定包并保存到package.json的dependencies中 npm uninstall 包名 npm help//查看使用帮助 npm 命令 --help//查看指定命令的使用帮助 如何解决npm被墙的问题 安装淘宝的cnpm： npm install --global cnpm//--global表示安装到全局，不能省略。以后就能用cnpm代替npm了 如果不想安装cnpm但是又想用淘宝的服务器下载，可以通过: npm config set registry https://registry.npm.taobao.org//默认使用淘宝服务器下载 Express一种Web开发框架 npm install express --save//安装express 拿到框架的第一步当然是Hello World！ var express=require(&#39;express&#39;) var app=express()//相当于以前的server对象 app.listen(3000,function(){ console.log(&#39;服务器，琦动&#39;) }) app.get(&#39;/&#39;,function(req,res){//以get方法请求&#39;/&#39;，并执行对应的处理函数 res.send(&#39;Hello World!&#39;) }) 静态服务（静态 资源获取）// 开放静态资源 // 1.当以/public/开头的时候，去./public/目录中找对应资源 // 访问：http://127.0.0.1:3000/public/login.html app.use(&#39;/public/&#39;,express.static(&#39;./public/&#39;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问 // 访问：http://127.0.0.1:3000/login.html // app.use(express.static(&#39;./public/&#39;)); // 3.访问：http://127.0.0.1:3000/a/login.html // a相当于public的别名 // app.use(&#39;/a/&#39;,express.static(&#39;./public/&#39;)); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 // 通过requery方法获取用户输入的数据 // req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） var express = require(&#39;express&#39;) // 引包 var bodyParser = require(&#39;body-parser&#39;) var app = express() // 配置body-parser // 只要加入这个配置，则在req请求对象上会多出来一个属性：body // 也就是说可以直接通过req.body来获取表单post请求数据 // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })) // parse application/json app.use(bodyParser.json()) 使用： app.use(function (req, res) { res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;) res.write(&#39;you posted:\\n&#39;) // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2)) }) 在express中配合和使用art-template安装： npm install --svae art-template npm install --save express-art-template 配置： app.engine(&#39;html&#39;,require(&#39;express-art-template&#39;))//第一个参数表示渲染以art结尾的文件 使用： app.get(&#39;/&#39;,function(req,res){ //express默认会从项目的views目录去寻找index.html res.render(&#39;index.html&#39;,{ title:&#39;hello world&#39; }) }) 如果希望修改视图渲染的目录（原本是views），可： app.set(&#39;views&#39;,目录路径) CRUD(待更…)其他项①修改完代码自动重启以前每次修改完代码都要傻乎乎地去node xxx.js现在有了nodemon这一个第三方命令行工具，就能解决这一问题。 安装方法，懂得都懂 npm install nodemon --global ②封装异步API回调函数：获取异步操作的结果 function fn(callback){ // var callback = funtion(data){ console.log(data); } setTimeout(function(){ var data = &#39;hello&#39;; callback(data); },1000); } // 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取 fn(function(data){ console.log(data); }) ③关于json文件格式の坑json文件格式要求极其严格，比如 致命错误在：id为5的一行末尾的逗号，一定要去掉！！！结尾的一个花括号不能有逗号（就这个错误折磨了我半个小时……） 小项目一个简单的表单提交网站 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: /** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */ var fs = require(&#39;fs&#39;); // Express专门提供了一种更好的方式 // 专门用来提供路由的 var express = require(&#39;express&#39;); // 1 创建一个路由容器 var router = express.Router(); // 2 把路由都挂载到路由容器中 var Students=require(&#39;./student&#39;) router.get(&#39;/students&#39;, function(req, res) { // res.send(&#39;hello world&#39;); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 Students.find(function(err,students){ if (err) { return res.status(500).send(&#39;Server error.&#39;) } res.render(&#39;index.html&#39;,{students:students}) }) }); router.get(&#39;/students/new&#39;,function(req,res){ res.render(&#39;new.html&#39;) }); router.post(&#39;/students/new&#39;,function(req,res){ //获取表单数据 console.log(JSON.stringify(req.body)) //处理数据 //将数据写入json文件 //发送响应 //读取json文件并转换为对象--&gt;在对象中添加数据--&gt;将对象转换为字符串--&gt;将字符串写入json文件 Students.save(req.body,function (err){ if(err){ return res.status(500).send(&#39;Server error.&#39;) } res.redirect(&#39;/&#39;) }) }); router.get(&#39;/students/edit&#39;,function(req,res){ }); router.post(&#39;/students/edit&#39;,function(req,res){ }); router.get(&#39;/students/delete&#39;,function(req,res){ }); // 3 把router导出 module.exports = router; app.js: var router = require(&#39;./router&#39;); // router(app); // 把路由容器挂载到app服务中 // 挂载路由 app.use(router); 数据操作文件模块/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */ var fs = require(&#39;fs&#39;); var dbPath = &#39;./db.json&#39; /** * 获取所有学生列表 * return [] */ exports.find = function (callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } callback(null, JSON.parse(data).students) }) } /** * 获取添加保存学生 */ exports.save = function (student, callback) { fs.readFile(dbPath, &#39;utf8&#39;, function (err, data) { if (err) { return callback(err) } //将json字符串转换为数组对象 var students = JSON.parse(data).students //将对象保存到数组对象中 if (students.length==0) { student.id =1 } else{ student.id=students[students.length-1].id+1 } students.push(student) //将数组对象转换为json文件（字符串） var newData = JSON.stringify({students: students}) //字符串写入到文件中 fs.writeFile(dbPath, newData, function (err) { if (err) { return callback(err) } callback(null) }) }) } /** * 更新学生 */ exports.update = function () { } /** * 删除学生 */ exports.delete = function () { } 成功插入数据の截图： 点击submit，成功重定向回主页并渲染完成の截图 小结：通过这个小项目的练习，可以体会到当进行异步编程时，要想获取异步函数的数据就要使用回调函数","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"/tags/nodeJs/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Preface","slug":"Preface","date":"2021-01-31T16:00:00.000Z","updated":"2021-03-12T09:41:24.000Z","comments":true,"path":"undefined/Preface/","link":"","permalink":"/undefined/Preface/","excerpt":"2021年1月31日半夜","text":"2021年1月31日半夜,躺在床上想着.因为今天下午的一道算法题我死活也写不出来(涉及知识盲区),翻了好多CSDN大佬们的博客终于有了思路.我在想,我是不是也可以搭一个属于自己的博客?就这样我溜到电脑旁,开始在网上寻找搭建博客的教程.相比于教程所演示的步骤以及最后的结果,我的却是漏洞百出. 第不知道第几个の漏洞:) ) 内心OS![] 就这样,我嗯是折腾到了凌晨2点半(2点的那条朋友圈发出来之后,我又发现博客有问题,然后又爬起来改……) And…就这样,2021年2月1日,Franの杂货铺算是“正式”测试营业了.你们可能想问博客都应该写些啥东西,都说了是杂货铺,种类肯定会比较繁多.不过可能还是会以知识技术(计算机)有关. However…以我现在的程度,能学会总结一些学科的知识点就已经很不错了.(我的总结能力有所欠缺,所以我总是一学就懂,一做就错.新知识”复写”(override)旧知识) Finally…我希望自己能坚持下去,不断完善博客的功能(留言板，评论板……),提高自己的总结能力,另外能加强自己语言表达能力就更好了(我的表达能力像稀饭一样).为什么我大一的时候没有想到搭博客……(掌嘴中)","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Keep searching......","slug":"hello-world-zy","date":"2021-01-31T08:00:00.000Z","updated":"2021-03-14T06:41:50.000Z","comments":true,"path":"undefined/hello-world-zy/","link":"","permalink":"/undefined/hello-world-zy/","excerpt":"","text":"Fran还在努力寻找资源……","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"待添加......","slug":"hello-world-tech","date":"2021-01-31T08:00:00.000Z","updated":"2021-03-14T06:41:32.000Z","comments":true,"path":"undefined/hello-world-tech/","link":"","permalink":"/undefined/hello-world-tech/","excerpt":"","text":"2 b continued……","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}